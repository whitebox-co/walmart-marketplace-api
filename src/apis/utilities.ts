/* tslint:disable */
/* eslint-disable */
/**
 * Utilities Management
 * Utilities Management API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * The category name for which the top trending items have to be fetched
     * @type {string}
     * @memberof Category
     */
    categoryName?: string;
    /**
     * The category id for which the top trending items have to be fetched
     * @type {string}
     * @memberof Category
     */
    categoryId?: string;
}
/**
 * 
 * @export
 * @interface CategoryPayload
 */
export interface CategoryPayload {
    /**
     * Type of item
     * @type {string}
     * @memberof CategoryPayload
     */
    category?: string;
    /**
     * Specific kind of category
     * @type {Array<InlineResponse200Subcategory>}
     * @memberof CategoryPayload
     */
    subcategory?: Array<InlineResponse200Subcategory>;
}
/**
 * 
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * The department name for which the categories have to be fetched
     * @type {string}
     * @memberof Department
     */
    departmentName?: string;
    /**
     * The department id for which the categories have to be fetched
     * @type {string}
     * @memberof Department
     */
    departmentId?: string;
}
/**
 * 
 * @export
 * @interface GetCategories
 */
export interface GetCategories {
    /**
     * 
     * @type {string}
     * @memberof GetCategories
     */
    status?: string;
    /**
     * 
     * @type {InlineResponse2002Response}
     * @memberof GetCategories
     */
    response?: InlineResponse2002Response;
}
/**
 * 
 * @export
 * @interface GetDepartmentList
 */
export interface GetDepartmentList {
    /**
     * 
     * @type {string}
     * @memberof GetDepartmentList
     */
    status?: string;
    /**
     * 
     * @type {Array<InlineResponse2001Payload>}
     * @memberof GetDepartmentList
     */
    payload?: Array<InlineResponse2001Payload>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    status?: string;
    /**
     * 
     * @type {Array<InlineResponse200Payload>}
     * @memberof InlineResponse200
     */
    payload?: Array<InlineResponse200Payload>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    status?: string;
    /**
     * 
     * @type {Array<InlineResponse2001Payload>}
     * @memberof InlineResponse2001
     */
    payload?: Array<InlineResponse2001Payload>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001Departments
 */
export interface InlineResponse2001Departments {
    /**
     * The department name for which the categories have to be fetched
     * @type {string}
     * @memberof InlineResponse2001Departments
     */
    departmentName?: string;
    /**
     * The department id for which the categories have to be fetched
     * @type {string}
     * @memberof InlineResponse2001Departments
     */
    departmentId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001Payload
 */
export interface InlineResponse2001Payload {
    /**
     * The super-department name for which the department have to be fetched
     * @type {string}
     * @memberof InlineResponse2001Payload
     */
    superDepartment?: string;
    /**
     * The super-department id for which the department have to be fetched
     * @type {string}
     * @memberof InlineResponse2001Payload
     */
    superDepartmentId?: string;
    /**
     * 
     * @type {Array<InlineResponse2001Departments>}
     * @memberof InlineResponse2001Payload
     */
    departments?: Array<InlineResponse2001Departments>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    status?: string;
    /**
     * 
     * @type {InlineResponse2002Response}
     * @memberof InlineResponse2002
     */
    response?: InlineResponse2002Response;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Response
 */
export interface InlineResponse2002Response {
    /**
     * The department name for which the categories have to be fetched
     * @type {string}
     * @memberof InlineResponse2002Response
     */
    departmentName?: string;
    /**
     * The department id for which the categories have to be fetched
     * @type {string}
     * @memberof InlineResponse2002Response
     */
    departmentId?: string;
    /**
     * 
     * @type {Array<InlineResponse2002ResponseCategory>}
     * @memberof InlineResponse2002Response
     */
    category?: Array<InlineResponse2002ResponseCategory>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002ResponseCategory
 */
export interface InlineResponse2002ResponseCategory {
    /**
     * The category name for which the top trending items have to be fetched
     * @type {string}
     * @memberof InlineResponse2002ResponseCategory
     */
    categoryName?: string;
    /**
     * The category id for which the top trending items have to be fetched
     * @type {string}
     * @memberof InlineResponse2002ResponseCategory
     */
    categoryId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * A-List of all API statuses
     * @type {Array<InlineResponse2003ApiStatuses>}
     * @memberof InlineResponse2003
     */
    apiStatuses?: Array<InlineResponse2003ApiStatuses>;
}
/**
 * A-List of all API statuses
 * @export
 * @interface InlineResponse2003ApiStatuses
 */
export interface InlineResponse2003ApiStatuses {
    /**
     * The marketplace api group
     * @type {string}
     * @memberof InlineResponse2003ApiStatuses
     */
    apiGroup?: InlineResponse2003ApiStatusesApiGroupEnum;
    /**
     * The current status of marketplace api group
     * @type {string}
     * @memberof InlineResponse2003ApiStatuses
     */
    status?: InlineResponse2003ApiStatusesStatusEnum;
    /**
     * The time at which the status of api group collected. This datetime field is in the ISO 8601 format.
     * @type {string}
     * @memberof InlineResponse2003ApiStatuses
     */
    lastUpdatedTime?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003ApiStatusesApiGroupEnum {
    Returns = 'Returns',
    Items = 'Items',
    Sandbox = 'Sandbox',
    Lagtime = 'Lagtime',
    Promos = 'Promos',
    Orders = 'Orders',
    Authentication = 'Authentication',
    Price = 'Price',
    Refunds = 'Refunds',
    Authorization = 'Authorization',
    Inventory = 'Inventory'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003ApiStatusesStatusEnum {
    Operational = 'OPERATIONAL',
    ServiceDegradation = 'SERVICE_DEGRADATION',
    ServiceOutage = 'SERVICE_OUTAGE',
    Unknown = 'UNKNOWN'
}

/**
 * 
 * @export
 * @interface InlineResponse200Payload
 */
export interface InlineResponse200Payload {
    /**
     * Type of item
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    category?: string;
    /**
     * Specific kind of category
     * @type {Array<InlineResponse200Subcategory>}
     * @memberof InlineResponse200Payload
     */
    subcategory?: Array<InlineResponse200Subcategory>;
}
/**
 * Specific kind of category
 * @export
 * @interface InlineResponse200Subcategory
 */
export interface InlineResponse200Subcategory {
    /**
     * Name of specific kind of category
     * @type {string}
     * @memberof InlineResponse200Subcategory
     */
    subCategoryName?: string;
    /**
     * ID of specific kind of category
     * @type {string}
     * @memberof InlineResponse200Subcategory
     */
    subCategoryId?: string;
}
/**
 * 
 * @export
 * @interface Payload
 */
export interface Payload {
    /**
     * The super-department name for which the department have to be fetched
     * @type {string}
     * @memberof Payload
     */
    superDepartment?: string;
    /**
     * The super-department id for which the department have to be fetched
     * @type {string}
     * @memberof Payload
     */
    superDepartmentId?: string;
    /**
     * 
     * @type {Array<InlineResponse2001Departments>}
     * @memberof Payload
     */
    departments?: Array<InlineResponse2001Departments>;
}
/**
 * 
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * The department name for which the categories have to be fetched
     * @type {string}
     * @memberof Response
     */
    departmentName?: string;
    /**
     * The department id for which the categories have to be fetched
     * @type {string}
     * @memberof Response
     */
    departmentId?: string;
    /**
     * 
     * @type {Array<InlineResponse2002ResponseCategory>}
     * @memberof Response
     */
    category?: Array<InlineResponse2002ResponseCategory>;
}
/**
 * 
 * @export
 * @interface StatusAPIResponse
 */
export interface StatusAPIResponse {
    /**
     * A-List of all API statuses
     * @type {Array<InlineResponse2003ApiStatuses>}
     * @memberof StatusAPIResponse
     */
    apiStatuses?: Array<InlineResponse2003ApiStatuses>;
}
/**
 * A-List of all API statuses
 * @export
 * @interface StatusAPIResponseDTO
 */
export interface StatusAPIResponseDTO {
    /**
     * The marketplace api group
     * @type {string}
     * @memberof StatusAPIResponseDTO
     */
    apiGroup?: StatusAPIResponseDTOApiGroupEnum;
    /**
     * The current status of marketplace api group
     * @type {string}
     * @memberof StatusAPIResponseDTO
     */
    status?: StatusAPIResponseDTOStatusEnum;
    /**
     * The time at which the status of api group collected. This datetime field is in the ISO 8601 format.
     * @type {string}
     * @memberof StatusAPIResponseDTO
     */
    lastUpdatedTime?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum StatusAPIResponseDTOApiGroupEnum {
    Returns = 'Returns',
    Items = 'Items',
    Sandbox = 'Sandbox',
    Lagtime = 'Lagtime',
    Promos = 'Promos',
    Orders = 'Orders',
    Authentication = 'Authentication',
    Price = 'Price',
    Refunds = 'Refunds',
    Authorization = 'Authorization',
    Inventory = 'Inventory'
}
/**
    * @export
    * @enum {string}
    */
export enum StatusAPIResponseDTOStatusEnum {
    Operational = 'OPERATIONAL',
    ServiceDegradation = 'SERVICE_DEGRADATION',
    ServiceOutage = 'SERVICE_OUTAGE',
    Unknown = 'UNKNOWN'
}

/**
 * Specific kind of category
 * @export
 * @interface SubCategory
 */
export interface SubCategory {
    /**
     * Name of specific kind of category
     * @type {string}
     * @memberof SubCategory
     */
    subCategoryName?: string;
    /**
     * ID of specific kind of category
     * @type {string}
     * @memberof SubCategory
     */
    subCategoryId?: string;
}
/**
 * 
 * @export
 * @interface TaxonomyResponseDTO
 */
export interface TaxonomyResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof TaxonomyResponseDTO
     */
    status?: string;
    /**
     * 
     * @type {Array<InlineResponse200Payload>}
     * @memberof TaxonomyResponseDTO
     */
    payload?: Array<InlineResponse200Payload>;
}

/**
 * UtilitiesApi - axios parameter creator
 * @export
 */
export const UtilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all marketplace Apis status
         * @summary API Platform Status
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiPlatformStatus: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getApiPlatformStatus', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getApiPlatformStatus', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getApiPlatformStatus', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/utilities/apiStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of categories for a specific department
         * @summary All Categories
         * @param {string} departmentId departmentId
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (departmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'departmentId' is not null or undefined
            assertParamExists('getCategories', 'departmentId', departmentId)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getCategories', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getCategories', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getCategories', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/utilities/taxonomy/departments/{departmentId}`
                .replace(`{${"departmentId"}}`, encodeURIComponent(String(departmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of departments
         * @summary All Departments
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentList: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getDepartmentList', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getDepartmentList', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getDepartmentList', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/utilities/taxonomy/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Taxonomy by Item spec API exposes the category taxonomy that Walmart.com uses to categorize items for each Item spec version. It returns a list of all Categories and Sub-categories that are available on Walmart.com for the Item spec version you specify. You can specify the feedType and version for these available Item specs. Make sure to specify the corresponding version that is available for that feed type: *   Item spec 3.2 feed type: item *   Item spec 4.0 feed types: MP_ITEM, MP_WFS_ITEM, or MP_MAINTENANCE *   Item spec 4.1 feed types: MP_WFS_ITEM, or MP_MAINTENANCE *   Item spec 4.2 feed type: MP_ITEM or MP_WFS_ITEM *   Item spec 4.3 feed type: MP_ITEM or MP_MAINTENANCE
         * @summary Taxonomy by spec
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {'item' | 'MP_ITEM' | 'MP_WFS_ITEM' | 'MP_MAINTENANCE'} [feedType] Specifies the Feed Type
         * @param {'3.2' | '4.0' | '4.1' | '4.2'} [version] Specifies the version for the Feed Type
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxonomyResponse: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, feedType?: 'item' | 'MP_ITEM' | 'MP_WFS_ITEM' | 'MP_MAINTENANCE', version?: '3.2' | '4.0' | '4.1' | '4.2', wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getTaxonomyResponse', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getTaxonomyResponse', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getTaxonomyResponse', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/utilities/taxonomy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilitiesApi - functional programming interface
 * @export
 */
export const UtilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all marketplace Apis status
         * @summary API Platform Status
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiPlatformStatus(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiPlatformStatus(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of categories for a specific department
         * @summary All Categories
         * @param {string} departmentId departmentId
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(departmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(departmentId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of departments
         * @summary All Departments
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepartmentList(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartmentList(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Taxonomy by Item spec API exposes the category taxonomy that Walmart.com uses to categorize items for each Item spec version. It returns a list of all Categories and Sub-categories that are available on Walmart.com for the Item spec version you specify. You can specify the feedType and version for these available Item specs. Make sure to specify the corresponding version that is available for that feed type: *   Item spec 3.2 feed type: item *   Item spec 4.0 feed types: MP_ITEM, MP_WFS_ITEM, or MP_MAINTENANCE *   Item spec 4.1 feed types: MP_WFS_ITEM, or MP_MAINTENANCE *   Item spec 4.2 feed type: MP_ITEM or MP_WFS_ITEM *   Item spec 4.3 feed type: MP_ITEM or MP_MAINTENANCE
         * @summary Taxonomy by spec
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {'item' | 'MP_ITEM' | 'MP_WFS_ITEM' | 'MP_MAINTENANCE'} [feedType] Specifies the Feed Type
         * @param {'3.2' | '4.0' | '4.1' | '4.2'} [version] Specifies the version for the Feed Type
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaxonomyResponse(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, feedType?: 'item' | 'MP_ITEM' | 'MP_WFS_ITEM' | 'MP_MAINTENANCE', version?: '3.2' | '4.0' | '4.1' | '4.2', wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaxonomyResponse(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, feedType, version, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UtilitiesApi - factory interface
 * @export
 */
export const UtilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilitiesApiFp(configuration)
    return {
        /**
         * Get all marketplace Apis status
         * @summary API Platform Status
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiPlatformStatus(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getApiPlatformStatus(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of categories for a specific department
         * @summary All Categories
         * @param {string} departmentId departmentId
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(departmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getCategories(departmentId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of departments
         * @summary All Departments
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentList(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getDepartmentList(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The Taxonomy by Item spec API exposes the category taxonomy that Walmart.com uses to categorize items for each Item spec version. It returns a list of all Categories and Sub-categories that are available on Walmart.com for the Item spec version you specify. You can specify the feedType and version for these available Item specs. Make sure to specify the corresponding version that is available for that feed type: *   Item spec 3.2 feed type: item *   Item spec 4.0 feed types: MP_ITEM, MP_WFS_ITEM, or MP_MAINTENANCE *   Item spec 4.1 feed types: MP_WFS_ITEM, or MP_MAINTENANCE *   Item spec 4.2 feed type: MP_ITEM or MP_WFS_ITEM *   Item spec 4.3 feed type: MP_ITEM or MP_MAINTENANCE
         * @summary Taxonomy by spec
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {'item' | 'MP_ITEM' | 'MP_WFS_ITEM' | 'MP_MAINTENANCE'} [feedType] Specifies the Feed Type
         * @param {'3.2' | '4.0' | '4.1' | '4.2'} [version] Specifies the version for the Feed Type
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxonomyResponse(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, feedType?: 'item' | 'MP_ITEM' | 'MP_WFS_ITEM' | 'MP_MAINTENANCE', version?: '3.2' | '4.0' | '4.1' | '4.2', wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getTaxonomyResponse(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, feedType, version, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getApiPlatformStatus operation in UtilitiesApi.
 * @export
 * @interface UtilitiesApiGetApiPlatformStatusRequest
 */
export interface UtilitiesApiGetApiPlatformStatusRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof UtilitiesApiGetApiPlatformStatus
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof UtilitiesApiGetApiPlatformStatus
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof UtilitiesApiGetApiPlatformStatus
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof UtilitiesApiGetApiPlatformStatus
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getCategories operation in UtilitiesApi.
 * @export
 * @interface UtilitiesApiGetCategoriesRequest
 */
export interface UtilitiesApiGetCategoriesRequest {
    /**
     * departmentId
     * @type {string}
     * @memberof UtilitiesApiGetCategories
     */
    readonly departmentId: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof UtilitiesApiGetCategories
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof UtilitiesApiGetCategories
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof UtilitiesApiGetCategories
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof UtilitiesApiGetCategories
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getDepartmentList operation in UtilitiesApi.
 * @export
 * @interface UtilitiesApiGetDepartmentListRequest
 */
export interface UtilitiesApiGetDepartmentListRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof UtilitiesApiGetDepartmentList
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof UtilitiesApiGetDepartmentList
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof UtilitiesApiGetDepartmentList
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof UtilitiesApiGetDepartmentList
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getTaxonomyResponse operation in UtilitiesApi.
 * @export
 * @interface UtilitiesApiGetTaxonomyResponseRequest
 */
export interface UtilitiesApiGetTaxonomyResponseRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof UtilitiesApiGetTaxonomyResponse
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof UtilitiesApiGetTaxonomyResponse
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof UtilitiesApiGetTaxonomyResponse
     */
    readonly wMSVCNAME: string

    /**
     * Specifies the Feed Type
     * @type {'item' | 'MP_ITEM' | 'MP_WFS_ITEM' | 'MP_MAINTENANCE'}
     * @memberof UtilitiesApiGetTaxonomyResponse
     */
    readonly feedType?: 'item' | 'MP_ITEM' | 'MP_WFS_ITEM' | 'MP_MAINTENANCE'

    /**
     * Specifies the version for the Feed Type
     * @type {'3.2' | '4.0' | '4.1' | '4.2'}
     * @memberof UtilitiesApiGetTaxonomyResponse
     */
    readonly version?: '3.2' | '4.0' | '4.1' | '4.2'

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof UtilitiesApiGetTaxonomyResponse
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * UtilitiesApi - object-oriented interface
 * @export
 * @class UtilitiesApi
 * @extends {BaseAPI}
 */
export class UtilitiesApi extends BaseAPI {
    /**
     * Get all marketplace Apis status
     * @summary API Platform Status
     * @param {UtilitiesApiGetApiPlatformStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public getApiPlatformStatus(requestParameters: UtilitiesApiGetApiPlatformStatusRequest, options?: any) {
        return UtilitiesApiFp(this.configuration).getApiPlatformStatus(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of categories for a specific department
     * @summary All Categories
     * @param {UtilitiesApiGetCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public getCategories(requestParameters: UtilitiesApiGetCategoriesRequest, options?: any) {
        return UtilitiesApiFp(this.configuration).getCategories(requestParameters.departmentId, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of departments
     * @summary All Departments
     * @param {UtilitiesApiGetDepartmentListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public getDepartmentList(requestParameters: UtilitiesApiGetDepartmentListRequest, options?: any) {
        return UtilitiesApiFp(this.configuration).getDepartmentList(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Taxonomy by Item spec API exposes the category taxonomy that Walmart.com uses to categorize items for each Item spec version. It returns a list of all Categories and Sub-categories that are available on Walmart.com for the Item spec version you specify. You can specify the feedType and version for these available Item specs. Make sure to specify the corresponding version that is available for that feed type: *   Item spec 3.2 feed type: item *   Item spec 4.0 feed types: MP_ITEM, MP_WFS_ITEM, or MP_MAINTENANCE *   Item spec 4.1 feed types: MP_WFS_ITEM, or MP_MAINTENANCE *   Item spec 4.2 feed type: MP_ITEM or MP_WFS_ITEM *   Item spec 4.3 feed type: MP_ITEM or MP_MAINTENANCE
     * @summary Taxonomy by spec
     * @param {UtilitiesApiGetTaxonomyResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public getTaxonomyResponse(requestParameters: UtilitiesApiGetTaxonomyResponseRequest, options?: any) {
        return UtilitiesApiFp(this.configuration).getTaxonomyResponse(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.feedType, requestParameters.version, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


