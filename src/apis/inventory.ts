/* tslint:disable */
/* eslint-disable */
/**
 * Inventory Management
 * Maintaining up-to-date inventory for your items on Walmart.com ensures a great experience for your customers and greater sales opportunities for you.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Quantity of an item that is available to be allocated to orders
 * @export
 * @interface AvailToSellQty
 */
export interface AvailToSellQty {
    /**
     * The unit of measurement. Example: \'EACH\'
     * @type {string}
     * @memberof AvailToSellQty
     */
    unit: AvailToSellQtyUnitEnum;
    /**
     * Inventory Count
     * @type {number}
     * @memberof AvailToSellQty
     */
    amount: number;
}

/**
    * @export
    * @enum {string}
    */
export enum AvailToSellQtyUnitEnum {
    Each = 'EACH'
}

/**
 * 
 * @export
 * @interface Cause
 */
export interface Cause {
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Elements
 */
export interface Elements {
    /**
     * 
     * @type {Array<InlineResponse200ElementsInventories>}
     * @memberof Elements
     */
    inventories?: Array<InlineResponse200ElementsInventories>;
}
/**
 * 
 * @export
 * @interface FeedId
 */
export interface FeedId {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
     * @type {string}
     * @memberof FeedId
     */
    feedId?: string;
    /**
     * 
     * @type {object}
     * @memberof FeedId
     */
    additionalAttributes?: object | null;
    /**
     * 
     * @type {object}
     * @memberof FeedId
     */
    errors?: object | null;
}
/**
 * 
 * @export
 * @interface GetAllInventoriesDTO
 */
export interface GetAllInventoriesDTO {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof GetAllInventoriesDTO
     */
    sku?: string;
    /**
     * 
     * @type {Array<InlineResponse200ElementsNodes>}
     * @memberof GetAllInventoriesDTO
     */
    nodes?: Array<InlineResponse200ElementsNodes>;
}
/**
 * 
 * @export
 * @interface GetAllInventoriesNodeDTO
 */
export interface GetAllInventoriesNodeDTO {
    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof GetAllInventoriesNodeDTO
     */
    shipNode?: string;
    /**
     * 
     * @type {InlineResponse200ElementsInputQty}
     * @memberof GetAllInventoriesNodeDTO
     */
    inputQty?: InlineResponse200ElementsInputQty;
    /**
     * 
     * @type {InlineResponse200ElementsAvailToSellQty}
     * @memberof GetAllInventoriesNodeDTO
     */
    availToSellQty?: InlineResponse200ElementsAvailToSellQty;
    /**
     * 
     * @type {InlineResponse200ElementsReservedQty}
     * @memberof GetAllInventoriesNodeDTO
     */
    reservedQty?: InlineResponse200ElementsReservedQty;
}
/**
 * 
 * @export
 * @interface Headers
 */
export interface Headers {
    /**
     * Total number of results for query.
     * @type {number}
     * @memberof Headers
     */
    totalCount?: number;
    /**
     * Information about the quantity in inventory
     * @type {number}
     * @memberof Headers
     */
    limit?: number;
    /**
     * Offset is the number of records you wish to skip before selecting results.
     * @type {number}
     * @memberof Headers
     */
    offset?: number;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {V3InventoriesSkuInventories}
     * @memberof InlineObject
     */
    inventories: V3InventoriesSkuInventories;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * A seller-provided Product ID. Response will have decoded value.
     * @type {string}
     * @memberof InlineObject1
     */
    sku: string;
    /**
     * 
     * @type {V3InventoriesSkuInventoriesInputQty}
     * @memberof InlineObject1
     */
    quantity: V3InventoriesSkuInventoriesInputQty;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse200
     */
    meta?: InlineResponse200Meta;
    /**
     * 
     * @type {InlineResponse200Elements}
     * @memberof InlineResponse200
     */
    elements?: InlineResponse200Elements;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InlineResponse2001
     */
    sku?: string;
    /**
     * 
     * @type {Array<InlineResponse2001Nodes>}
     * @memberof InlineResponse2001
     */
    nodes?: Array<InlineResponse2001Nodes>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001Causes
 */
export interface InlineResponse2001Causes {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Causes
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Causes
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Causes
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Causes
     */
    description?: string;
}
/**
 * Node Update Error description.
 * @export
 * @interface InlineResponse2001Errors
 */
export interface InlineResponse2001Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Errors
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Errors
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Errors
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Errors
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Errors
     */
    severity?: InlineResponse2001ErrorsSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Errors
     */
    category?: InlineResponse2001ErrorsCategoryEnum;
    /**
     * 
     * @type {Array<InlineResponse2001Causes>}
     * @memberof InlineResponse2001Errors
     */
    causes?: Array<InlineResponse2001Causes>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse2001Errors
     */
    errorIdentifiers?: { [key: string]: object; };
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2001ErrorsSeverityEnum {
    Info = 'INFO',
    Warn = 'WARN',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2001ErrorsCategoryEnum {
    Application = 'APPLICATION',
    System = 'SYSTEM',
    Request = 'REQUEST',
    Data = 'DATA'
}

/**
 * 
 * @export
 * @interface InlineResponse2001Nodes
 */
export interface InlineResponse2001Nodes {
    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof InlineResponse2001Nodes
     */
    shipNode?: string;
    /**
     * 
     * @type {InlineResponse200ElementsInputQty}
     * @memberof InlineResponse2001Nodes
     */
    inputQty?: InlineResponse200ElementsInputQty;
    /**
     * 
     * @type {InlineResponse200ElementsAvailToSellQty}
     * @memberof InlineResponse2001Nodes
     */
    availToSellQty?: InlineResponse200ElementsAvailToSellQty;
    /**
     * 
     * @type {Array<InlineResponse2001Errors>}
     * @memberof InlineResponse2001Nodes
     */
    errors?: Array<InlineResponse2001Errors>;
    /**
     * 
     * @type {InlineResponse200ElementsReservedQty}
     * @memberof InlineResponse2001Nodes
     */
    reservedQty?: InlineResponse200ElementsReservedQty;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InlineResponse2002
     */
    sku?: string;
    /**
     * 
     * @type {Array<InlineResponse2002Nodes>}
     * @memberof InlineResponse2002
     */
    nodes?: Array<InlineResponse2002Nodes>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Nodes
 */
export interface InlineResponse2002Nodes {
    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof InlineResponse2002Nodes
     */
    shipNode?: string;
    /**
     * Node Update status. Example: \'Success\'
     * @type {string}
     * @memberof InlineResponse2002Nodes
     */
    status?: string;
    /**
     * Node Update Error description.
     * @type {Array<InlineResponse2001Errors>}
     * @memberof InlineResponse2002Nodes
     */
    errors?: Array<InlineResponse2001Errors>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * A seller-provided Product ID. Response will have decoded value.
     * @type {string}
     * @memberof InlineResponse2003
     */
    sku: string;
    /**
     * 
     * @type {V3InventoriesSkuInventoriesInputQty}
     * @memberof InlineResponse2003
     */
    quantity: V3InventoriesSkuInventoriesInputQty;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {InlineResponse2004Headers}
     * @memberof InlineResponse2004
     */
    headers?: InlineResponse2004Headers;
    /**
     * 
     * @type {InlineResponse2004Payload}
     * @memberof InlineResponse2004
     */
    payload?: InlineResponse2004Payload;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Headers
 */
export interface InlineResponse2004Headers {
    /**
     * Total number of results for query.
     * @type {number}
     * @memberof InlineResponse2004Headers
     */
    totalCount?: number;
    /**
     * Information about the quantity in inventory
     * @type {number}
     * @memberof InlineResponse2004Headers
     */
    limit?: number;
    /**
     * Offset is the number of records you wish to skip before selecting results.
     * @type {number}
     * @memberof InlineResponse2004Headers
     */
    offset?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Payload
 */
export interface InlineResponse2004Payload {
    /**
     * 
     * @type {Array<InlineResponse2004PayloadInventory>}
     * @memberof InlineResponse2004Payload
     */
    inventory?: Array<InlineResponse2004PayloadInventory>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004PayloadInventory
 */
export interface InlineResponse2004PayloadInventory {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InlineResponse2004PayloadInventory
     */
    sku?: string;
    /**
     * 
     * @type {Array<InlineResponse2004PayloadShipNodes>}
     * @memberof InlineResponse2004PayloadInventory
     */
    shipNodes?: Array<InlineResponse2004PayloadShipNodes>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004PayloadShipNodes
 */
export interface InlineResponse2004PayloadShipNodes {
    /**
     * Last changes date for the item.
     * @type {string}
     * @memberof InlineResponse2004PayloadShipNodes
     */
    modifiedDate?: string;
    /**
     * The available quantity is the quantity of an item that is available to be allocated to orders.
     * @type {number}
     * @memberof InlineResponse2004PayloadShipNodes
     */
    availToSellQty?: number;
    /**
     * The on-hand balance is the quantity of active inventory stored at the warehouse.Active inventory is defined as the usable amount of an item that is in the warehouse.Inventory is active if it is not damaged, expired or being inspected.
     * @type {number}
     * @memberof InlineResponse2004PayloadShipNodes
     */
    onHandQty?: number;
    /**
     * Identifies fulfillment aspect of invetory. Walmart, seller or 3PL fulfilled. Possible value is \'WFSFulfilled\'. In later phase we will also add seller fulfilled inventory.
     * @type {string}
     * @memberof InlineResponse2004PayloadShipNodes
     */
    shipNodeType?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
     * @type {string}
     * @memberof InlineResponse2005
     */
    feedId?: string;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2005
     */
    additionalAttributes?: object | null;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2005
     */
    errors?: object | null;
}
/**
 * 
 * @export
 * @interface InlineResponse200Elements
 */
export interface InlineResponse200Elements {
    /**
     * 
     * @type {Array<InlineResponse200ElementsInventories>}
     * @memberof InlineResponse200Elements
     */
    inventories?: Array<InlineResponse200ElementsInventories>;
}
/**
 * Quantity of an item that is available to be allocated to orders
 * @export
 * @interface InlineResponse200ElementsAvailToSellQty
 */
export interface InlineResponse200ElementsAvailToSellQty {
    /**
     * The unit of measurement. Example: \'EACH\'
     * @type {string}
     * @memberof InlineResponse200ElementsAvailToSellQty
     */
    unit: InlineResponse200ElementsAvailToSellQtyUnitEnum;
    /**
     * Inventory Count
     * @type {number}
     * @memberof InlineResponse200ElementsAvailToSellQty
     */
    amount: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200ElementsAvailToSellQtyUnitEnum {
    Each = 'EACH'
}

/**
 * Quantity of an item that is input by the seller
 * @export
 * @interface InlineResponse200ElementsInputQty
 */
export interface InlineResponse200ElementsInputQty {
    /**
     * The unit of measurement. Example: \'EACH\'
     * @type {string}
     * @memberof InlineResponse200ElementsInputQty
     */
    unit: InlineResponse200ElementsInputQtyUnitEnum;
    /**
     * Inventory Count
     * @type {number}
     * @memberof InlineResponse200ElementsInputQty
     */
    amount: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200ElementsInputQtyUnitEnum {
    Each = 'EACH'
}

/**
 * 
 * @export
 * @interface InlineResponse200ElementsInventories
 */
export interface InlineResponse200ElementsInventories {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InlineResponse200ElementsInventories
     */
    sku?: string;
    /**
     * 
     * @type {Array<InlineResponse200ElementsNodes>}
     * @memberof InlineResponse200ElementsInventories
     */
    nodes?: Array<InlineResponse200ElementsNodes>;
}
/**
 * 
 * @export
 * @interface InlineResponse200ElementsNodes
 */
export interface InlineResponse200ElementsNodes {
    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof InlineResponse200ElementsNodes
     */
    shipNode?: string;
    /**
     * 
     * @type {InlineResponse200ElementsInputQty}
     * @memberof InlineResponse200ElementsNodes
     */
    inputQty?: InlineResponse200ElementsInputQty;
    /**
     * 
     * @type {InlineResponse200ElementsAvailToSellQty}
     * @memberof InlineResponse200ElementsNodes
     */
    availToSellQty?: InlineResponse200ElementsAvailToSellQty;
    /**
     * 
     * @type {InlineResponse200ElementsReservedQty}
     * @memberof InlineResponse200ElementsNodes
     */
    reservedQty?: InlineResponse200ElementsReservedQty;
}
/**
 * Quantity that has been ordered by the customers but not yet shipped
 * @export
 * @interface InlineResponse200ElementsReservedQty
 */
export interface InlineResponse200ElementsReservedQty {
    /**
     * The unit of measurement. Example: \'EACH\'
     * @type {string}
     * @memberof InlineResponse200ElementsReservedQty
     */
    unit: InlineResponse200ElementsReservedQtyUnitEnum;
    /**
     * Inventory Count
     * @type {number}
     * @memberof InlineResponse200ElementsReservedQty
     */
    amount: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200ElementsReservedQtyUnitEnum {
    Each = 'EACH'
}

/**
 * 
 * @export
 * @interface InlineResponse200Meta
 */
export interface InlineResponse200Meta {
    /**
     * Total number of Skus of the Seller. Example: \'235\'
     * @type {number}
     * @memberof InlineResponse200Meta
     */
    totalCount?: number;
    /**
     * Used for pagination to fetch the next set of items.
     * @type {string}
     * @memberof InlineResponse200Meta
     */
    nextCursor?: string;
}
/**
 * Quantity of an item that is input by the seller
 * @export
 * @interface InputQty
 */
export interface InputQty {
    /**
     * The unit of measurement. Example: \'EACH\'
     * @type {string}
     * @memberof InputQty
     */
    unit: InputQtyUnitEnum;
    /**
     * Inventory Count
     * @type {number}
     * @memberof InputQty
     */
    amount: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InputQtyUnitEnum {
    Each = 'EACH'
}

/**
 * 
 * @export
 * @interface InventoriesDTO
 */
export interface InventoriesDTO {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InventoriesDTO
     */
    sku?: string;
    /**
     * 
     * @type {Array<InlineResponse2001Nodes>}
     * @memberof InventoriesDTO
     */
    nodes?: Array<InlineResponse2001Nodes>;
}
/**
 * 
 * @export
 * @interface Inventory
 */
export interface Inventory {
    /**
     * A seller-provided Product ID. Response will have decoded value.
     * @type {string}
     * @memberof Inventory
     */
    sku: string;
    /**
     * 
     * @type {V3InventoriesSkuInventoriesInputQty}
     * @memberof Inventory
     */
    quantity: V3InventoriesSkuInventoriesInputQty;
}
/**
 * 
 * @export
 * @interface InventoryWFS
 */
export interface InventoryWFS {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InventoryWFS
     */
    sku?: string;
    /**
     * 
     * @type {Array<InlineResponse2004PayloadShipNodes>}
     * @memberof InventoryWFS
     */
    shipNodes?: Array<InlineResponse2004PayloadShipNodes>;
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * Total number of Skus of the Seller. Example: \'235\'
     * @type {number}
     * @memberof Meta
     */
    totalCount?: number;
    /**
     * Used for pagination to fetch the next set of items.
     * @type {string}
     * @memberof Meta
     */
    nextCursor?: string;
}
/**
 * Node Update Error description.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    severity?: ModelErrorSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    category?: ModelErrorCategoryEnum;
    /**
     * 
     * @type {Array<InlineResponse2001Causes>}
     * @memberof ModelError
     */
    causes?: Array<InlineResponse2001Causes>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModelError
     */
    errorIdentifiers?: { [key: string]: object; };
}

/**
    * @export
    * @enum {string}
    */
export enum ModelErrorSeverityEnum {
    Info = 'INFO',
    Warn = 'WARN',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum ModelErrorCategoryEnum {
    Application = 'APPLICATION',
    System = 'SYSTEM',
    Request = 'REQUEST',
    Data = 'DATA'
}

/**
 * 
 * @export
 * @interface MultiNodeInventoryFetchResponseDTO
 */
export interface MultiNodeInventoryFetchResponseDTO {
    /**
     * 
     * @type {InlineResponse200Meta}
     * @memberof MultiNodeInventoryFetchResponseDTO
     */
    meta?: InlineResponse200Meta;
    /**
     * 
     * @type {InlineResponse200Elements}
     * @memberof MultiNodeInventoryFetchResponseDTO
     */
    elements?: InlineResponse200Elements;
}
/**
 * 
 * @export
 * @interface MultiNodeInventoryUpdateRequestDTO
 */
export interface MultiNodeInventoryUpdateRequestDTO {
    /**
     * 
     * @type {V3InventoriesSkuInventories}
     * @memberof MultiNodeInventoryUpdateRequestDTO
     */
    inventories: V3InventoriesSkuInventories;
}
/**
 * 
 * @export
 * @interface MultiNodeInventoryUpdateResponseDTO
 */
export interface MultiNodeInventoryUpdateResponseDTO {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof MultiNodeInventoryUpdateResponseDTO
     */
    sku?: string;
    /**
     * 
     * @type {Array<InlineResponse2002Nodes>}
     * @memberof MultiNodeInventoryUpdateResponseDTO
     */
    nodes?: Array<InlineResponse2002Nodes>;
}
/**
 * 
 * @export
 * @interface NodeDTO
 */
export interface NodeDTO {
    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof NodeDTO
     */
    shipNode?: string;
    /**
     * 
     * @type {InlineResponse200ElementsInputQty}
     * @memberof NodeDTO
     */
    inputQty?: InlineResponse200ElementsInputQty;
    /**
     * 
     * @type {InlineResponse200ElementsAvailToSellQty}
     * @memberof NodeDTO
     */
    availToSellQty?: InlineResponse200ElementsAvailToSellQty;
    /**
     * 
     * @type {Array<InlineResponse2001Errors>}
     * @memberof NodeDTO
     */
    errors?: Array<InlineResponse2001Errors>;
    /**
     * 
     * @type {InlineResponse200ElementsReservedQty}
     * @memberof NodeDTO
     */
    reservedQty?: InlineResponse200ElementsReservedQty;
}
/**
 * 
 * @export
 * @interface Payload
 */
export interface Payload {
    /**
     * 
     * @type {Array<InlineResponse2004PayloadInventory>}
     * @memberof Payload
     */
    inventory?: Array<InlineResponse2004PayloadInventory>;
}
/**
 * Quantity that has been ordered by the customers but not yet shipped
 * @export
 * @interface ReservedQty
 */
export interface ReservedQty {
    /**
     * The unit of measurement. Example: \'EACH\'
     * @type {string}
     * @memberof ReservedQty
     */
    unit: ReservedQtyUnitEnum;
    /**
     * Inventory Count
     * @type {number}
     * @memberof ReservedQty
     */
    amount: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ReservedQtyUnitEnum {
    Each = 'EACH'
}

/**
 * 
 * @export
 * @interface ShipNodes
 */
export interface ShipNodes {
    /**
     * Last changes date for the item.
     * @type {string}
     * @memberof ShipNodes
     */
    modifiedDate?: string;
    /**
     * The available quantity is the quantity of an item that is available to be allocated to orders.
     * @type {number}
     * @memberof ShipNodes
     */
    availToSellQty?: number;
    /**
     * The on-hand balance is the quantity of active inventory stored at the warehouse.Active inventory is defined as the usable amount of an item that is in the warehouse.Inventory is active if it is not damaged, expired or being inspected.
     * @type {number}
     * @memberof ShipNodes
     */
    onHandQty?: number;
    /**
     * Identifies fulfillment aspect of invetory. Walmart, seller or 3PL fulfilled. Possible value is \'WFSFulfilled\'. In later phase we will also add seller fulfilled inventory.
     * @type {string}
     * @memberof ShipNodes
     */
    shipNodeType?: string;
}
/**
 * Information about the quantity in inventory
 * @export
 * @interface SupplyQuantity
 */
export interface SupplyQuantity {
    /**
     * The unit of measurement. Example: \'EACH\'
     * @type {string}
     * @memberof SupplyQuantity
     */
    unit: SupplyQuantityUnitEnum;
    /**
     * Inventory Count
     * @type {number}
     * @memberof SupplyQuantity
     */
    amount: number;
}

/**
    * @export
    * @enum {string}
    */
export enum SupplyQuantityUnitEnum {
    Each = 'EACH'
}

/**
 * 
 * @export
 * @interface UpdateInventoriesRequestDTO
 */
export interface UpdateInventoriesRequestDTO {
    /**
     * 
     * @type {Array<V3InventoriesSkuInventoriesNodes>}
     * @memberof UpdateInventoriesRequestDTO
     */
    nodes: Array<V3InventoriesSkuInventoriesNodes>;
}
/**
 * 
 * @export
 * @interface UpdateInventoriesRequestNodeDTO
 */
export interface UpdateInventoriesRequestNodeDTO {
    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof UpdateInventoriesRequestNodeDTO
     */
    shipNode: string;
    /**
     * 
     * @type {V3InventoriesSkuInventoriesInputQty}
     * @memberof UpdateInventoriesRequestNodeDTO
     */
    inputQty: V3InventoriesSkuInventoriesInputQty;
}
/**
 * 
 * @export
 * @interface UpdateInventoriesResponseNodeDTO
 */
export interface UpdateInventoriesResponseNodeDTO {
    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof UpdateInventoriesResponseNodeDTO
     */
    shipNode?: string;
    /**
     * Node Update status. Example: \'Success\'
     * @type {string}
     * @memberof UpdateInventoriesResponseNodeDTO
     */
    status?: string;
    /**
     * Node Update Error description.
     * @type {Array<InlineResponse2001Errors>}
     * @memberof UpdateInventoriesResponseNodeDTO
     */
    errors?: Array<InlineResponse2001Errors>;
}
/**
 * 
 * @export
 * @interface V3InventoriesSkuInventories
 */
export interface V3InventoriesSkuInventories {
    /**
     * 
     * @type {Array<V3InventoriesSkuInventoriesNodes>}
     * @memberof V3InventoriesSkuInventories
     */
    nodes: Array<V3InventoriesSkuInventoriesNodes>;
}
/**
 * Information about the quantity in inventory
 * @export
 * @interface V3InventoriesSkuInventoriesInputQty
 */
export interface V3InventoriesSkuInventoriesInputQty {
    /**
     * The unit of measurement. Example: \'EACH\'
     * @type {string}
     * @memberof V3InventoriesSkuInventoriesInputQty
     */
    unit: V3InventoriesSkuInventoriesInputQtyUnitEnum;
    /**
     * Inventory Count
     * @type {number}
     * @memberof V3InventoriesSkuInventoriesInputQty
     */
    amount: number;
}

/**
    * @export
    * @enum {string}
    */
export enum V3InventoriesSkuInventoriesInputQtyUnitEnum {
    Each = 'EACH'
}

/**
 * 
 * @export
 * @interface V3InventoriesSkuInventoriesNodes
 */
export interface V3InventoriesSkuInventoriesNodes {
    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof V3InventoriesSkuInventoriesNodes
     */
    shipNode: string;
    /**
     * 
     * @type {V3InventoriesSkuInventoriesInputQty}
     * @memberof V3InventoriesSkuInventoriesNodes
     */
    inputQty: V3InventoriesSkuInventoriesInputQty;
}
/**
 * 
 * @export
 * @interface WfsInventoryDTO
 */
export interface WfsInventoryDTO {
    /**
     * 
     * @type {InlineResponse2004Headers}
     * @memberof WfsInventoryDTO
     */
    headers?: InlineResponse2004Headers;
    /**
     * 
     * @type {InlineResponse2004Payload}
     * @memberof WfsInventoryDTO
     */
    payload?: InlineResponse2004Payload;
}

/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You can use this API to get the inventory for a given item.
         * @summary Inventory
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’, \&#39;{\&#39;, \&#39;}\&#39; as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] The shipNode for which the inventory is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory: async (sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getInventory', 'sku', sku)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getInventory', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInventory', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMCONSUMERCHANNELTYPE' is not null or undefined
            assertParamExists('getInventory', 'wMCONSUMERCHANNELTYPE', wMCONSUMERCHANNELTYPE)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInventory', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInventory', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sku !== undefined) {
                localVarQueryParameter['sku'] = sku;
            }

            if (shipNode !== undefined) {
                localVarQueryParameter['shipNode'] = shipNode;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API will retrieve the inventory count for all of a seller\'s items across all ship nodes by item to ship node mapping. Inventory can be zero or non-zero.
         * @summary Multiple Item Inventory for All Ship Nodes
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [limit] The number of items returned. Cannot be more than 50.
         * @param {string} [nextCursor] String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiNodeInventoryForAllSkuAndAllShipNodes: async (authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, limit?: string, nextCursor?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getMultiNodeInventoryForAllSkuAndAllShipNodes', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getMultiNodeInventoryForAllSkuAndAllShipNodes', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMCONSUMERCHANNELTYPE' is not null or undefined
            assertParamExists('getMultiNodeInventoryForAllSkuAndAllShipNodes', 'wMCONSUMERCHANNELTYPE', wMCONSUMERCHANNELTYPE)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getMultiNodeInventoryForAllSkuAndAllShipNodes', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getMultiNodeInventoryForAllSkuAndAllShipNodes', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/inventories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API will retrieve the inventory count for an item across all ship nodes or one specific ship node. You can specify the ship node for which you want to fetch the inventory
         * @summary Single Item Inventory by Ship Node
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] ShipNode Id of the ship node for which the inventory is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiNodeInventoryForSkuAndAllShipnodes: async (sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getMultiNodeInventoryForSkuAndAllShipnodes', 'sku', sku)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getMultiNodeInventoryForSkuAndAllShipnodes', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getMultiNodeInventoryForSkuAndAllShipnodes', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMCONSUMERCHANNELTYPE' is not null or undefined
            assertParamExists('getMultiNodeInventoryForSkuAndAllShipnodes', 'wMCONSUMERCHANNELTYPE', wMCONSUMERCHANNELTYPE)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getMultiNodeInventoryForSkuAndAllShipnodes', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getMultiNodeInventoryForSkuAndAllShipnodes', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/inventories/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (shipNode !== undefined) {
                localVarQueryParameter['shipNode'] = shipNode;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use this API to get the current Available to Sell inventory quantities for all WFS items in your catalog. You can also query specific SKUs or filter to only items updated after a specific date in order to reduce the response size.
         * @summary WFS Inventory
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [sku] An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} [fromModifiedDate] last inventory modified date - starting range.
         * @param {string} [toModifiedDate] last inventory modified date - starting range.
         * @param {string} [limit] Number of Sku to be returned. Cannot be larger than 300.
         * @param {string} [offset] Offset is the number of records you wish to skip before selecting records.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWFSInventory: async (authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, sku?: string, fromModifiedDate?: string, toModifiedDate?: string, limit?: string, offset?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getWFSInventory', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getWFSInventory', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMCONSUMERCHANNELTYPE' is not null or undefined
            assertParamExists('getWFSInventory', 'wMCONSUMERCHANNELTYPE', wMCONSUMERCHANNELTYPE)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getWFSInventory', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getWFSInventory', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sku !== undefined) {
                localVarQueryParameter['sku'] = sku;
            }

            if (fromModifiedDate !== undefined) {
                localVarQueryParameter['fromModifiedDate'] = fromModifiedDate;
            }

            if (toModifiedDate !== undefined) {
                localVarQueryParameter['toModifiedDate'] = toModifiedDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates inventory for items in bulk.  Seller Can either use feed type \"inventory\" or \"MP_INVENTORY\"  * Inventory spec 1.4 feed type: inventory  * Inventory spec 1.5 feed type: MP_INVENTORY   Please Note: Multi Node Inventory Update Feed (feedType=MP_INVENTORY) only supports JSON Request and Responses. Refer to \"MultiNode_Bulk_Inventory_Update_Request.json\" for the corresponding request sample    Refer to the <a href=\"https://developer.walmart.com/doc/us/us-mp/us-mp-inventory/\">guide section</a> for more detailed guide around each of the feed types    Refer to the throttling limits before uploading the Feed Files.
         * @summary Bulk Item Inventory Update
         * @param {'inventory' | 'MP_INVENTORY'} feedType The feed Type
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType&#x3D;MP_INVENTORY)
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBulkInventory: async (feedType: 'inventory' | 'MP_INVENTORY', authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedType' is not null or undefined
            assertParamExists('updateBulkInventory', 'feedType', feedType)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateBulkInventory', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateBulkInventory', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMCONSUMERCHANNELTYPE' is not null or undefined
            assertParamExists('updateBulkInventory', 'wMCONSUMERCHANNELTYPE', wMCONSUMERCHANNELTYPE)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateBulkInventory', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateBulkInventory', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (shipNode !== undefined) {
                localVarQueryParameter['shipNode'] = shipNode;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the inventory for a given item.
         * @summary Update inventory
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’, \&#39;{\&#39;, \&#39;}\&#39; as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [shipNode] The shipNode for which the inventory is to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventoryForAnItem: async (sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, shipNode?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('updateInventoryForAnItem', 'sku', sku)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateInventoryForAnItem', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateInventoryForAnItem', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMCONSUMERCHANNELTYPE' is not null or undefined
            assertParamExists('updateInventoryForAnItem', 'wMCONSUMERCHANNELTYPE', wMCONSUMERCHANNELTYPE)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateInventoryForAnItem', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateInventoryForAnItem', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('updateInventoryForAnItem', 'inlineObject1', inlineObject1)
            const localVarPath = `/v3/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sku !== undefined) {
                localVarQueryParameter['sku'] = sku;
            }

            if (shipNode !== undefined) {
                localVarQueryParameter['shipNode'] = shipNode;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API will update the inventory for an item across one or more fulfillment centers, known as ship nodes.
         * @summary Update Item Inventory per Ship Node
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMultiNodeInventory: async (sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('updateMultiNodeInventory', 'sku', sku)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateMultiNodeInventory', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateMultiNodeInventory', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMCONSUMERCHANNELTYPE' is not null or undefined
            assertParamExists('updateMultiNodeInventory', 'wMCONSUMERCHANNELTYPE', wMCONSUMERCHANNELTYPE)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateMultiNodeInventory', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateMultiNodeInventory', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('updateMultiNodeInventory', 'inlineObject', inlineObject)
            const localVarPath = `/v3/inventories/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoryApiAxiosParamCreator(configuration)
    return {
        /**
         * You can use this API to get the inventory for a given item.
         * @summary Inventory
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’, \&#39;{\&#39;, \&#39;}\&#39; as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] The shipNode for which the inventory is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventory(sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventory(sku, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, shipNode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API will retrieve the inventory count for all of a seller\'s items across all ship nodes by item to ship node mapping. Inventory can be zero or non-zero.
         * @summary Multiple Item Inventory for All Ship Nodes
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [limit] The number of items returned. Cannot be more than 50.
         * @param {string} [nextCursor] String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultiNodeInventoryForAllSkuAndAllShipNodes(authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, limit?: string, nextCursor?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultiNodeInventoryForAllSkuAndAllShipNodes(authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, limit, nextCursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API will retrieve the inventory count for an item across all ship nodes or one specific ship node. You can specify the ship node for which you want to fetch the inventory
         * @summary Single Item Inventory by Ship Node
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] ShipNode Id of the ship node for which the inventory is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultiNodeInventoryForSkuAndAllShipnodes(sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultiNodeInventoryForSkuAndAllShipnodes(sku, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, shipNode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can use this API to get the current Available to Sell inventory quantities for all WFS items in your catalog. You can also query specific SKUs or filter to only items updated after a specific date in order to reduce the response size.
         * @summary WFS Inventory
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [sku] An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} [fromModifiedDate] last inventory modified date - starting range.
         * @param {string} [toModifiedDate] last inventory modified date - starting range.
         * @param {string} [limit] Number of Sku to be returned. Cannot be larger than 300.
         * @param {string} [offset] Offset is the number of records you wish to skip before selecting records.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWFSInventory(authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, sku?: string, fromModifiedDate?: string, toModifiedDate?: string, limit?: string, offset?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWFSInventory(authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, sku, fromModifiedDate, toModifiedDate, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates inventory for items in bulk.  Seller Can either use feed type \"inventory\" or \"MP_INVENTORY\"  * Inventory spec 1.4 feed type: inventory  * Inventory spec 1.5 feed type: MP_INVENTORY   Please Note: Multi Node Inventory Update Feed (feedType=MP_INVENTORY) only supports JSON Request and Responses. Refer to \"MultiNode_Bulk_Inventory_Update_Request.json\" for the corresponding request sample    Refer to the <a href=\"https://developer.walmart.com/doc/us/us-mp/us-mp-inventory/\">guide section</a> for more detailed guide around each of the feed types    Refer to the throttling limits before uploading the Feed Files.
         * @summary Bulk Item Inventory Update
         * @param {'inventory' | 'MP_INVENTORY'} feedType The feed Type
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType&#x3D;MP_INVENTORY)
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBulkInventory(feedType: 'inventory' | 'MP_INVENTORY', authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBulkInventory(feedType, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, shipNode, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the inventory for a given item.
         * @summary Update inventory
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’, \&#39;{\&#39;, \&#39;}\&#39; as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [shipNode] The shipNode for which the inventory is to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInventoryForAnItem(sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, shipNode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineObject1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInventoryForAnItem(sku, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, inlineObject1, shipNode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API will update the inventory for an item across one or more fulfillment centers, known as ship nodes.
         * @summary Update Item Inventory per Ship Node
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMultiNodeInventory(sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMultiNodeInventory(sku, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoryApiFp(configuration)
    return {
        /**
         * You can use this API to get the inventory for a given item.
         * @summary Inventory
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’, \&#39;{\&#39;, \&#39;}\&#39; as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] The shipNode for which the inventory is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory(sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getInventory(sku, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, shipNode, options).then((request) => request(axios, basePath));
        },
        /**
         * This API will retrieve the inventory count for all of a seller\'s items across all ship nodes by item to ship node mapping. Inventory can be zero or non-zero.
         * @summary Multiple Item Inventory for All Ship Nodes
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [limit] The number of items returned. Cannot be more than 50.
         * @param {string} [nextCursor] String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiNodeInventoryForAllSkuAndAllShipNodes(authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, limit?: string, nextCursor?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getMultiNodeInventoryForAllSkuAndAllShipNodes(authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, limit, nextCursor, options).then((request) => request(axios, basePath));
        },
        /**
         * This API will retrieve the inventory count for an item across all ship nodes or one specific ship node. You can specify the ship node for which you want to fetch the inventory
         * @summary Single Item Inventory by Ship Node
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] ShipNode Id of the ship node for which the inventory is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiNodeInventoryForSkuAndAllShipnodes(sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getMultiNodeInventoryForSkuAndAllShipnodes(sku, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, shipNode, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use this API to get the current Available to Sell inventory quantities for all WFS items in your catalog. You can also query specific SKUs or filter to only items updated after a specific date in order to reduce the response size.
         * @summary WFS Inventory
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [sku] An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} [fromModifiedDate] last inventory modified date - starting range.
         * @param {string} [toModifiedDate] last inventory modified date - starting range.
         * @param {string} [limit] Number of Sku to be returned. Cannot be larger than 300.
         * @param {string} [offset] Offset is the number of records you wish to skip before selecting records.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWFSInventory(authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, sku?: string, fromModifiedDate?: string, toModifiedDate?: string, limit?: string, offset?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.getWFSInventory(authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, sku, fromModifiedDate, toModifiedDate, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates inventory for items in bulk.  Seller Can either use feed type \"inventory\" or \"MP_INVENTORY\"  * Inventory spec 1.4 feed type: inventory  * Inventory spec 1.5 feed type: MP_INVENTORY   Please Note: Multi Node Inventory Update Feed (feedType=MP_INVENTORY) only supports JSON Request and Responses. Refer to \"MultiNode_Bulk_Inventory_Update_Request.json\" for the corresponding request sample    Refer to the <a href=\"https://developer.walmart.com/doc/us/us-mp/us-mp-inventory/\">guide section</a> for more detailed guide around each of the feed types    Refer to the throttling limits before uploading the Feed Files.
         * @summary Bulk Item Inventory Update
         * @param {'inventory' | 'MP_INVENTORY'} feedType The feed Type
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipNode] The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType&#x3D;MP_INVENTORY)
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBulkInventory(feedType: 'inventory' | 'MP_INVENTORY', authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipNode?: string, file?: any, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.updateBulkInventory(feedType, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, shipNode, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the inventory for a given item.
         * @summary Update inventory
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’, \&#39;{\&#39;, \&#39;}\&#39; as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [shipNode] The shipNode for which the inventory is to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventoryForAnItem(sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, shipNode?: string, options?: any): AxiosPromise<InlineObject1> {
            return localVarFp.updateInventoryForAnItem(sku, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, inlineObject1, shipNode, options).then((request) => request(axios, basePath));
        },
        /**
         * This API will update the inventory for an item across one or more fulfillment centers, known as ship nodes.
         * @summary Update Item Inventory per Ship Node
         * @param {string} sku An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMCONSUMERCHANNELTYPE A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMultiNodeInventory(sku: string, authorization: string, wMSECACCESSTOKEN: string, wMCONSUMERCHANNELTYPE: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.updateMultiNodeInventory(sku, authorization, wMSECACCESSTOKEN, wMCONSUMERCHANNELTYPE, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getInventory operation in InventoryApi.
 * @export
 * @interface InventoryApiGetInventoryRequest
 */
export interface InventoryApiGetInventoryRequest {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’, \&#39;{\&#39;, \&#39;}\&#39; as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
     * @type {string}
     * @memberof InventoryApiGetInventory
     */
    readonly sku: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof InventoryApiGetInventory
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof InventoryApiGetInventory
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof InventoryApiGetInventory
     */
    readonly wMCONSUMERCHANNELTYPE: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof InventoryApiGetInventory
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof InventoryApiGetInventory
     */
    readonly wMSVCNAME: string

    /**
     * The shipNode for which the inventory is requested
     * @type {string}
     * @memberof InventoryApiGetInventory
     */
    readonly shipNode?: string
}

/**
 * Request parameters for getMultiNodeInventoryForAllSkuAndAllShipNodes operation in InventoryApi.
 * @export
 * @interface InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodesRequest
 */
export interface InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodesRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodes
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodes
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodes
     */
    readonly wMCONSUMERCHANNELTYPE: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodes
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodes
     */
    readonly wMSVCNAME: string

    /**
     * The number of items returned. Cannot be more than 50.
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodes
     */
    readonly limit?: string

    /**
     * String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodes
     */
    readonly nextCursor?: string
}

/**
 * Request parameters for getMultiNodeInventoryForSkuAndAllShipnodes operation in InventoryApi.
 * @export
 * @interface InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodesRequest
 */
export interface InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodesRequest {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodes
     */
    readonly sku: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodes
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodes
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodes
     */
    readonly wMCONSUMERCHANNELTYPE: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodes
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodes
     */
    readonly wMSVCNAME: string

    /**
     * ShipNode Id of the ship node for which the inventory is requested
     * @type {string}
     * @memberof InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodes
     */
    readonly shipNode?: string
}

/**
 * Request parameters for getWFSInventory operation in InventoryApi.
 * @export
 * @interface InventoryApiGetWFSInventoryRequest
 */
export interface InventoryApiGetWFSInventoryRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly wMCONSUMERCHANNELTYPE: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly wMSVCNAME: string

    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly sku?: string

    /**
     * last inventory modified date - starting range.
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly fromModifiedDate?: string

    /**
     * last inventory modified date - starting range.
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly toModifiedDate?: string

    /**
     * Number of Sku to be returned. Cannot be larger than 300.
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly limit?: string

    /**
     * Offset is the number of records you wish to skip before selecting records.
     * @type {string}
     * @memberof InventoryApiGetWFSInventory
     */
    readonly offset?: string
}

/**
 * Request parameters for updateBulkInventory operation in InventoryApi.
 * @export
 * @interface InventoryApiUpdateBulkInventoryRequest
 */
export interface InventoryApiUpdateBulkInventoryRequest {
    /**
     * The feed Type
     * @type {'inventory' | 'MP_INVENTORY'}
     * @memberof InventoryApiUpdateBulkInventory
     */
    readonly feedType: 'inventory' | 'MP_INVENTORY'

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof InventoryApiUpdateBulkInventory
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof InventoryApiUpdateBulkInventory
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof InventoryApiUpdateBulkInventory
     */
    readonly wMCONSUMERCHANNELTYPE: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof InventoryApiUpdateBulkInventory
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof InventoryApiUpdateBulkInventory
     */
    readonly wMSVCNAME: string

    /**
     * The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType&#x3D;MP_INVENTORY)
     * @type {string}
     * @memberof InventoryApiUpdateBulkInventory
     */
    readonly shipNode?: string

    /**
     * 
     * @type {any}
     * @memberof InventoryApiUpdateBulkInventory
     */
    readonly file?: any
}

/**
 * Request parameters for updateInventoryForAnItem operation in InventoryApi.
 * @export
 * @interface InventoryApiUpdateInventoryForAnItemRequest
 */
export interface InventoryApiUpdateInventoryForAnItemRequest {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’, \&#39;{\&#39;, \&#39;}\&#39; as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
     * @type {string}
     * @memberof InventoryApiUpdateInventoryForAnItem
     */
    readonly sku: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof InventoryApiUpdateInventoryForAnItem
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof InventoryApiUpdateInventoryForAnItem
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof InventoryApiUpdateInventoryForAnItem
     */
    readonly wMCONSUMERCHANNELTYPE: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof InventoryApiUpdateInventoryForAnItem
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof InventoryApiUpdateInventoryForAnItem
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject1}
     * @memberof InventoryApiUpdateInventoryForAnItem
     */
    readonly inlineObject1: InlineObject1

    /**
     * The shipNode for which the inventory is to be updated.
     * @type {string}
     * @memberof InventoryApiUpdateInventoryForAnItem
     */
    readonly shipNode?: string
}

/**
 * Request parameters for updateMultiNodeInventory operation in InventoryApi.
 * @export
 * @interface InventoryApiUpdateMultiNodeInventoryRequest
 */
export interface InventoryApiUpdateMultiNodeInventoryRequest {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \&#39;:\&#39;, \&#39;/\&#39;, \&#39;?\&#39;, \&#39;#\&#39;, \&#39;[\&#39;, \&#39;]\&#39;, \&#39;@\&#39;, \&#39;!\&#39;, \&#39;$\&#39;, \&#39;&amp;\&#39;, \&quot;\&#39;\&quot;, \&#39;(\&#39;, \&#39;)\&#39;, \&#39;*\&#39;, \&#39;+\&#39;, \&#39;,\&#39;, \&#39;;\&#39;, \&#39;&#x3D;\&#39;, ‘ ’ as well as \&#39;%\&#39; itself if it\&#39;s a part of sku. Make sure to encode space with %20. Other characters don\&#39;t need to be encoded.
     * @type {string}
     * @memberof InventoryApiUpdateMultiNodeInventory
     */
    readonly sku: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof InventoryApiUpdateMultiNodeInventory
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof InventoryApiUpdateMultiNodeInventory
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof InventoryApiUpdateMultiNodeInventory
     */
    readonly wMCONSUMERCHANNELTYPE: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof InventoryApiUpdateMultiNodeInventory
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof InventoryApiUpdateMultiNodeInventory
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject}
     * @memberof InventoryApiUpdateMultiNodeInventory
     */
    readonly inlineObject: InlineObject
}

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
    /**
     * You can use this API to get the inventory for a given item.
     * @summary Inventory
     * @param {InventoryApiGetInventoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getInventory(requestParameters: InventoryApiGetInventoryRequest, options?: any) {
        return InventoryApiFp(this.configuration).getInventory(requestParameters.sku, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.shipNode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will retrieve the inventory count for all of a seller\'s items across all ship nodes by item to ship node mapping. Inventory can be zero or non-zero.
     * @summary Multiple Item Inventory for All Ship Nodes
     * @param {InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getMultiNodeInventoryForAllSkuAndAllShipNodes(requestParameters: InventoryApiGetMultiNodeInventoryForAllSkuAndAllShipNodesRequest, options?: any) {
        return InventoryApiFp(this.configuration).getMultiNodeInventoryForAllSkuAndAllShipNodes(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.limit, requestParameters.nextCursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will retrieve the inventory count for an item across all ship nodes or one specific ship node. You can specify the ship node for which you want to fetch the inventory
     * @summary Single Item Inventory by Ship Node
     * @param {InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getMultiNodeInventoryForSkuAndAllShipnodes(requestParameters: InventoryApiGetMultiNodeInventoryForSkuAndAllShipnodesRequest, options?: any) {
        return InventoryApiFp(this.configuration).getMultiNodeInventoryForSkuAndAllShipnodes(requestParameters.sku, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.shipNode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use this API to get the current Available to Sell inventory quantities for all WFS items in your catalog. You can also query specific SKUs or filter to only items updated after a specific date in order to reduce the response size.
     * @summary WFS Inventory
     * @param {InventoryApiGetWFSInventoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getWFSInventory(requestParameters: InventoryApiGetWFSInventoryRequest, options?: any) {
        return InventoryApiFp(this.configuration).getWFSInventory(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.sku, requestParameters.fromModifiedDate, requestParameters.toModifiedDate, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates inventory for items in bulk.  Seller Can either use feed type \"inventory\" or \"MP_INVENTORY\"  * Inventory spec 1.4 feed type: inventory  * Inventory spec 1.5 feed type: MP_INVENTORY   Please Note: Multi Node Inventory Update Feed (feedType=MP_INVENTORY) only supports JSON Request and Responses. Refer to \"MultiNode_Bulk_Inventory_Update_Request.json\" for the corresponding request sample    Refer to the <a href=\"https://developer.walmart.com/doc/us/us-mp/us-mp-inventory/\">guide section</a> for more detailed guide around each of the feed types    Refer to the throttling limits before uploading the Feed Files.
     * @summary Bulk Item Inventory Update
     * @param {InventoryApiUpdateBulkInventoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public updateBulkInventory(requestParameters: InventoryApiUpdateBulkInventoryRequest, options?: any) {
        return InventoryApiFp(this.configuration).updateBulkInventory(requestParameters.feedType, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.shipNode, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the inventory for a given item.
     * @summary Update inventory
     * @param {InventoryApiUpdateInventoryForAnItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public updateInventoryForAnItem(requestParameters: InventoryApiUpdateInventoryForAnItemRequest, options?: any) {
        return InventoryApiFp(this.configuration).updateInventoryForAnItem(requestParameters.sku, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject1, requestParameters.shipNode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will update the inventory for an item across one or more fulfillment centers, known as ship nodes.
     * @summary Update Item Inventory per Ship Node
     * @param {InventoryApiUpdateMultiNodeInventoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public updateMultiNodeInventory(requestParameters: InventoryApiUpdateMultiNodeInventoryRequest, options?: any) {
        return InventoryApiFp(this.configuration).updateMultiNodeInventory(requestParameters.sku, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


