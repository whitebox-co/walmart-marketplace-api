/* tslint:disable */
/* eslint-disable */
/**
 * Fulfillment Management
 * With Walmart Fulfillment Services, you can focus on sales while we expertly take care of fast shipping, seamless returns, and customer service. Simply send your inventory to Walmart fulfillment centers, where we will store your products securely and prepare them swiftly for shipping when an order is placed.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Fulfillment access mode details.
 * @export
 * @interface AccessMode
 */
export interface AccessMode {
    /**
     * Fulfillment access mode type. For example : \'NATIONAL_CARRIER\'
     * @type {string}
     * @memberof AccessMode
     */
    mode?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    stateCode: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    phone?: string;
}
/**
 * Available Quantity Information of an item.
 * @export
 * @interface AvailableQuantity
 */
export interface AvailableQuantity {
    /**
     * Quantity of each item.
     * @type {number}
     * @memberof AvailableQuantity
     */
    measurementValue: number;
    /**
     * Unit of quantity. Currently supported type : \'EA\'
     * @type {string}
     * @memberof AvailableQuantity
     */
    unitOfMeasure: string;
}
/**
 * buyerInfo of the order
 * @export
 * @interface BuyerInfo
 */
export interface BuyerInfo {
    /**
     * 
     * @type {InlineResponse2009BuyerInfoPrimaryContact}
     * @memberof BuyerInfo
     */
    primaryContact?: InlineResponse2009BuyerInfoPrimaryContact;
}
/**
 * request payload
 * @export
 * @interface CancelCustomerOrderRequestPayload
 */
export interface CancelCustomerOrderRequestPayload {
    /**
     * 
     * @type {string}
     * @memberof CancelCustomerOrderRequestPayload
     */
    sellerOrderId: string;
    /**
     * 
     * @type {Array<V3FulfillmentOrdersFulfillmentsCancelPayloadOrderItems>}
     * @memberof CancelCustomerOrderRequestPayload
     */
    orderItems: Array<V3FulfillmentOrdersFulfillmentsCancelPayloadOrderItems>;
}
/**
 * 
 * @export
 * @interface CancelCustomerOrderRequestWrapper
 */
export interface CancelCustomerOrderRequestWrapper {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof CancelCustomerOrderRequestWrapper
     */
    header: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsCancelPayload}
     * @memberof CancelCustomerOrderRequestWrapper
     */
    payload?: V3FulfillmentOrdersFulfillmentsCancelPayload;
}
/**
 * 
 * @export
 * @interface Carrier
 */
export interface Carrier {
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    carrierId?: string;
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    carrierName?: string;
}
/**
 * 
 * @export
 * @interface CarrierLabelRequestWrapper
 */
export interface CarrierLabelRequestWrapper {
    /**
     * 
     * @type {string}
     * @memberof CarrierLabelRequestWrapper
     */
    shipDate: string;
}
/**
 * 
 * @export
 * @interface CarrierQuoteConfirmRequestWrapper
 */
export interface CarrierQuoteConfirmRequestWrapper {
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteConfirmRequestWrapper
     */
    shipmentId: string;
}
/**
 * 
 * @export
 * @interface CarrierQuoteRequestV2Wrapper
 */
export interface CarrierQuoteRequestV2Wrapper {
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    shipmentSource: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    pickupFromDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    pickupToDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    deliveryFromDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    deliveryToDateTime?: string;
    /**
     * 
     * @type {V3FulfillmentCarrierRateQuotesCustomer}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    customer: V3FulfillmentCarrierRateQuotesCustomer;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    originLocation: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    destinationLocation: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006ReturnLocation}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    returnLocation: InlineResponse2006ReturnLocation;
    /**
     * 
     * @type {Array<InlineResponse2006ShipmentPackages>}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    shipmentPackages: Array<InlineResponse2006ShipmentPackages>;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    mode: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    freightClass?: string;
    /**
     * 
     * @type {number}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    declaredValue?: number;
    /**
     * 
     * @type {Array<V3FulfillmentCarrierRateQuotesLoadTypes>}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    loadTypes?: Array<V3FulfillmentCarrierRateQuotesLoadTypes>;
}
/**
 * 
 * @export
 * @interface Cause
 */
export interface Cause {
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    description?: string;
}
/**
 * Item charge details
 * @export
 * @interface ChargeDetails
 */
export interface ChargeDetails {
    /**
     * Charge category, for example: \'PRODUCT\'
     * @type {string}
     * @memberof ChargeDetails
     */
    chargeCategory: string;
    /**
     * Name of the charge, for example: \'Sale Price\'
     * @type {string}
     * @memberof ChargeDetails
     */
    chargeName: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit}
     * @memberof ChargeDetails
     */
    chargePerUnit: V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadTaxDetails}
     * @memberof ChargeDetails
     */
    taxDetails?: V3FulfillmentOrdersFulfillmentsPayloadTaxDetails;
}
/**
 * Customer contact details
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName}
     * @memberof Contact
     */
    name: V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName;
    /**
     * Customer phone number
     * @type {string}
     * @memberof Contact
     */
    phone: string;
    /**
     * Customer email address
     * @type {string}
     * @memberof Contact
     */
    email: string;
}
/**
 * request payload
 * @export
 * @interface CreateCustomerOrderRequestPayload
 */
export interface CreateCustomerOrderRequestPayload {
    /**
     * Unique ID identifying channels from where the orders have been generated. This ID is generated by Walmart at the time of on-boarding onto multichannel program and this cannot be a random number
     * @type {string}
     * @memberof CreateCustomerOrderRequestPayload
     */
    orderChannelId: string;
    /**
     * Unique ID identifying customer order request. Preferred to attach seller short name as prefix. For example: \'seller001\'
     * @type {string}
     * @memberof CreateCustomerOrderRequestPayload
     */
    sellerOrderId: string;
    /**
     * Order placed time at respective channels. Format: \'2022-03-25T21:58:30.143Z\'
     * @type {string}
     * @memberof CreateCustomerOrderRequestPayload
     */
    orderPlacedTime: string;
    /**
     * Flag to identify if confirmation is needed. Currently supported: \'false\'
     * @type {boolean}
     * @memberof CreateCustomerOrderRequestPayload
     */
    needsConfirmation?: boolean;
    /**
     * Flag to identify if partial fulfilment is allowed. Currently supported: \'false\'
     * @type {boolean}
     * @memberof CreateCustomerOrderRequestPayload
     */
    partialFulfillments?: boolean;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomer}
     * @memberof CreateCustomerOrderRequestPayload
     */
    customer: V3FulfillmentOrdersFulfillmentsPayloadCustomer;
    /**
     * Order items details
     * @type {Array<V3FulfillmentOrdersFulfillmentsPayloadOrderItems>}
     * @memberof CreateCustomerOrderRequestPayload
     */
    orderItems: Array<V3FulfillmentOrdersFulfillmentsPayloadOrderItems>;
}
/**
 * 
 * @export
 * @interface CreateCustomerOrderRequestWrapper
 */
export interface CreateCustomerOrderRequestWrapper {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof CreateCustomerOrderRequestWrapper
     */
    header: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayload}
     * @memberof CreateCustomerOrderRequestWrapper
     */
    payload: V3FulfillmentOrdersFulfillmentsPayload;
}
/**
 * Request Payload
 * @export
 * @interface CreateInboundRequestDTO
 */
export interface CreateInboundRequestDTO {
    /**
     * Unique identifier used for shipments
     * @type {string}
     * @memberof CreateInboundRequestDTO
     */
    inboundOrderId: string;
    /**
     * 
     * @type {InlineResponse2003ReturnAddress}
     * @memberof CreateInboundRequestDTO
     */
    returnAddress: InlineResponse2003ReturnAddress;
    /**
     * List of Order Items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof CreateInboundRequestDTO
     */
    orderItems: Array<V3FulfillmentInboundShipmentsOrderItems>;
}
/**
 * Currency type details
 * @export
 * @interface CurrencyType
 */
export interface CurrencyType {
    /**
     * Currency amount, preferred value: 0
     * @type {number}
     * @memberof CurrencyType
     */
    currencyAmount: number;
    /**
     * Currency unit, for example: \'USD\'
     * @type {string}
     * @memberof CurrencyType
     */
    unit: CurrencyTypeUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CurrencyTypeUnitEnum {
    Aed = 'AED',
    Afn = 'AFN',
    All = 'ALL',
    Amd = 'AMD',
    Ang = 'ANG',
    Aoa = 'AOA',
    Ars = 'ARS',
    Aud = 'AUD',
    Awg = 'AWG',
    Azn = 'AZN',
    Bam = 'BAM',
    Bbd = 'BBD',
    Bdt = 'BDT',
    Bgn = 'BGN',
    Bhd = 'BHD',
    Bif = 'BIF',
    Bmd = 'BMD',
    Bnd = 'BND',
    Bob = 'BOB',
    Brl = 'BRL',
    Bsd = 'BSD',
    Btn = 'BTN',
    Bwp = 'BWP',
    Byr = 'BYR',
    Bzd = 'BZD',
    Cad = 'CAD',
    Cdf = 'CDF',
    Chf = 'CHF',
    Clp = 'CLP',
    Cny = 'CNY',
    Cop = 'COP',
    Crc = 'CRC',
    Cup = 'CUP',
    Cve = 'CVE',
    Czk = 'CZK',
    Djf = 'DJF',
    Dkk = 'DKK',
    Dop = 'DOP',
    Dzd = 'DZD',
    Egp = 'EGP',
    Ern = 'ERN',
    Etb = 'ETB',
    Eur = 'EUR',
    Fjd = 'FJD',
    Fkp = 'FKP',
    Gbp = 'GBP',
    Gel = 'GEL',
    Ghs = 'GHS',
    Gip = 'GIP',
    Gmd = 'GMD',
    Gnf = 'GNF',
    Gtq = 'GTQ',
    Gyd = 'GYD',
    Hkd = 'HKD',
    Hnl = 'HNL',
    Hrk = 'HRK',
    Htg = 'HTG',
    Huf = 'HUF',
    Idr = 'IDR',
    Ils = 'ILS',
    Inr = 'INR',
    Iqd = 'IQD',
    Irr = 'IRR',
    Isk = 'ISK',
    Jmd = 'JMD',
    Jod = 'JOD',
    Jpy = 'JPY',
    Kes = 'KES',
    Kgs = 'KGS',
    Khr = 'KHR',
    Kmf = 'KMF',
    Kpw = 'KPW',
    Krw = 'KRW',
    Kwd = 'KWD',
    Kyd = 'KYD',
    Kzt = 'KZT',
    Lak = 'LAK',
    Lbp = 'LBP',
    Lkr = 'LKR',
    Lrd = 'LRD',
    Lsl = 'LSL',
    Ltl = 'LTL',
    Lvl = 'LVL',
    Lyd = 'LYD',
    Mad = 'MAD',
    Mdl = 'MDL',
    Mga = 'MGA',
    Mkd = 'MKD',
    Mmk = 'MMK',
    Mnt = 'MNT',
    Mop = 'MOP',
    Mro = 'MRO',
    Mur = 'MUR',
    Mvr = 'MVR',
    Mwk = 'MWK',
    Mxn = 'MXN',
    Myr = 'MYR',
    Mzn = 'MZN',
    Nad = 'NAD',
    Ngn = 'NGN',
    Nio = 'NIO',
    Nok = 'NOK',
    Npr = 'NPR',
    Nzd = 'NZD',
    Omr = 'OMR',
    Pab = 'PAB',
    Pen = 'PEN',
    Pgk = 'PGK',
    Php = 'PHP',
    Pkr = 'PKR',
    Pln = 'PLN',
    Pyg = 'PYG',
    Qar = 'QAR',
    Ron = 'RON',
    Rsd = 'RSD',
    Rub = 'RUB',
    Rur = 'RUR',
    Rwf = 'RWF',
    Sar = 'SAR',
    Sbd = 'SBD',
    Scr = 'SCR',
    Sdg = 'SDG',
    Sek = 'SEK',
    Sgd = 'SGD',
    Shp = 'SHP',
    Sll = 'SLL',
    Sos = 'SOS',
    Srd = 'SRD',
    Std = 'STD',
    Syp = 'SYP',
    Szl = 'SZL',
    Thb = 'THB',
    Tjs = 'TJS',
    Tmt = 'TMT',
    Tnd = 'TND',
    Top = 'TOP',
    Try = 'TRY',
    Ttd = 'TTD',
    Twd = 'TWD',
    Tzs = 'TZS',
    Uah = 'UAH',
    Ugx = 'UGX',
    Usd = 'USD',
    Uyu = 'UYU',
    Uzs = 'UZS',
    Vef = 'VEF',
    Vnd = 'VND',
    Vuv = 'VUV',
    Wst = 'WST',
    Xaf = 'XAF',
    Xag = 'XAG',
    Xau = 'XAU',
    Xba = 'XBA',
    Xbb = 'XBB',
    Xbc = 'XBC',
    Xbd = 'XBD',
    Xcd = 'XCD',
    Xdr = 'XDR',
    Xfu = 'XFU',
    Xof = 'XOF',
    Xpd = 'XPD',
    Xpf = 'XPF',
    Xpt = 'XPT',
    Xts = 'XTS',
    Xxx = 'XXX',
    Yer = 'YER',
    Zar = 'ZAR',
    Zmk = 'ZMK',
    Zwl = 'ZWL'
}

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    customerName: string;
}
/**
 * Customer address details
 * @export
 * @interface CustomerAddress
 */
export interface CustomerAddress {
    /**
     * First line of the address
     * @type {string}
     * @memberof CustomerAddress
     */
    line1: string;
    /**
     * Second line of the address
     * @type {string}
     * @memberof CustomerAddress
     */
    line2?: string;
    /**
     * City where the address is located in
     * @type {string}
     * @memberof CustomerAddress
     */
    city: string;
    /**
     * State (two letter) code where the address is located in, for example: \'MI\'
     * @type {string}
     * @memberof CustomerAddress
     */
    state: string;
    /**
     * Country code where the address is located in, for example: \'USA\'
     * @type {string}
     * @memberof CustomerAddress
     */
    country: string;
    /**
     * ZIP or postal code where the address is located in, for example: \'48083\'
     * @type {string}
     * @memberof CustomerAddress
     */
    zip: string;
    /**
     * The address type. Currently supported: \'RESIDENTIAL\'
     * @type {string}
     * @memberof CustomerAddress
     */
    addressType?: string;
}
/**
 * Customer details
 * @export
 * @interface CustomerOrderContactDetails
 */
export interface CustomerOrderContactDetails {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomerContact}
     * @memberof CustomerOrderContactDetails
     */
    contact: V3FulfillmentOrdersFulfillmentsPayloadCustomerContact;
}
/**
 * Meta data of the response
 * @export
 * @interface CustomerOrderDetailsHeader
 */
export interface CustomerOrderDetailsHeader {
    /**
     * 
     * @type {InlineResponse2009HeaderHeaderAttributes}
     * @memberof CustomerOrderDetailsHeader
     */
    headerAttributes?: InlineResponse2009HeaderHeaderAttributes;
}
/**
 * Header attributes
 * @export
 * @interface CustomerOrderDetailsHeaderAttributes
 */
export interface CustomerOrderDetailsHeaderAttributes {
    /**
     * martId passed in header
     * @type {string}
     * @memberof CustomerOrderDetailsHeaderAttributes
     */
    martId?: string;
    /**
     * buId passed in header
     * @type {string}
     * @memberof CustomerOrderDetailsHeaderAttributes
     */
    buId?: string;
    /**
     * page count of the orders available with given filters
     * @type {number}
     * @memberof CustomerOrderDetailsHeaderAttributes
     */
    pageCount?: number;
    /**
     * total count of orders available with given filters
     * @type {number}
     * @memberof CustomerOrderDetailsHeaderAttributes
     */
    totalCount?: number;
}
/**
 * Order details
 * @export
 * @interface CustomerOrderDetailsResponse
 */
export interface CustomerOrderDetailsResponse {
    /**
     * orderChannelId of the order
     * @type {string}
     * @memberof CustomerOrderDetailsResponse
     */
    orderChannelId?: string;
    /**
     * sellerOrderId of the order
     * @type {string}
     * @memberof CustomerOrderDetailsResponse
     */
    sellerOrderId?: string;
    /**
     * order type of the order
     * @type {string}
     * @memberof CustomerOrderDetailsResponse
     */
    orderType?: string;
    /**
     * status of the order
     * @type {string}
     * @memberof CustomerOrderDetailsResponse
     */
    status?: string;
    /**
     * createDate of the order
     * @type {string}
     * @memberof CustomerOrderDetailsResponse
     */
    orderDate?: string;
    /**
     * 
     * @type {InlineResponse2009BuyerInfo}
     * @memberof CustomerOrderDetailsResponse
     */
    buyerInfo?: InlineResponse2009BuyerInfo;
    /**
     * createDate of the order
     * @type {Array<InlineResponse2009Shipments>}
     * @memberof CustomerOrderDetailsResponse
     */
    shipments?: Array<InlineResponse2009Shipments>;
    /**
     * order lines details
     * @type {Array<InlineResponse2009OrderLines>}
     * @memberof CustomerOrderDetailsResponse
     */
    orderLines?: Array<InlineResponse2009OrderLines>;
}
/**
 * 
 * @export
 * @interface CustomerOrderDetailsResponseWrapperDTO
 */
export interface CustomerOrderDetailsResponseWrapperDTO {
    /**
     * status
     * @type {string}
     * @memberof CustomerOrderDetailsResponseWrapperDTO
     */
    status?: string;
    /**
     * 
     * @type {InlineResponse2009Header}
     * @memberof CustomerOrderDetailsResponseWrapperDTO
     */
    header?: InlineResponse2009Header;
    /**
     * Order details
     * @type {Array<InlineResponse2009Payload>}
     * @memberof CustomerOrderDetailsResponseWrapperDTO
     */
    payload?: Array<InlineResponse2009Payload>;
}
/**
 * header to support build and martId
 * @export
 * @interface CustomerOrderHeader
 */
export interface CustomerOrderHeader {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeaderHeaderAttributes}
     * @memberof CustomerOrderHeader
     */
    headerAttributes?: V3FulfillmentOrdersFulfillmentsHeaderHeaderAttributes;
}
/**
 * Header attributes
 * @export
 * @interface CustomerOrderHeaderAttributes
 */
export interface CustomerOrderHeaderAttributes {
    /**
     * martId of the seller. Currently supported: \'202\'
     * @type {string}
     * @memberof CustomerOrderHeaderAttributes
     */
    martId?: string;
    /**
     * buId of the seller. Currently supported: \'0\'
     * @type {string}
     * @memberof CustomerOrderHeaderAttributes
     */
    buId?: string;
}
/**
 * Order items details
 * @export
 * @interface CustomerOrderItem
 */
export interface CustomerOrderItem {
    /**
     * Fulfillment Type of an order. Currently supported type: \'DELIVERY\'
     * @type {string}
     * @memberof CustomerOrderItem
     */
    fulfillmentType?: string;
    /**
     * Unique Id for each line item, preferred sequence 1,2,3...
     * @type {string}
     * @memberof CustomerOrderItem
     */
    sellerLineId: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadItemDetail}
     * @memberof CustomerOrderItem
     */
    itemDetail: V3FulfillmentOrdersFulfillmentsPayloadItemDetail;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadQty}
     * @memberof CustomerOrderItem
     */
    qty: V3FulfillmentOrdersFulfillmentsPayloadQty;
    /**
     * Shipping method of an order. Currently supported type: \'EXPEDITED\', \'STANDARD\'
     * @type {string}
     * @memberof CustomerOrderItem
     */
    shippingMethod?: CustomerOrderItemShippingMethodEnum;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadShippingTo}
     * @memberof CustomerOrderItem
     */
    shippingTo: V3FulfillmentOrdersFulfillmentsPayloadShippingTo;
    /**
     * Item charge details
     * @type {Array<V3FulfillmentOrdersFulfillmentsPayloadChargeDetails>}
     * @memberof CustomerOrderItem
     */
    chargeDetails: Array<V3FulfillmentOrdersFulfillmentsPayloadChargeDetails>;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomerOrderItemShippingMethodEnum {
    Expedited = 'EXPEDITED',
    Standard = 'STANDARD',
    Rush = 'RUSH'
}

/**
 * Item quantity details
 * @export
 * @interface CustomerOrderItemQuantityType
 */
export interface CustomerOrderItemQuantityType {
    /**
     * Sales unit measure. Currently supported type : \'EACH\'
     * @type {string}
     * @memberof CustomerOrderItemQuantityType
     */
    unitOfMeasure: string;
    /**
     * Requested Quantity Information of an item
     * @type {number}
     * @memberof CustomerOrderItemQuantityType
     */
    measurementValue: number;
}
/**
 * Order line quantity information
 * @export
 * @interface CustomerOrderLineQtyInfo
 */
export interface CustomerOrderLineQtyInfo {
    /**
     * status of the order line quantity
     * @type {string}
     * @memberof CustomerOrderLineQtyInfo
     */
    status?: string;
    /**
     * status description of the order line quantity
     * @type {string}
     * @memberof CustomerOrderLineQtyInfo
     */
    statusDescription?: string;
    /**
     * 
     * @type {InlineResponse2009Quantity}
     * @memberof CustomerOrderLineQtyInfo
     */
    statusQuantity?: InlineResponse2009Quantity;
}
/**
 * order lines details
 * @export
 * @interface CustomerOrderLinesDetails
 */
export interface CustomerOrderLinesDetails {
    /**
     * fulfillmentType of the order
     * @type {string}
     * @memberof CustomerOrderLinesDetails
     */
    fulfillmentType?: string;
    /**
     * Last modified date of the order lines
     * @type {string}
     * @memberof CustomerOrderLinesDetails
     */
    lastModified?: string;
    /**
     * Shipping method of the order lines
     * @type {string}
     * @memberof CustomerOrderLinesDetails
     */
    shippingMethod?: string;
    /**
     * Shipping tier of the order lines
     * @type {string}
     * @memberof CustomerOrderLinesDetails
     */
    shippingTier?: string;
    /**
     * Order line quantity information
     * @type {Array<InlineResponse2009OrderLineQuantityInfo>}
     * @memberof CustomerOrderLinesDetails
     */
    orderLineQuantityInfo?: Array<InlineResponse2009OrderLineQuantityInfo>;
    /**
     * 
     * @type {InlineResponse2009OrderProduct}
     * @memberof CustomerOrderLinesDetails
     */
    orderProduct?: InlineResponse2009OrderProduct;
    /**
     * 
     * @type {InlineResponse2009Quantity}
     * @memberof CustomerOrderLinesDetails
     */
    orderedQty?: InlineResponse2009Quantity;
    /**
     * 
     * @type {InlineResponse2009CustomerShipToAddress}
     * @memberof CustomerOrderLinesDetails
     */
    customerShipToAddress?: InlineResponse2009CustomerShipToAddress;
}
/**
 * Name of the Customer
 * @export
 * @interface CustomerOrderName
 */
export interface CustomerOrderName {
    /**
     * Customer first name
     * @type {string}
     * @memberof CustomerOrderName
     */
    firstName: string;
    /**
     * Customer last name
     * @type {string}
     * @memberof CustomerOrderName
     */
    lastName: string;
}
/**
 * response payload
 * @export
 * @interface CustomerOrderResponseWrapper
 */
export interface CustomerOrderResponseWrapper {
    /**
     * Unique ID identifying each request
     * @type {string}
     * @memberof CustomerOrderResponseWrapper
     */
    requestId?: string;
}
/**
 * 
 * @export
 * @interface CustomerOrderResponseWrapperDTO
 */
export interface CustomerOrderResponseWrapperDTO {
    /**
     * status
     * @type {string}
     * @memberof CustomerOrderResponseWrapperDTO
     */
    status?: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof CustomerOrderResponseWrapperDTO
     */
    header?: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {InlineResponse2001Payload}
     * @memberof CustomerOrderResponseWrapperDTO
     */
    payload?: InlineResponse2001Payload;
}
/**
 * Customer shipping address
 * @export
 * @interface CustomerShipToAddress
 */
export interface CustomerShipToAddress {
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof CustomerShipToAddress
     */
    address?: InlineResponse2006OriginLocationAddress;
    /**
     * 
     * @type {InlineResponse2009CustomerShipToAddressName}
     * @memberof CustomerShipToAddress
     */
    name?: InlineResponse2009CustomerShipToAddressName;
}
/**
 * 
 * @export
 * @interface DestinationLocation
 */
export interface DestinationLocation {
    /**
     * 
     * @type {string}
     * @memberof DestinationLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof DestinationLocation
     */
    address: InlineResponse2006OriginLocationAddress;
    /**
     * 
     * @type {string}
     * @memberof DestinationLocation
     */
    locationId?: string;
}
/**
 * 
 * @export
 * @interface FeedId
 */
export interface FeedId {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
     * @type {string}
     * @memberof FeedId
     */
    feedId?: string;
    /**
     * 
     * @type {object}
     * @memberof FeedId
     */
    additionalAttributes?: object | null;
    /**
     * 
     * @type {object}
     * @memberof FeedId
     */
    errors?: object | null;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | status | Item status | string
     * @type {string}
     * @memberof Filter
     */
    field?: FilterFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    op?: FilterOpEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Filter
     */
    values?: Array<FilterValuesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum FilterFieldEnum {
    Status = 'status'
}
/**
    * @export
    * @enum {string}
    */
export enum FilterOpEnum {
    Equals = 'equals'
}
/**
    * @export
    * @enum {string}
    */
export enum FilterValuesEnum {
    Prohibited = 'PROHIBITED',
    InReview = 'IN_REVIEW',
    ActionNeeded = 'ACTION_NEEDED'
}

/**
 * Fulfillment details.
 * @export
 * @interface Fulfillment
 */
export interface Fulfillment {
    /**
     * The identifier to identify fulfillment.
     * @type {string}
     * @memberof Fulfillment
     */
    fulfillmentId?: string;
    /**
     * Line item attribute details.
     * @type {Array<InlineResponse2002PayloadLineItemAttributesList>}
     * @memberof Fulfillment
     */
    lineItemAttributesList?: Array<InlineResponse2002PayloadLineItemAttributesList>;
    /**
     * 
     * @type {InlineResponse2002PayloadSla}
     * @memberof Fulfillment
     */
    sla?: InlineResponse2002PayloadSla;
    /**
     * Fulfillment node type details. For example : \'FC\'
     * @type {string}
     * @memberof Fulfillment
     */
    nodeType?: string;
    /**
     * 
     * @type {InlineResponse2002PayloadAccessMode}
     * @memberof Fulfillment
     */
    accessMode?: InlineResponse2002PayloadAccessMode;
    /**
     * 
     * @type {InlineResponse2002PayloadFulfillmentTime}
     * @memberof Fulfillment
     */
    fulfillmentTime?: InlineResponse2002PayloadFulfillmentTime;
    /**
     * Error list details.
     * @type {Array<InlineResponse200Errors>}
     * @memberof Fulfillment
     */
    errors?: Array<InlineResponse200Errors>;
}
/**
 * Fulfillment date details.
 * @export
 * @interface FulfillmentDate
 */
export interface FulfillmentDate {
    /**
     * Fulfillment minimum promise date detail.
     * @type {string}
     * @memberof FulfillmentDate
     */
    minPromiseDate?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentDate
     */
    Fulfillment_maximum_promise_date_detail_?: string;
}
/**
 * Fulfillment Group details.
 * @export
 * @interface FulfillmentGroup
 */
export interface FulfillmentGroup {
    /**
     * Fulfillment options details.
     * @type {Array<InlineResponse2002PayloadFulfillmentOptions>}
     * @memberof FulfillmentGroup
     */
    fulfillmentOptions?: Array<InlineResponse2002PayloadFulfillmentOptions>;
}
/**
 * Fulfillment module details.
 * @export
 * @interface FulfillmentModule
 */
export interface FulfillmentModule {
    /**
     * Fulfillment module name. For example : \'UNSCHEDULED_DELIVERY and ERROR\'
     * @type {string}
     * @memberof FulfillmentModule
     */
    name?: string;
    /**
     * Fulfillment Group details.
     * @type {Array<InlineResponse2002PayloadFulfillmentGroups>}
     * @memberof FulfillmentModule
     */
    fulfillmentGroups?: Array<InlineResponse2002PayloadFulfillmentGroups>;
}
/**
 * Fulfillment options details.
 * @export
 * @interface FulfillmentOption
 */
export interface FulfillmentOption {
    /**
     * Fulfillment mode detail. For example : \'UNSCHEDULED\'
     * @type {string}
     * @memberof FulfillmentOption
     */
    fulfillmentMode?: string;
    /**
     * Fulfillment access type. For example : \'DELIVERY_ADDRESS\'
     * @type {string}
     * @memberof FulfillmentOption
     */
    accessType?: string;
    /**
     * Fulfillment details.
     * @type {Array<InlineResponse2002PayloadFulfillments>}
     * @memberof FulfillmentOption
     */
    fulfillments?: Array<InlineResponse2002PayloadFulfillments>;
    /**
     * Fulfillment type detail. For example : \'DELIVERY\'
     * @type {string}
     * @memberof FulfillmentOption
     */
    fulfillmentType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FulfillmentOption
     */
    _default?: boolean;
}
/**
 * Fulfillment plans details.
 * @export
 * @interface FulfillmentPlan
 */
export interface FulfillmentPlan {
    /**
     * Fulfillment module details.
     * @type {Array<InlineResponse2002PayloadFulfillmentModules>}
     * @memberof FulfillmentPlan
     */
    fulfillmentModules?: Array<InlineResponse2002PayloadFulfillmentModules>;
}
/**
 * Fulfillment time details.
 * @export
 * @interface FulfillmentTime
 */
export interface FulfillmentTime {
    /**
     * 
     * @type {InlineResponse2002PayloadFulfillmentTimeDate}
     * @memberof FulfillmentTime
     */
    date?: InlineResponse2002PayloadFulfillmentTimeDate;
}
/**
 * Payload Section
 * @export
 * @interface GetInventoryLogsResponsePayload
 */
export interface GetInventoryLogsResponsePayload {
    /**
     * GTIN
     * @type {string}
     * @memberof GetInventoryLogsResponsePayload
     */
    gtin?: string;
    /**
     * Vendor SKU
     * @type {string}
     * @memberof GetInventoryLogsResponsePayload
     */
    vendorSku?: string;
    /**
     * Product Name
     * @type {string}
     * @memberof GetInventoryLogsResponsePayload
     */
    productName?: string;
    /**
     * Inventory Log records
     * @type {Array<InlineResponse20010PayloadInventoryLog>}
     * @memberof GetInventoryLogsResponsePayload
     */
    inventoryLog?: Array<InlineResponse20010PayloadInventoryLog>;
}
/**
 * 
 * @export
 * @interface GetRateQuoteInfoResponseWrapper
 */
export interface GetRateQuoteInfoResponseWrapper {
    /**
     * 
     * @type {string}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    quoteId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    estimatedDeliveryDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    quoteCreationDate?: string;
    /**
     * 
     * @type {InlineResponse2006Carrier}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    carrier?: InlineResponse2006Carrier;
    /**
     * 
     * @type {InlineResponse2006RateQuote}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    rateQuote?: InlineResponse2006RateQuote;
    /**
     * 
     * @type {Array<InlineResponse2006ShipmentPackages>}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    shipmentPackages?: Array<InlineResponse2006ShipmentPackages>;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    originLocation?: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    destinationLocation?: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006ReturnLocation}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    returnLocation?: InlineResponse2006ReturnLocation;
}
/**
 * 
 * @export
 * @interface GetShipmentItemsDTO
 */
export interface GetShipmentItemsDTO {
    /**
     * 
     * @type {InlineResponse2003Headers}
     * @memberof GetShipmentItemsDTO
     */
    headers?: InlineResponse2003Headers;
    /**
     * response payload
     * @type {Array<InlineResponse20011Payload>}
     * @memberof GetShipmentItemsDTO
     */
    payload?: Array<InlineResponse20011Payload>;
}
/**
 * 
 * @export
 * @interface GetShipmentPlanDTO
 */
export interface GetShipmentPlanDTO {
    /**
     * 
     * @type {InlineResponse2003Headers}
     * @memberof GetShipmentPlanDTO
     */
    headers?: InlineResponse2003Headers;
    /**
     * response payload
     * @type {Array<InlineResponse2003Payload>}
     * @memberof GetShipmentPlanDTO
     */
    payload?: Array<InlineResponse2003Payload>;
}
/**
 * 
 * @export
 * @interface Headers
 */
export interface Headers {
    /**
     * total number of POs for provided GET request.
     * @type {number}
     * @memberof Headers
     */
    totalCount?: number;
    /**
     * provided limit value in the request
     * @type {number}
     * @memberof Headers
     */
    limit?: number;
    /**
     * provided offset value in the request.
     * @type {number}
     * @memberof Headers
     */
    offset?: number;
}
/**
 * Response payload.
 * @export
 * @interface InboundPreviewResponseDTO
 */
export interface InboundPreviewResponseDTO {
    /**
     * Unique shipment identifier
     * @type {string}
     * @memberof InboundPreviewResponseDTO
     */
    inboundOrderId?: string;
    /**
     * List of preview responses
     * @type {Array<InlineResponse2005Previews>}
     * @memberof InboundPreviewResponseDTO
     */
    previews?: Array<InlineResponse2005Previews>;
}
/**
 * 
 * @export
 * @interface InboundPreviewResponseWrapper
 */
export interface InboundPreviewResponseWrapper {
    /**
     * Response status.
     * @type {string}
     * @memberof InboundPreviewResponseWrapper
     */
    status?: string;
    /**
     * Response payload.
     * @type {Array<InlineResponse2005Payload>}
     * @memberof InboundPreviewResponseWrapper
     */
    payload?: Array<InlineResponse2005Payload>;
}
/**
 * 
 * @export
 * @interface InboundPreviewWrapper
 */
export interface InboundPreviewWrapper {
    /**
     * 
     * @type {V3FulfillmentInboundPreviewHeader}
     * @memberof InboundPreviewWrapper
     */
    header: V3FulfillmentInboundPreviewHeader;
    /**
     * 
     * @type {V3FulfillmentInboundPreviewPayload}
     * @memberof InboundPreviewWrapper
     */
    payload: V3FulfillmentInboundPreviewPayload;
}
/**
 * Requested inbound services such as ITS
 * @export
 * @interface InboundService
 */
export interface InboundService {
    /**
     * ITS Flag
     * @type {string}
     * @memberof InboundService
     */
    inventoryTransferService?: string;
}
/**
 * response payload
 * @export
 * @interface InboundShipmentCreateResponseWrapper
 */
export interface InboundShipmentCreateResponseWrapper {
    /**
     * Unique ID identifying each shipment
     * @type {string}
     * @memberof InboundShipmentCreateResponseWrapper
     */
    shipmentId?: string;
    /**
     * 
     * @type {InlineResponse2003ShipToAddress}
     * @memberof InboundShipmentCreateResponseWrapper
     */
    shipToAddress?: InlineResponse2003ShipToAddress;
    /**
     * The items which needs to be send in the shipment
     * @type {Array<InlineResponse2004ShipmentItems>}
     * @memberof InboundShipmentCreateResponseWrapper
     */
    shipmentItems?: Array<InlineResponse2004ShipmentItems>;
    /**
     * expected delivery date for inbounding shipment. Can be different from provided in the rquest based on network capacity
     * @type {string}
     * @memberof InboundShipmentCreateResponseWrapper
     */
    expectedDeliveryDate?: string;
}
/**
 * 
 * @export
 * @interface InboundShipmentCreateResponseWrapperDTO
 */
export interface InboundShipmentCreateResponseWrapperDTO {
    /**
     * 
     * @type {string}
     * @memberof InboundShipmentCreateResponseWrapperDTO
     */
    status?: string;
    /**
     * response payload
     * @type {Array<InlineResponse2004Payload>}
     * @memberof InboundShipmentCreateResponseWrapperDTO
     */
    payload?: Array<InlineResponse2004Payload>;
}
/**
 * 
 * @export
 * @interface InboundShipmentErrorResponseWrapperDTO
 */
export interface InboundShipmentErrorResponseWrapperDTO {
    /**
     * 
     * @type {InlineResponse2003Headers}
     * @memberof InboundShipmentErrorResponseWrapperDTO
     */
    headers?: InlineResponse2003Headers;
    /**
     * response payload
     * @type {Array<InlineResponse20012Payload>}
     * @memberof InboundShipmentErrorResponseWrapperDTO
     */
    payload?: Array<InlineResponse20012Payload>;
}
/**
 * response payload
 * @export
 * @interface InboundShipmentErrorsResponseWrapper
 */
export interface InboundShipmentErrorsResponseWrapper {
    /**
     * Unique ID identifying inbound shipment requests
     * @type {string}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    inboundOrderId?: string;
    /**
     * created date for the request
     * @type {string}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    createdDate?: string;
    /**
     * 
     * @type {InlineResponse2003ReturnAddress}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    returnAddress?: InlineResponse2003ReturnAddress;
    /**
     * inbound shipment request line items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
    /**
     * Error in inbound shipment creation
     * @type {Array<InlineResponse200Errors>}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    errors?: Array<InlineResponse200Errors>;
}
/**
 * 
 * @export
 * @interface InboundShipmentRequestWrapper
 */
export interface InboundShipmentRequestWrapper {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InboundShipmentRequestWrapper
     */
    inboundOrderId: string;
    /**
     * 
     * @type {V3FulfillmentInboundShipmentsInboundServices}
     * @memberof InboundShipmentRequestWrapper
     */
    inboundServices?: V3FulfillmentInboundShipmentsInboundServices;
    /**
     * 
     * @type {InlineResponse2003ReturnAddress}
     * @memberof InboundShipmentRequestWrapper
     */
    returnAddress: InlineResponse2003ReturnAddress;
    /**
     * inbound shipment request line items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof InboundShipmentRequestWrapper
     */
    orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
}
/**
 * 
 * @export
 * @interface InboundShipmentUpdateQtyWrapper
 */
export interface InboundShipmentUpdateQtyWrapper {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InboundShipmentUpdateQtyWrapper
     */
    inboundOrderId: string;
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof InboundShipmentUpdateQtyWrapper
     */
    shipmentId: string;
    /**
     * update shipment qty line items
     * @type {Array<V3FulfillmentShipmentQuantitiesOrderItems>}
     * @memberof InboundShipmentUpdateQtyWrapper
     */
    orderItems?: Array<V3FulfillmentShipmentQuantitiesOrderItems>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InlineObject
     */
    inboundOrderId: string;
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof InlineObject
     */
    shipmentId: string;
    /**
     * update shipment qty line items
     * @type {Array<V3FulfillmentShipmentQuantitiesOrderItems>}
     * @memberof InlineObject
     */
    orderItems?: Array<V3FulfillmentShipmentQuantitiesOrderItems>;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {V3ItemsOnholdSearchQuery}
     * @memberof InlineObject1
     */
    query?: V3ItemsOnholdSearchQuery;
    /**
     * 
     * @type {Array<V3ItemsOnholdSearchFilters>}
     * @memberof InlineObject1
     */
    filters?: Array<V3ItemsOnholdSearchFilters>;
    /**
     * 
     * @type {V3ItemsOnholdSearchSort}
     * @memberof InlineObject1
     */
    sort?: V3ItemsOnholdSearchSort;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    shipmentId: string;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    shipDate: string;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * Feed file to upload
     * @type {any}
     * @memberof InlineObject12
     */
    file: any;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    carrierName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject2
     */
    trackingInfo?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    labelSize?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    labelFormat?: string;
    /**
     * 
     * @type {Array<V3FulfillmentShipmentLabelLoadTypes>}
     * @memberof InlineObject3
     */
    loadTypes?: Array<V3FulfillmentShipmentLabelLoadTypes>;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof InlineObject4
     */
    header: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayload}
     * @memberof InlineObject4
     */
    payload: V3FulfillmentOrdersFulfillmentsPayload;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof InlineObject5
     */
    header: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload}
     * @memberof InlineObject5
     */
    payload?: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof InlineObject6
     */
    header: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsCancelPayload}
     * @memberof InlineObject6
     */
    payload?: V3FulfillmentOrdersFulfillmentsCancelPayload;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InlineObject7
     */
    inboundOrderId: string;
    /**
     * 
     * @type {V3FulfillmentInboundShipmentsInboundServices}
     * @memberof InlineObject7
     */
    inboundServices?: V3FulfillmentInboundShipmentsInboundServices;
    /**
     * 
     * @type {InlineResponse2003ReturnAddress}
     * @memberof InlineObject7
     */
    returnAddress: InlineResponse2003ReturnAddress;
    /**
     * inbound shipment request line items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof InlineObject7
     */
    orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {V3FulfillmentInboundPreviewHeader}
     * @memberof InlineObject8
     */
    header: V3FulfillmentInboundPreviewHeader;
    /**
     * 
     * @type {V3FulfillmentInboundPreviewPayload}
     * @memberof InlineObject8
     */
    payload: V3FulfillmentInboundPreviewPayload;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    shipmentSource: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    pickupFromDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    pickupToDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    deliveryFromDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    deliveryToDateTime?: string;
    /**
     * 
     * @type {V3FulfillmentCarrierRateQuotesCustomer}
     * @memberof InlineObject9
     */
    customer: V3FulfillmentCarrierRateQuotesCustomer;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof InlineObject9
     */
    originLocation: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof InlineObject9
     */
    destinationLocation: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006ReturnLocation}
     * @memberof InlineObject9
     */
    returnLocation: InlineResponse2006ReturnLocation;
    /**
     * 
     * @type {Array<InlineResponse2006ShipmentPackages>}
     * @memberof InlineObject9
     */
    shipmentPackages: Array<InlineResponse2006ShipmentPackages>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    mode: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    freightClass?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject9
     */
    declaredValue?: number;
    /**
     * 
     * @type {Array<V3FulfillmentCarrierRateQuotesLoadTypes>}
     * @memberof InlineObject9
     */
    loadTypes?: Array<V3FulfillmentCarrierRateQuotesLoadTypes>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    status: InlineResponse200StatusEnum;
    /**
     * 
     * @type {InlineResponse200Header}
     * @memberof InlineResponse200
     */
    header?: InlineResponse200Header;
    /**
     * 
     * @type {Array<InlineResponse200Errors>}
     * @memberof InlineResponse200
     */
    errors?: Array<InlineResponse200Errors>;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse200
     */
    payload?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200StatusEnum {
    Ok = 'OK',
    Created = 'CREATED',
    Accepted = 'ACCEPTED',
    NoContent = 'NO_CONTENT',
    Partial = 'PARTIAL',
    MovedPermanent = 'MOVED_PERMANENT',
    Found = 'FOUND',
    SeeOther = 'SEE_OTHER',
    NotModified = 'NOT_MODIFIED',
    TemporaryRedirect = 'TEMPORARY_REDIRECT',
    BadRequest = 'BAD_REQUEST',
    Unauthorized = 'UNAUTHORIZED',
    Forbidden = 'FORBIDDEN',
    NotFound = 'NOT_FOUND',
    MethodNotAllowed = 'METHOD_NOT_ALLOWED',
    NotAcceptable = 'NOT_ACCEPTABLE',
    RequestTimeout = 'REQUEST_TIMEOUT',
    Conflict = 'CONFLICT',
    RequestEntityTooLarge = 'REQUEST_ENTITY_TOO_LARGE',
    UnsupportedMediaType = 'UNSUPPORTED_MEDIA_TYPE',
    UnprocessableEntity = 'UNPROCESSABLE_ENTITY',
    TooManyRequests = 'TOO_MANY_REQUESTS',
    Fail = 'FAIL',
    BadGateway = 'BAD_GATEWAY',
    ServiceUnavailable = 'SERVICE_UNAVAILABLE',
    GatewayTimeout = 'GATEWAY_TIMEOUT'
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * status
     * @type {string}
     * @memberof InlineResponse2001
     */
    status?: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof InlineResponse2001
     */
    header?: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {InlineResponse2001Payload}
     * @memberof InlineResponse2001
     */
    payload?: InlineResponse2001Payload;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {InlineResponse20010Headers}
     * @memberof InlineResponse20010
     */
    headers?: InlineResponse20010Headers;
    /**
     * 
     * @type {InlineResponse20010Payload}
     * @memberof InlineResponse20010
     */
    payload?: InlineResponse20010Payload;
}
/**
 * Headers Section
 * @export
 * @interface InlineResponse20010Headers
 */
export interface InlineResponse20010Headers {
    /**
     * Number of records to be returned
     * @type {number}
     * @memberof InlineResponse20010Headers
     */
    limit?: number;
    /**
     * Number of records you wish to skip before selecting records
     * @type {number}
     * @memberof InlineResponse20010Headers
     */
    offset?: number;
    /**
     * Total Count of records this request yields
     * @type {number}
     * @memberof InlineResponse20010Headers
     */
    totalCount?: number;
}
/**
 * Payload Section
 * @export
 * @interface InlineResponse20010Payload
 */
export interface InlineResponse20010Payload {
    /**
     * GTIN
     * @type {string}
     * @memberof InlineResponse20010Payload
     */
    gtin?: string;
    /**
     * Vendor SKU
     * @type {string}
     * @memberof InlineResponse20010Payload
     */
    vendorSku?: string;
    /**
     * Product Name
     * @type {string}
     * @memberof InlineResponse20010Payload
     */
    productName?: string;
    /**
     * Inventory Log records
     * @type {Array<InlineResponse20010PayloadInventoryLog>}
     * @memberof InlineResponse20010Payload
     */
    inventoryLog?: Array<InlineResponse20010PayloadInventoryLog>;
}
/**
 * Inventory Log records
 * @export
 * @interface InlineResponse20010PayloadInventoryLog
 */
export interface InlineResponse20010PayloadInventoryLog {
    /**
     * Unique Event Id
     * @type {string}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    id?: string;
    /**
     * Fulfillment Center Short Name
     * @type {string}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    fcName?: string;
    /**
     * Number of inventory units changed +/- in FC as a result of this transaction
     * @type {number}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    changedUnits?: number;
    /**
     * Timestamp of transaction
     * @type {string}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    transactionTime?: string;
    /**
     * Transaction Location
     * @type {string}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    transactionLocation?: string;
    /**
     * Transaction Reason Code
     * @type {string}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    transactionReasonCode?: string;
    /**
     * Transaction Reason Description
     * @type {string}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    transactionReasonDesc?: string;
    /**
     * Transaction Type
     * @type {string}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    transactionType?: string;
    /**
     * Shipment Id
     * @type {string}
     * @memberof InlineResponse20010PayloadInventoryLog
     */
    shipmentId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {InlineResponse2003Headers}
     * @memberof InlineResponse20011
     */
    headers?: InlineResponse2003Headers;
    /**
     * response payload
     * @type {Array<InlineResponse20011Payload>}
     * @memberof InlineResponse20011
     */
    payload?: Array<InlineResponse20011Payload>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse20011Payload
 */
export interface InlineResponse20011Payload {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InlineResponse20011Payload
     */
    inboundOrderId?: string;
    /**
     * Unique ID identifying each shipment
     * @type {string}
     * @memberof InlineResponse20011Payload
     */
    shipmentId?: string;
    /**
     * Item barcode
     * @type {string}
     * @memberof InlineResponse20011Payload
     */
    gtin?: string;
    /**
     * Seller Item ID
     * @type {string}
     * @memberof InlineResponse20011Payload
     */
    sku?: string;
    /**
     * Item description
     * @type {string}
     * @memberof InlineResponse20011Payload
     */
    itemDesc?: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof InlineResponse20011Payload
     */
    itemQty?: number;
    /**
     * Total number of cases
     * @type {number}
     * @memberof InlineResponse20011Payload
     */
    vendorPackQty?: number;
    /**
     * Total number of sellable units per case
     * @type {number}
     * @memberof InlineResponse20011Payload
     */
    innerPackQty?: number;
    /**
     * Qty received in FC
     * @type {number}
     * @memberof InlineResponse20011Payload
     */
    receivedQty?: number;
    /**
     * Qty damaged while receiving in FC
     * @type {number}
     * @memberof InlineResponse20011Payload
     */
    damagedQty?: number;
    /**
     * Fill rate for this shipment item
     * @type {number}
     * @memberof InlineResponse20011Payload
     */
    fillRate?: number;
    /**
     * expected delivery date provided by seller
     * @type {string}
     * @memberof InlineResponse20011Payload
     */
    expectedDeliveryDate?: string;
    /**
     * update expected delivery date based on network capacity
     * @type {string}
     * @memberof InlineResponse20011Payload
     */
    updatedExpectedDeliveryDate?: string;
    /**
     * FC name
     * @type {string}
     * @memberof InlineResponse20011Payload
     */
    shipNodeName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {InlineResponse2003Headers}
     * @memberof InlineResponse20012
     */
    headers?: InlineResponse2003Headers;
    /**
     * response payload
     * @type {Array<InlineResponse20012Payload>}
     * @memberof InlineResponse20012
     */
    payload?: Array<InlineResponse20012Payload>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse20012Payload
 */
export interface InlineResponse20012Payload {
    /**
     * Unique ID identifying inbound shipment requests
     * @type {string}
     * @memberof InlineResponse20012Payload
     */
    inboundOrderId?: string;
    /**
     * created date for the request
     * @type {string}
     * @memberof InlineResponse20012Payload
     */
    createdDate?: string;
    /**
     * 
     * @type {InlineResponse2003ReturnAddress}
     * @memberof InlineResponse20012Payload
     */
    returnAddress?: InlineResponse2003ReturnAddress;
    /**
     * inbound shipment request line items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof InlineResponse20012Payload
     */
    orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
    /**
     * Error in inbound shipment creation
     * @type {Array<InlineResponse200Errors>}
     * @memberof InlineResponse20012Payload
     */
    errors?: Array<InlineResponse200Errors>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse2001Payload
 */
export interface InlineResponse2001Payload {
    /**
     * Unique ID identifying each request
     * @type {string}
     * @memberof InlineResponse2001Payload
     */
    requestId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * Response status.
     * @type {string}
     * @memberof InlineResponse2002
     */
    status?: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof InlineResponse2002
     */
    header?: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {InlineResponse2002Payload}
     * @memberof InlineResponse2002
     */
    payload?: InlineResponse2002Payload;
}
/**
 * Response payload.
 * @export
 * @interface InlineResponse2002Payload
 */
export interface InlineResponse2002Payload {
    /**
     * Offer details indicating available quantity vs required quantify for offer
     * @type {Array<InlineResponse2002PayloadOffers>}
     * @memberof InlineResponse2002Payload
     */
    offers?: Array<InlineResponse2002PayloadOffers>;
    /**
     * Customer order destination details.
     * @type {Array<InlineResponse2002PayloadDestinations>}
     * @memberof InlineResponse2002Payload
     */
    destinations?: Array<InlineResponse2002PayloadDestinations>;
    /**
     * The identifier to identify the response.
     * @type {string}
     * @memberof InlineResponse2002Payload
     */
    prepurchaseHandle?: string;
    /**
     * Fulfillment plans details.
     * @type {Array<InlineResponse2002PayloadFulfillmentPlans>}
     * @memberof InlineResponse2002Payload
     */
    fulfillmentPlans?: Array<InlineResponse2002PayloadFulfillmentPlans>;
}
/**
 * Fulfillment access mode details.
 * @export
 * @interface InlineResponse2002PayloadAccessMode
 */
export interface InlineResponse2002PayloadAccessMode {
    /**
     * Fulfillment access mode type. For example : \'NATIONAL_CARRIER\'
     * @type {string}
     * @memberof InlineResponse2002PayloadAccessMode
     */
    mode?: string;
}
/**
 * Available Quantity Information of an item.
 * @export
 * @interface InlineResponse2002PayloadAvailableQuantity
 */
export interface InlineResponse2002PayloadAvailableQuantity {
    /**
     * Quantity of each item.
     * @type {number}
     * @memberof InlineResponse2002PayloadAvailableQuantity
     */
    measurementValue: number;
    /**
     * Unit of quantity. Currently supported type : \'EA\'
     * @type {string}
     * @memberof InlineResponse2002PayloadAvailableQuantity
     */
    unitOfMeasure: string;
}
/**
 * Customer order destination details.
 * @export
 * @interface InlineResponse2002PayloadDestinations
 */
export interface InlineResponse2002PayloadDestinations {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress}
     * @memberof InlineResponse2002PayloadDestinations
     */
    address?: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress;
    /**
     * Fulfillment Type of an order. Currently supported type : \'DELIVERY\'
     * @type {string}
     * @memberof InlineResponse2002PayloadDestinations
     */
    fulfillmentType?: string;
    /**
     * Destination id detail. For example : \'fulfillment type for DELIVERY has destinationId 0
     * @type {string}
     * @memberof InlineResponse2002PayloadDestinations
     */
    destinationId?: string;
}
/**
 * Fulfillment Group details.
 * @export
 * @interface InlineResponse2002PayloadFulfillmentGroups
 */
export interface InlineResponse2002PayloadFulfillmentGroups {
    /**
     * Fulfillment options details.
     * @type {Array<InlineResponse2002PayloadFulfillmentOptions>}
     * @memberof InlineResponse2002PayloadFulfillmentGroups
     */
    fulfillmentOptions?: Array<InlineResponse2002PayloadFulfillmentOptions>;
}
/**
 * Fulfillment module details.
 * @export
 * @interface InlineResponse2002PayloadFulfillmentModules
 */
export interface InlineResponse2002PayloadFulfillmentModules {
    /**
     * Fulfillment module name. For example : \'UNSCHEDULED_DELIVERY and ERROR\'
     * @type {string}
     * @memberof InlineResponse2002PayloadFulfillmentModules
     */
    name?: string;
    /**
     * Fulfillment Group details.
     * @type {Array<InlineResponse2002PayloadFulfillmentGroups>}
     * @memberof InlineResponse2002PayloadFulfillmentModules
     */
    fulfillmentGroups?: Array<InlineResponse2002PayloadFulfillmentGroups>;
}
/**
 * Fulfillment options details.
 * @export
 * @interface InlineResponse2002PayloadFulfillmentOptions
 */
export interface InlineResponse2002PayloadFulfillmentOptions {
    /**
     * Fulfillment mode detail. For example : \'UNSCHEDULED\'
     * @type {string}
     * @memberof InlineResponse2002PayloadFulfillmentOptions
     */
    fulfillmentMode?: string;
    /**
     * Fulfillment access type. For example : \'DELIVERY_ADDRESS\'
     * @type {string}
     * @memberof InlineResponse2002PayloadFulfillmentOptions
     */
    accessType?: string;
    /**
     * Fulfillment details.
     * @type {Array<InlineResponse2002PayloadFulfillments>}
     * @memberof InlineResponse2002PayloadFulfillmentOptions
     */
    fulfillments?: Array<InlineResponse2002PayloadFulfillments>;
    /**
     * Fulfillment type detail. For example : \'DELIVERY\'
     * @type {string}
     * @memberof InlineResponse2002PayloadFulfillmentOptions
     */
    fulfillmentType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002PayloadFulfillmentOptions
     */
    _default?: boolean;
}
/**
 * Fulfillment plans details.
 * @export
 * @interface InlineResponse2002PayloadFulfillmentPlans
 */
export interface InlineResponse2002PayloadFulfillmentPlans {
    /**
     * Fulfillment module details.
     * @type {Array<InlineResponse2002PayloadFulfillmentModules>}
     * @memberof InlineResponse2002PayloadFulfillmentPlans
     */
    fulfillmentModules?: Array<InlineResponse2002PayloadFulfillmentModules>;
}
/**
 * Fulfillment time details.
 * @export
 * @interface InlineResponse2002PayloadFulfillmentTime
 */
export interface InlineResponse2002PayloadFulfillmentTime {
    /**
     * 
     * @type {InlineResponse2002PayloadFulfillmentTimeDate}
     * @memberof InlineResponse2002PayloadFulfillmentTime
     */
    date?: InlineResponse2002PayloadFulfillmentTimeDate;
}
/**
 * Fulfillment date details.
 * @export
 * @interface InlineResponse2002PayloadFulfillmentTimeDate
 */
export interface InlineResponse2002PayloadFulfillmentTimeDate {
    /**
     * Fulfillment minimum promise date detail.
     * @type {string}
     * @memberof InlineResponse2002PayloadFulfillmentTimeDate
     */
    minPromiseDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002PayloadFulfillmentTimeDate
     */
    Fulfillment_maximum_promise_date_detail_?: string;
}
/**
 * Fulfillment details.
 * @export
 * @interface InlineResponse2002PayloadFulfillments
 */
export interface InlineResponse2002PayloadFulfillments {
    /**
     * The identifier to identify fulfillment.
     * @type {string}
     * @memberof InlineResponse2002PayloadFulfillments
     */
    fulfillmentId?: string;
    /**
     * Line item attribute details.
     * @type {Array<InlineResponse2002PayloadLineItemAttributesList>}
     * @memberof InlineResponse2002PayloadFulfillments
     */
    lineItemAttributesList?: Array<InlineResponse2002PayloadLineItemAttributesList>;
    /**
     * 
     * @type {InlineResponse2002PayloadSla}
     * @memberof InlineResponse2002PayloadFulfillments
     */
    sla?: InlineResponse2002PayloadSla;
    /**
     * Fulfillment node type details. For example : \'FC\'
     * @type {string}
     * @memberof InlineResponse2002PayloadFulfillments
     */
    nodeType?: string;
    /**
     * 
     * @type {InlineResponse2002PayloadAccessMode}
     * @memberof InlineResponse2002PayloadFulfillments
     */
    accessMode?: InlineResponse2002PayloadAccessMode;
    /**
     * 
     * @type {InlineResponse2002PayloadFulfillmentTime}
     * @memberof InlineResponse2002PayloadFulfillments
     */
    fulfillmentTime?: InlineResponse2002PayloadFulfillmentTime;
    /**
     * Error list details.
     * @type {Array<InlineResponse200Errors>}
     * @memberof InlineResponse2002PayloadFulfillments
     */
    errors?: Array<InlineResponse200Errors>;
}
/**
 * Line item attribute details.
 * @export
 * @interface InlineResponse2002PayloadLineItemAttributesList
 */
export interface InlineResponse2002PayloadLineItemAttributesList {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity}
     * @memberof InlineResponse2002PayloadLineItemAttributesList
     */
    availableQuantity?: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity;
    /**
     * Fulfillment channel details. For example : \'WFS_FULFILLED\'
     * @type {Array<string>}
     * @memberof InlineResponse2002PayloadLineItemAttributesList
     */
    fulfillmentChannel?: Array<string>;
    /**
     * The identifier to identify each line, assigned by seller systems.
     * @type {string}
     * @memberof InlineResponse2002PayloadLineItemAttributesList
     */
    lineId?: string;
}
/**
 * Offer details indicating available quantity vs required quantify for offer
 * @export
 * @interface InlineResponse2002PayloadOffers
 */
export interface InlineResponse2002PayloadOffers {
    /**
     * 
     * @type {InlineResponse2002PayloadAvailableQuantity}
     * @memberof InlineResponse2002PayloadOffers
     */
    availableQuantity?: InlineResponse2002PayloadAvailableQuantity;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity}
     * @memberof InlineResponse2002PayloadOffers
     */
    requestedQuantity?: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity;
    /**
     * The identifier (UUID) for each line assigned by seller systems.
     * @type {string}
     * @memberof InlineResponse2002PayloadOffers
     */
    lineId?: string;
    /**
     * Sales unit type. Currently supported type : \'EACH\'
     * @type {string}
     * @memberof InlineResponse2002PayloadOffers
     */
    salesUnit?: string;
    /**
     * The identifier of the item in seller system (vendor sku).
     * @type {string}
     * @memberof InlineResponse2002PayloadOffers
     */
    sku?: string;
}
/**
 * Fulfillment service level agreement details.
 * @export
 * @interface InlineResponse2002PayloadSla
 */
export interface InlineResponse2002PayloadSla {
    /**
     * Service level agreement tier details.For example : \'TWO_DAY\'
     * @type {string}
     * @memberof InlineResponse2002PayloadSla
     */
    tier?: string;
    /**
     * Ship method details. For example : \'Rush, Expedited, Value and Standard\'
     * @type {string}
     * @memberof InlineResponse2002PayloadSla
     */
    speed?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {InlineResponse2003Headers}
     * @memberof InlineResponse2003
     */
    headers?: InlineResponse2003Headers;
    /**
     * response payload
     * @type {Array<InlineResponse2003Payload>}
     * @memberof InlineResponse2003
     */
    payload?: Array<InlineResponse2003Payload>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003Headers
 */
export interface InlineResponse2003Headers {
    /**
     * total number of POs for provided GET request.
     * @type {number}
     * @memberof InlineResponse2003Headers
     */
    totalCount?: number;
    /**
     * provided limit value in the request
     * @type {number}
     * @memberof InlineResponse2003Headers
     */
    limit?: number;
    /**
     * provided offset value in the request.
     * @type {number}
     * @memberof InlineResponse2003Headers
     */
    offset?: number;
}
/**
 * response payload
 * @export
 * @interface InlineResponse2003Payload
 */
export interface InlineResponse2003Payload {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    inboundOrderId?: string;
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    shipmentId?: string;
    /**
     * 
     * @type {InlineResponse2003ShipToAddress}
     * @memberof InlineResponse2003Payload
     */
    shipToAddress?: InlineResponse2003ShipToAddress;
    /**
     * 
     * @type {InlineResponse2003ReturnAddress}
     * @memberof InlineResponse2003Payload
     */
    returnAddress?: InlineResponse2003ReturnAddress;
    /**
     * Current status of the shipment
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    status?: string;
    /**
     * creation date for shipment
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    createdDate?: string;
    /**
     * Total number of units in the shipment
     * @type {number}
     * @memberof InlineResponse2003Payload
     */
    shipmentUnits?: number;
    /**
     * Total number of units recived in FC for the shipment
     * @type {number}
     * @memberof InlineResponse2003Payload
     */
    receivedUnits?: number;
    /**
     * expected delivery date provided by seller
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    expectedDeliveryDate?: string;
    /**
     * update expected delivery date based on network capacity
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    updatedExpectedDeliveryDate?: string;
    /**
     * Actual delivery date of the shipment at FC
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    actualDeliveryDate?: string;
    /**
     * Tracking info for the shipment
     * @type {Array<string>}
     * @memberof InlineResponse2003Payload
     */
    trackingNo?: Array<string>;
    /**
     * Carrier of the shipment
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    carrierName?: string;
}
/**
 * return address of seller
 * @export
 * @interface InlineResponse2003ReturnAddress
 */
export interface InlineResponse2003ReturnAddress {
    /**
     * Address details
     * @type {string}
     * @memberof InlineResponse2003ReturnAddress
     */
    addressLine1: string;
    /**
     * Address details continuation
     * @type {string}
     * @memberof InlineResponse2003ReturnAddress
     */
    addressLine2?: string;
    /**
     * City name
     * @type {string}
     * @memberof InlineResponse2003ReturnAddress
     */
    city: string;
    /**
     * State Code
     * @type {string}
     * @memberof InlineResponse2003ReturnAddress
     */
    stateCode: string;
    /**
     * Country code
     * @type {string}
     * @memberof InlineResponse2003ReturnAddress
     */
    countryCode: string;
    /**
     * Zip code
     * @type {string}
     * @memberof InlineResponse2003ReturnAddress
     */
    postalCode: string;
}
/**
 * The address to which sellers need to inbound items
 * @export
 * @interface InlineResponse2003ShipToAddress
 */
export interface InlineResponse2003ShipToAddress {
    /**
     * Facility name
     * @type {string}
     * @memberof InlineResponse2003ShipToAddress
     */
    fcName?: string;
    /**
     * Address details 
     * @type {string}
     * @memberof InlineResponse2003ShipToAddress
     */
    addressLine1?: string;
    /**
     * Address details continuation
     * @type {string}
     * @memberof InlineResponse2003ShipToAddress
     */
    addressLine2?: string;
    /**
     * City name
     * @type {string}
     * @memberof InlineResponse2003ShipToAddress
     */
    city?: string;
    /**
     * State code
     * @type {string}
     * @memberof InlineResponse2003ShipToAddress
     */
    stateCode?: string;
    /**
     * Country code
     * @type {string}
     * @memberof InlineResponse2003ShipToAddress
     */
    countryCode?: string;
    /**
     * Zip code
     * @type {string}
     * @memberof InlineResponse2003ShipToAddress
     */
    postalCode?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    status?: string;
    /**
     * response payload
     * @type {Array<InlineResponse2004Payload>}
     * @memberof InlineResponse2004
     */
    payload?: Array<InlineResponse2004Payload>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse2004Payload
 */
export interface InlineResponse2004Payload {
    /**
     * Unique ID identifying each shipment
     * @type {string}
     * @memberof InlineResponse2004Payload
     */
    shipmentId?: string;
    /**
     * 
     * @type {InlineResponse2003ShipToAddress}
     * @memberof InlineResponse2004Payload
     */
    shipToAddress?: InlineResponse2003ShipToAddress;
    /**
     * The items which needs to be send in the shipment
     * @type {Array<InlineResponse2004ShipmentItems>}
     * @memberof InlineResponse2004Payload
     */
    shipmentItems?: Array<InlineResponse2004ShipmentItems>;
    /**
     * expected delivery date for inbounding shipment. Can be different from provided in the rquest based on network capacity
     * @type {string}
     * @memberof InlineResponse2004Payload
     */
    expectedDeliveryDate?: string;
}
/**
 * The items which needs to be send in the shipment
 * @export
 * @interface InlineResponse2004ShipmentItems
 */
export interface InlineResponse2004ShipmentItems {
    /**
     * Seller Item ID
     * @type {string}
     * @memberof InlineResponse2004ShipmentItems
     */
    vendorSku?: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof InlineResponse2004ShipmentItems
     */
    itemQty?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * Response status.
     * @type {string}
     * @memberof InlineResponse2005
     */
    status?: string;
    /**
     * Response payload.
     * @type {Array<InlineResponse2005Payload>}
     * @memberof InlineResponse2005
     */
    payload?: Array<InlineResponse2005Payload>;
}
/**
 * Response payload.
 * @export
 * @interface InlineResponse2005Payload
 */
export interface InlineResponse2005Payload {
    /**
     * Unique shipment identifier
     * @type {string}
     * @memberof InlineResponse2005Payload
     */
    inboundOrderId?: string;
    /**
     * List of preview responses
     * @type {Array<InlineResponse2005Previews>}
     * @memberof InlineResponse2005Payload
     */
    previews?: Array<InlineResponse2005Previews>;
}
/**
 * Preview
 * @export
 * @interface InlineResponse2005Preview
 */
export interface InlineResponse2005Preview {
    /**
     * Ship Node
     * @type {string}
     * @memberof InlineResponse2005Preview
     */
    shipNode?: string;
    /**
     * Flag indicating if the dimensions of the item make it sortable
     * @type {boolean}
     * @memberof InlineResponse2005Preview
     */
    isSortable?: boolean;
    /**
     * Flag indicating if the dimensions of the item make it non-sortable
     * @type {boolean}
     * @memberof InlineResponse2005Preview
     */
    isNonSortable?: boolean;
    /**
     * Node Type: FC/ICC
     * @type {string}
     * @memberof InlineResponse2005Preview
     */
    nodeType?: string;
    /**
     * 
     * @type {InlineResponse2003ShipToAddress}
     * @memberof InlineResponse2005Preview
     */
    shipToAddress?: InlineResponse2003ShipToAddress;
    /**
     * Total charge if you are using ITS.
     * @type {number}
     * @memberof InlineResponse2005Preview
     */
    totalNetTransferCharge?: number;
    /**
     * Currency in which transfer charge is estimated
     * @type {string}
     * @memberof InlineResponse2005Preview
     */
    currencyUnit?: string;
    /**
     * Shipment items
     * @type {Array<InlineResponse2005ShipmentItems>}
     * @memberof InlineResponse2005Preview
     */
    shipmentItems?: Array<InlineResponse2005ShipmentItems>;
}
/**
 * List of preview responses
 * @export
 * @interface InlineResponse2005Previews
 */
export interface InlineResponse2005Previews {
    /**
     * Use \"inbound\" if you are using WFS Inventory Transfer Service (ITS). Use \"selfMirroring\" if you are not using ITS and shipping directly to Walmart fulfillment centers.
     * @type {string}
     * @memberof InlineResponse2005Previews
     */
    previewType?: string;
    /**
     * Preview
     * @type {Array<InlineResponse2005Preview>}
     * @memberof InlineResponse2005Previews
     */
    preview?: Array<InlineResponse2005Preview>;
}
/**
 * Shipment items
 * @export
 * @interface InlineResponse2005ShipmentItems
 */
export interface InlineResponse2005ShipmentItems {
    /**
     * Vendor SKU
     * @type {string}
     * @memberof InlineResponse2005ShipmentItems
     */
    vendorSku?: string;
    /**
     * Product type: GTIN/UPC/EAN
     * @type {string}
     * @memberof InlineResponse2005ShipmentItems
     */
    productType?: string;
    /**
     * Unique product identifier
     * @type {string}
     * @memberof InlineResponse2005ShipmentItems
     */
    productId?: string;
    /**
     * Item quantity
     * @type {number}
     * @memberof InlineResponse2005ShipmentItems
     */
    itemQty?: number;
    /**
     * Total charge if you are using ITS.
     * @type {number}
     * @memberof InlineResponse2005ShipmentItems
     */
    netTransferCharge?: number;
    /**
     * Currency in which transfer charge is estimated
     * @type {string}
     * @memberof InlineResponse2005ShipmentItems
     */
    currencyUnit?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    quoteId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    estimatedDeliveryDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    quoteCreationDate?: string;
    /**
     * 
     * @type {InlineResponse2006Carrier}
     * @memberof InlineResponse2006
     */
    carrier?: InlineResponse2006Carrier;
    /**
     * 
     * @type {InlineResponse2006RateQuote}
     * @memberof InlineResponse2006
     */
    rateQuote?: InlineResponse2006RateQuote;
    /**
     * 
     * @type {Array<InlineResponse2006ShipmentPackages>}
     * @memberof InlineResponse2006
     */
    shipmentPackages?: Array<InlineResponse2006ShipmentPackages>;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof InlineResponse2006
     */
    originLocation?: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof InlineResponse2006
     */
    destinationLocation?: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006ReturnLocation}
     * @memberof InlineResponse2006
     */
    returnLocation?: InlineResponse2006ReturnLocation;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Carrier
 */
export interface InlineResponse2006Carrier {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Carrier
     */
    carrierId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Carrier
     */
    carrierName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006LabelInformation
 */
export interface InlineResponse2006LabelInformation {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    labelData?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    labelFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    trackingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    referenceTrackingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    epTrackerId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    packageAsn?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    masterTrackingCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006LabelInformation
     */
    master?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2006OriginLocation
 */
export interface InlineResponse2006OriginLocation {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof InlineResponse2006OriginLocation
     */
    address: InlineResponse2006OriginLocationAddress;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocation
     */
    locationId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006OriginLocationAddress
 */
export interface InlineResponse2006OriginLocationAddress {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    stateCode: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    phone?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006RateQuote
 */
export interface InlineResponse2006RateQuote {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    quoteId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    estimatedDeliveryDateTime?: string;
    /**
     * 
     * @type {InlineResponse2006Carrier}
     * @memberof InlineResponse2006RateQuote
     */
    carrier?: InlineResponse2006Carrier;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    discountCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    netCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    surchargeType?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    surchargeValue?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    totalBillingWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    transitDays?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    effectiveDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    expiryDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    sellerFreightClassCode?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    freightCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    fuelCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    totalWeight?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    totalVolume?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    equipmentTypeCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    serviceCode?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    numberOfPallets?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    nominalCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    assessorialCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    serviceCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    minimumCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    declaredValue?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    mixedSKUs?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    singleSKUs?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    freightReadyDate?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006ReturnLocation
 */
export interface InlineResponse2006ReturnLocation {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ReturnLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof InlineResponse2006ReturnLocation
     */
    address: InlineResponse2006OriginLocationAddress;
}
/**
 * 
 * @export
 * @interface InlineResponse2006ShipmentPackages
 */
export interface InlineResponse2006ShipmentPackages {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    packageSequenceNumber: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    weight: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ShipmentPackages
     */
    weightUOM: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    length: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    width: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ShipmentPackages
     */
    lengthUOM: string;
    /**
     * 
     * @type {InlineResponse2006LabelInformation}
     * @memberof InlineResponse2006ShipmentPackages
     */
    labelInformation?: InlineResponse2006LabelInformation;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    billingWeight?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    netCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    nominalCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    assessorialCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    serviceCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ShipmentPackages
     */
    packageType?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    noOfPackages?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006ShipmentPackages
     */
    stackable?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    shipmentNumber?: string;
    /**
     * 
     * @type {Array<InlineResponse2006RateQuote>}
     * @memberof InlineResponse2007
     */
    rateQuotes?: Array<InlineResponse2006RateQuote>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
     * @type {string}
     * @memberof InlineResponse2008
     */
    feedId?: string;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2008
     */
    additionalAttributes?: object | null;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2008
     */
    errors?: object | null;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * status
     * @type {string}
     * @memberof InlineResponse2009
     */
    status?: string;
    /**
     * 
     * @type {InlineResponse2009Header}
     * @memberof InlineResponse2009
     */
    header?: InlineResponse2009Header;
    /**
     * Order details
     * @type {Array<InlineResponse2009Payload>}
     * @memberof InlineResponse2009
     */
    payload?: Array<InlineResponse2009Payload>;
}
/**
 * buyerInfo of the order
 * @export
 * @interface InlineResponse2009BuyerInfo
 */
export interface InlineResponse2009BuyerInfo {
    /**
     * 
     * @type {InlineResponse2009BuyerInfoPrimaryContact}
     * @memberof InlineResponse2009BuyerInfo
     */
    primaryContact?: InlineResponse2009BuyerInfoPrimaryContact;
}
/**
 * Primary contact of the order
 * @export
 * @interface InlineResponse2009BuyerInfoPrimaryContact
 */
export interface InlineResponse2009BuyerInfoPrimaryContact {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName}
     * @memberof InlineResponse2009BuyerInfoPrimaryContact
     */
    name?: V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName;
}
/**
 * Customer shipping address
 * @export
 * @interface InlineResponse2009CustomerShipToAddress
 */
export interface InlineResponse2009CustomerShipToAddress {
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof InlineResponse2009CustomerShipToAddress
     */
    address?: InlineResponse2006OriginLocationAddress;
    /**
     * 
     * @type {InlineResponse2009CustomerShipToAddressName}
     * @memberof InlineResponse2009CustomerShipToAddress
     */
    name?: InlineResponse2009CustomerShipToAddressName;
}
/**
 * Customer name details
 * @export
 * @interface InlineResponse2009CustomerShipToAddressName
 */
export interface InlineResponse2009CustomerShipToAddressName {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009CustomerShipToAddressName
     */
    completeName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009CustomerShipToAddressName
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009CustomerShipToAddressName
     */
    lastName?: string;
}
/**
 * Meta data of the response
 * @export
 * @interface InlineResponse2009Header
 */
export interface InlineResponse2009Header {
    /**
     * 
     * @type {InlineResponse2009HeaderHeaderAttributes}
     * @memberof InlineResponse2009Header
     */
    headerAttributes?: InlineResponse2009HeaderHeaderAttributes;
}
/**
 * Header attributes
 * @export
 * @interface InlineResponse2009HeaderHeaderAttributes
 */
export interface InlineResponse2009HeaderHeaderAttributes {
    /**
     * martId passed in header
     * @type {string}
     * @memberof InlineResponse2009HeaderHeaderAttributes
     */
    martId?: string;
    /**
     * buId passed in header
     * @type {string}
     * @memberof InlineResponse2009HeaderHeaderAttributes
     */
    buId?: string;
    /**
     * page count of the orders available with given filters
     * @type {number}
     * @memberof InlineResponse2009HeaderHeaderAttributes
     */
    pageCount?: number;
    /**
     * total count of orders available with given filters
     * @type {number}
     * @memberof InlineResponse2009HeaderHeaderAttributes
     */
    totalCount?: number;
}
/**
 * Order line quantity information
 * @export
 * @interface InlineResponse2009OrderLineQuantityInfo
 */
export interface InlineResponse2009OrderLineQuantityInfo {
    /**
     * status of the order line quantity
     * @type {string}
     * @memberof InlineResponse2009OrderLineQuantityInfo
     */
    status?: string;
    /**
     * status description of the order line quantity
     * @type {string}
     * @memberof InlineResponse2009OrderLineQuantityInfo
     */
    statusDescription?: string;
    /**
     * 
     * @type {InlineResponse2009Quantity}
     * @memberof InlineResponse2009OrderLineQuantityInfo
     */
    statusQuantity?: InlineResponse2009Quantity;
}
/**
 * order lines details
 * @export
 * @interface InlineResponse2009OrderLines
 */
export interface InlineResponse2009OrderLines {
    /**
     * fulfillmentType of the order
     * @type {string}
     * @memberof InlineResponse2009OrderLines
     */
    fulfillmentType?: string;
    /**
     * Last modified date of the order lines
     * @type {string}
     * @memberof InlineResponse2009OrderLines
     */
    lastModified?: string;
    /**
     * Shipping method of the order lines
     * @type {string}
     * @memberof InlineResponse2009OrderLines
     */
    shippingMethod?: string;
    /**
     * Shipping tier of the order lines
     * @type {string}
     * @memberof InlineResponse2009OrderLines
     */
    shippingTier?: string;
    /**
     * Order line quantity information
     * @type {Array<InlineResponse2009OrderLineQuantityInfo>}
     * @memberof InlineResponse2009OrderLines
     */
    orderLineQuantityInfo?: Array<InlineResponse2009OrderLineQuantityInfo>;
    /**
     * 
     * @type {InlineResponse2009OrderProduct}
     * @memberof InlineResponse2009OrderLines
     */
    orderProduct?: InlineResponse2009OrderProduct;
    /**
     * 
     * @type {InlineResponse2009Quantity}
     * @memberof InlineResponse2009OrderLines
     */
    orderedQty?: InlineResponse2009Quantity;
    /**
     * 
     * @type {InlineResponse2009CustomerShipToAddress}
     * @memberof InlineResponse2009OrderLines
     */
    customerShipToAddress?: InlineResponse2009CustomerShipToAddress;
}
/**
 * Product details within order
 * @export
 * @interface InlineResponse2009OrderProduct
 */
export interface InlineResponse2009OrderProduct {
    /**
     * Product name of the order
     * @type {string}
     * @memberof InlineResponse2009OrderProduct
     */
    productName?: string;
}
/**
 * Order details
 * @export
 * @interface InlineResponse2009Payload
 */
export interface InlineResponse2009Payload {
    /**
     * orderChannelId of the order
     * @type {string}
     * @memberof InlineResponse2009Payload
     */
    orderChannelId?: string;
    /**
     * sellerOrderId of the order
     * @type {string}
     * @memberof InlineResponse2009Payload
     */
    sellerOrderId?: string;
    /**
     * order type of the order
     * @type {string}
     * @memberof InlineResponse2009Payload
     */
    orderType?: string;
    /**
     * status of the order
     * @type {string}
     * @memberof InlineResponse2009Payload
     */
    status?: string;
    /**
     * createDate of the order
     * @type {string}
     * @memberof InlineResponse2009Payload
     */
    orderDate?: string;
    /**
     * 
     * @type {InlineResponse2009BuyerInfo}
     * @memberof InlineResponse2009Payload
     */
    buyerInfo?: InlineResponse2009BuyerInfo;
    /**
     * createDate of the order
     * @type {Array<InlineResponse2009Shipments>}
     * @memberof InlineResponse2009Payload
     */
    shipments?: Array<InlineResponse2009Shipments>;
    /**
     * order lines details
     * @type {Array<InlineResponse2009OrderLines>}
     * @memberof InlineResponse2009Payload
     */
    orderLines?: Array<InlineResponse2009OrderLines>;
}
/**
 * Quantity of the order
 * @export
 * @interface InlineResponse2009Quantity
 */
export interface InlineResponse2009Quantity {
    /**
     * The unit of measure in the item\'s weight (e.g., \'EACH\' or \'EA\')
     * @type {string}
     * @memberof InlineResponse2009Quantity
     */
    unitOfMeasure: string;
    /**
     * The quantity of the unit of measure for the item
     * @type {number}
     * @memberof InlineResponse2009Quantity
     */
    measurementValue: number;
}
/**
 * Shipment dates
 * @export
 * @interface InlineResponse2009ShipmentDates
 */
export interface InlineResponse2009ShipmentDates {
    /**
     * Actual delivery date of the order
     * @type {string}
     * @memberof InlineResponse2009ShipmentDates
     */
    actualDate?: string;
    /**
     * Order dateTypeId
     * @type {string}
     * @memberof InlineResponse2009ShipmentDates
     */
    dateTypeId?: string;
    /**
     * Expected delivery date of the order
     * @type {string}
     * @memberof InlineResponse2009ShipmentDates
     */
    expectedDate?: string;
}
/**
 * Shipment line details
 * @export
 * @interface InlineResponse2009ShipmentLines
 */
export interface InlineResponse2009ShipmentLines {
    /**
     * Shipment line number
     * @type {string}
     * @memberof InlineResponse2009ShipmentLines
     */
    shipmentLineNo?: string;
    /**
     * Shipment fulfiller LineId
     * @type {string}
     * @memberof InlineResponse2009ShipmentLines
     */
    fulfillerLineId?: string;
    /**
     * 
     * @type {InlineResponse2009Quantity}
     * @memberof InlineResponse2009ShipmentLines
     */
    quantity?: InlineResponse2009Quantity;
}
/**
 * createDate of the order
 * @export
 * @interface InlineResponse2009Shipments
 */
export interface InlineResponse2009Shipments {
    /**
     * Shipment status
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    status?: string;
    /**
     * Shipment status description
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    statusDescription?: string;
    /**
     * Shipment purchase Order Id
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    purchaseOrderId?: string;
    /**
     * Shipment scac
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    scac?: string;
    /**
     * Shipment tracking number
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    trackingNo?: string;
    /**
     * Shipment tracking URL
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    externalTrackingURL?: string;
    /**
     * Shipment number
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    shipmentNo?: string;
    /**
     * Actual shipment date
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    actualShipmentDate?: string;
    /**
     * Shipment packageASN number
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    packageASN?: string;
    /**
     * Shipment carrier description
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    carrierDescription?: string;
    /**
     * Shipment carrier service code
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    carrierServiceCode?: string;
    /**
     * Shipment package Id
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    packageId?: string;
    /**
     * Shipment lastModified date
     * @type {string}
     * @memberof InlineResponse2009Shipments
     */
    lastModified?: string;
    /**
     * Shipment line details
     * @type {Array<InlineResponse2009ShipmentLines>}
     * @memberof InlineResponse2009Shipments
     */
    shipmentLines?: Array<InlineResponse2009ShipmentLines>;
    /**
     * Shipment dates
     * @type {Array<InlineResponse2009ShipmentDates>}
     * @memberof InlineResponse2009Shipments
     */
    shipmentDates?: Array<InlineResponse2009ShipmentDates>;
}
/**
 * 
 * @export
 * @interface InlineResponse200Causes
 */
export interface InlineResponse200Causes {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Causes
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Causes
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Causes
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Causes
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200Errors
 */
export interface InlineResponse200Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    severity?: InlineResponse200ErrorsSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    category?: InlineResponse200ErrorsCategoryEnum;
    /**
     * 
     * @type {Array<InlineResponse200Causes>}
     * @memberof InlineResponse200Errors
     */
    causes?: Array<InlineResponse200Causes>;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200ErrorsSeverityEnum {
    Info = 'INFO',
    Warn = 'WARN',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200ErrorsCategoryEnum {
    Application = 'APPLICATION',
    System = 'SYSTEM',
    Request = 'REQUEST',
    Data = 'DATA'
}

/**
 * 
 * @export
 * @interface InlineResponse200Header
 */
export interface InlineResponse200Header {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse200Header
     */
    headerAttributes?: { [key: string]: object; };
}
/**
 * Inventory Log records
 * @export
 * @interface InventoryLog
 */
export interface InventoryLog {
    /**
     * Unique Event Id
     * @type {string}
     * @memberof InventoryLog
     */
    id?: string;
    /**
     * Fulfillment Center Short Name
     * @type {string}
     * @memberof InventoryLog
     */
    fcName?: string;
    /**
     * Number of inventory units changed +/- in FC as a result of this transaction
     * @type {number}
     * @memberof InventoryLog
     */
    changedUnits?: number;
    /**
     * Timestamp of transaction
     * @type {string}
     * @memberof InventoryLog
     */
    transactionTime?: string;
    /**
     * Transaction Location
     * @type {string}
     * @memberof InventoryLog
     */
    transactionLocation?: string;
    /**
     * Transaction Reason Code
     * @type {string}
     * @memberof InventoryLog
     */
    transactionReasonCode?: string;
    /**
     * Transaction Reason Description
     * @type {string}
     * @memberof InventoryLog
     */
    transactionReasonDesc?: string;
    /**
     * Transaction Type
     * @type {string}
     * @memberof InventoryLog
     */
    transactionType?: string;
    /**
     * Shipment Id
     * @type {string}
     * @memberof InventoryLog
     */
    shipmentId?: string;
}
/**
 * 
 * @export
 * @interface InventoryLogResponseWrapper
 */
export interface InventoryLogResponseWrapper {
    /**
     * 
     * @type {InlineResponse20010Headers}
     * @memberof InventoryLogResponseWrapper
     */
    headers?: InlineResponse20010Headers;
    /**
     * 
     * @type {InlineResponse20010Payload}
     * @memberof InventoryLogResponseWrapper
     */
    payload?: InlineResponse20010Payload;
}
/**
 * Details of an item
 * @export
 * @interface ItemDetail
 */
export interface ItemDetail {
    /**
     * The identifier of the item in seller system (vendor sku)
     * @type {string}
     * @memberof ItemDetail
     */
    sku: string;
    /**
     * Description of the item
     * @type {string}
     * @memberof ItemDetail
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface LabelInformation
 */
export interface LabelInformation {
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    labelData?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    labelFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    trackingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    referenceTrackingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    epTrackerId?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    packageAsn?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    masterTrackingCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LabelInformation
     */
    master?: boolean;
}
/**
 * 
 * @export
 * @interface LabelV2RequestWrapper
 */
export interface LabelV2RequestWrapper {
    /**
     * 
     * @type {string}
     * @memberof LabelV2RequestWrapper
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof LabelV2RequestWrapper
     */
    labelSize?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelV2RequestWrapper
     */
    labelFormat?: string;
    /**
     * 
     * @type {Array<V3FulfillmentShipmentLabelLoadTypes>}
     * @memberof LabelV2RequestWrapper
     */
    loadTypes?: Array<V3FulfillmentShipmentLabelLoadTypes>;
}
/**
 * Line item attribute details.
 * @export
 * @interface LineItemAttributes
 */
export interface LineItemAttributes {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity}
     * @memberof LineItemAttributes
     */
    availableQuantity?: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity;
    /**
     * Fulfillment channel details. For example : \'WFS_FULFILLED\'
     * @type {Array<string>}
     * @memberof LineItemAttributes
     */
    fulfillmentChannel?: Array<string>;
    /**
     * The identifier to identify each line, assigned by seller systems.
     * @type {string}
     * @memberof LineItemAttributes
     */
    lineId?: string;
}
/**
 * 
 * @export
 * @interface LoadType
 */
export interface LoadType {
    /**
     * 
     * @type {number}
     * @memberof LoadType
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof LoadType
     */
    loadType?: string;
}
/**
 * 
 * @export
 * @interface LoadTypeDetails
 */
export interface LoadTypeDetails {
    /**
     * 
     * @type {string}
     * @memberof LoadTypeDetails
     */
    count: string;
    /**
     * 
     * @type {string}
     * @memberof LoadTypeDetails
     */
    loadType: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    severity?: ModelErrorSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    category?: ModelErrorCategoryEnum;
    /**
     * 
     * @type {Array<InlineResponse200Causes>}
     * @memberof ModelError
     */
    causes?: Array<InlineResponse200Causes>;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelErrorSeverityEnum {
    Info = 'INFO',
    Warn = 'WARN',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum ModelErrorCategoryEnum {
    Application = 'APPLICATION',
    System = 'SYSTEM',
    Request = 'REQUEST',
    Data = 'DATA'
}

/**
 * Multi Tenant header attributes
 * @export
 * @interface MultitenantHeader
 */
export interface MultitenantHeader {
    /**
     * Business unit identifier and must be 0 for US market.
     * @type {string}
     * @memberof MultitenantHeader
     */
    buId: string;
    /**
     * Market identifier and must be 0 for US market.
     * @type {string}
     * @memberof MultitenantHeader
     */
    martId: string;
}
/**
 * Request Multi Tenant Header Wrapper
 * @export
 * @interface MultitenantHeaderWrapper
 */
export interface MultitenantHeaderWrapper {
    /**
     * 
     * @type {V3FulfillmentInboundPreviewHeaderHeaderAttributes}
     * @memberof MultitenantHeaderWrapper
     */
    headerAttributes: V3FulfillmentInboundPreviewHeaderHeaderAttributes;
}
/**
 * Customer name details
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    completeName?: string;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    lastName?: string;
}
/**
 * Offer Selection details. List of offers - number of offer inside offer selection should be less than or equal to 30.
 * @export
 * @interface OfferSelection
 */
export interface OfferSelection {
    /**
     * Offer details. List of an items/vendor sku.
     * @type {Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers>}
     * @memberof OfferSelection
     */
    offers: Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers>;
}
/**
 * 
 * @export
 * @interface OrderCancelItem
 */
export interface OrderCancelItem {
    /**
     * 
     * @type {string}
     * @memberof OrderCancelItem
     */
    sellerLineId: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsCancelPayloadQty}
     * @memberof OrderCancelItem
     */
    qty: V3FulfillmentOrdersFulfillmentsCancelPayloadQty;
}
/**
 * Shipment dates
 * @export
 * @interface OrderDate
 */
export interface OrderDate {
    /**
     * Actual delivery date of the order
     * @type {string}
     * @memberof OrderDate
     */
    actualDate?: string;
    /**
     * Order dateTypeId
     * @type {string}
     * @memberof OrderDate
     */
    dateTypeId?: string;
    /**
     * Expected delivery date of the order
     * @type {string}
     * @memberof OrderDate
     */
    expectedDate?: string;
}
/**
 * inbound shipment request line items
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * Unique ID identifying product
     * @type {string}
     * @memberof OrderItem
     */
    productId: string;
    /**
     * Supported product types are GTIN
     * @type {string}
     * @memberof OrderItem
     */
    productType: string;
    /**
     * Seller Item ID
     * @type {string}
     * @memberof OrderItem
     */
    sku: string;
    /**
     * Item description
     * @type {string}
     * @memberof OrderItem
     */
    itemDesc: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof OrderItem
     */
    itemQty: number;
    /**
     * Total number of cases
     * @type {number}
     * @memberof OrderItem
     */
    vendorPackQty: number;
    /**
     * Total number of sellable units per case
     * @type {number}
     * @memberof OrderItem
     */
    innerPackQty: number;
    /**
     * expected delivery date for shipment
     * @type {string}
     * @memberof OrderItem
     */
    expectedDeliveryDate: string;
    /**
     * Indicate whether add-on services (e.g. item labeling or poly bagging) are needed
     * @type {Array<string>}
     * @memberof OrderItem
     */
    addOnServices?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    itemNbr?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof OrderItem
     */
    dimensions?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    itemWeightQty?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderItem
     */
    nonSortItem?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    shipNode?: string;
}
/**
 * update shipment qty line items
 * @export
 * @interface OrderItemUpdate
 */
export interface OrderItemUpdate {
    /**
     * Seller Item ID
     * @type {string}
     * @memberof OrderItemUpdate
     */
    sku: string;
    /**
     * updated quantity
     * @type {number}
     * @memberof OrderItemUpdate
     */
    updatedShipmentQty: number;
}
/**
 * Product details within order
 * @export
 * @interface OrderProduct
 */
export interface OrderProduct {
    /**
     * Product name of the order
     * @type {string}
     * @memberof OrderProduct
     */
    productName?: string;
}
/**
 * 
 * @export
 * @interface OriginLocation
 */
export interface OriginLocation {
    /**
     * 
     * @type {string}
     * @memberof OriginLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof OriginLocation
     */
    address: InlineResponse2006OriginLocationAddress;
    /**
     * 
     * @type {string}
     * @memberof OriginLocation
     */
    locationId?: string;
}
/**
 * Headers Section
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * Number of records to be returned
     * @type {number}
     * @memberof PaginationMetadata
     */
    limit?: number;
    /**
     * Number of records you wish to skip before selecting records
     * @type {number}
     * @memberof PaginationMetadata
     */
    offset?: number;
    /**
     * Total Count of records this request yields
     * @type {number}
     * @memberof PaginationMetadata
     */
    totalCount?: number;
}
/**
 * Shipping address details
 * @export
 * @interface PickupPersonDetails
 */
export interface PickupPersonDetails {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomerContact}
     * @memberof PickupPersonDetails
     */
    contact: V3FulfillmentOrdersFulfillmentsPayloadCustomerContact;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress}
     * @memberof PickupPersonDetails
     */
    address?: V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress;
}
/**
 * List of preview responses
 * @export
 * @interface Preview
 */
export interface Preview {
    /**
     * Use \"inbound\" if you are using WFS Inventory Transfer Service (ITS). Use \"selfMirroring\" if you are not using ITS and shipping directly to Walmart fulfillment centers.
     * @type {string}
     * @memberof Preview
     */
    previewType?: string;
    /**
     * Preview
     * @type {Array<InlineResponse2005Preview>}
     * @memberof Preview
     */
    preview?: Array<InlineResponse2005Preview>;
}
/**
 * Preview
 * @export
 * @interface PreviewResponseDTO
 */
export interface PreviewResponseDTO {
    /**
     * Ship Node
     * @type {string}
     * @memberof PreviewResponseDTO
     */
    shipNode?: string;
    /**
     * Flag indicating if the dimensions of the item make it sortable
     * @type {boolean}
     * @memberof PreviewResponseDTO
     */
    isSortable?: boolean;
    /**
     * Flag indicating if the dimensions of the item make it non-sortable
     * @type {boolean}
     * @memberof PreviewResponseDTO
     */
    isNonSortable?: boolean;
    /**
     * Node Type: FC/ICC
     * @type {string}
     * @memberof PreviewResponseDTO
     */
    nodeType?: string;
    /**
     * 
     * @type {InlineResponse2003ShipToAddress}
     * @memberof PreviewResponseDTO
     */
    shipToAddress?: InlineResponse2003ShipToAddress;
    /**
     * Total charge if you are using ITS.
     * @type {number}
     * @memberof PreviewResponseDTO
     */
    totalNetTransferCharge?: number;
    /**
     * Currency in which transfer charge is estimated
     * @type {string}
     * @memberof PreviewResponseDTO
     */
    currencyUnit?: string;
    /**
     * Shipment items
     * @type {Array<InlineResponse2005ShipmentItems>}
     * @memberof PreviewResponseDTO
     */
    shipmentItems?: Array<InlineResponse2005ShipmentItems>;
}
/**
 * Shipment items
 * @export
 * @interface PreviewShipmentItem
 */
export interface PreviewShipmentItem {
    /**
     * Vendor SKU
     * @type {string}
     * @memberof PreviewShipmentItem
     */
    vendorSku?: string;
    /**
     * Product type: GTIN/UPC/EAN
     * @type {string}
     * @memberof PreviewShipmentItem
     */
    productType?: string;
    /**
     * Unique product identifier
     * @type {string}
     * @memberof PreviewShipmentItem
     */
    productId?: string;
    /**
     * Item quantity
     * @type {number}
     * @memberof PreviewShipmentItem
     */
    itemQty?: number;
    /**
     * Total charge if you are using ITS.
     * @type {number}
     * @memberof PreviewShipmentItem
     */
    netTransferCharge?: number;
    /**
     * Currency in which transfer charge is estimated
     * @type {string}
     * @memberof PreviewShipmentItem
     */
    currencyUnit?: string;
}
/**
 * Primary contact of the order
 * @export
 * @interface PrimaryContactDetails
 */
export interface PrimaryContactDetails {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName}
     * @memberof PrimaryContactDetails
     */
    name?: V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName;
}
/**
 * Address details.
 * @export
 * @interface PromiseAddress
 */
export interface PromiseAddress {
    /**
     * City where the address is located in.
     * @type {string}
     * @memberof PromiseAddress
     */
    city?: string;
    /**
     * The address type. For example: \'RESIDENTIAL\'
     * @type {string}
     * @memberof PromiseAddress
     */
    addressType?: string;
    /**
     * ZIP or postal code where the address is located in.
     * @type {string}
     * @memberof PromiseAddress
     */
    postalCode: string;
    /**
     * First line of the address.
     * @type {string}
     * @memberof PromiseAddress
     */
    addressLineOne?: string;
    /**
     * Second line of the address.
     * @type {string}
     * @memberof PromiseAddress
     */
    addressLineTwo?: string;
    /**
     * Country code where the address is located in.
     * @type {string}
     * @memberof PromiseAddress
     */
    countryCode?: string;
    /**
     * State (two letter) code where the address is located in.
     * @type {string}
     * @memberof PromiseAddress
     */
    stateCode: string;
    /**
     * PO box detail.
     * @type {boolean}
     * @memberof PromiseAddress
     */
    isPOBox?: boolean;
}
/**
 * Customer order destination details.
 * @export
 * @interface PromiseDestination
 */
export interface PromiseDestination {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress}
     * @memberof PromiseDestination
     */
    address: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress;
    /**
     * Fulfillment Type of an order. Currently supported type : \'DELIVERY\'
     * @type {string}
     * @memberof PromiseDestination
     */
    fulfillmentType: string;
}
/**
 * Customer order destination details.
 * @export
 * @interface PromiseDestinationResponse
 */
export interface PromiseDestinationResponse {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress}
     * @memberof PromiseDestinationResponse
     */
    address?: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress;
    /**
     * Fulfillment Type of an order. Currently supported type : \'DELIVERY\'
     * @type {string}
     * @memberof PromiseDestinationResponse
     */
    fulfillmentType?: string;
    /**
     * Destination id detail. For example : \'fulfillment type for DELIVERY has destinationId 0
     * @type {string}
     * @memberof PromiseDestinationResponse
     */
    destinationId?: string;
}
/**
 * Offer details. List of an items/vendor sku.
 * @export
 * @interface PromiseOffer
 */
export interface PromiseOffer {
    /**
     * The identifier of the item in seller system (vendor sku).
     * @type {string}
     * @memberof PromiseOffer
     */
    sku: string;
    /**
     * The identifier (UUID) for each line assigned by seller systems.
     * @type {string}
     * @memberof PromiseOffer
     */
    lineId: string;
    /**
     * Sales unit type. Currently supported type : \'EACH\'
     * @type {string}
     * @memberof PromiseOffer
     */
    salesUnit: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity}
     * @memberof PromiseOffer
     */
    requestedQuantity: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity;
}
/**
 * Request payload.
 * @export
 * @interface PromiseOrderRequestPayload
 */
export interface PromiseOrderRequestPayload {
    /**
     * The identifier to identify the request.
     * @type {string}
     * @memberof PromiseOrderRequestPayload
     */
    requestId: string;
    /**
     * Customer order destination details.
     * @type {Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadDestinations>}
     * @memberof PromiseOrderRequestPayload
     */
    destinations: Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadDestinations>;
    /**
     * Offer Selection details. List of offers - number of offer inside offer selection should be less than or equal to 30.
     * @type {Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOfferSelections>}
     * @memberof PromiseOrderRequestPayload
     */
    offerSelections: Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOfferSelections>;
}
/**
 * 
 * @export
 * @interface PromiseOrderRequestWrapper
 */
export interface PromiseOrderRequestWrapper {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof PromiseOrderRequestWrapper
     */
    header: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload}
     * @memberof PromiseOrderRequestWrapper
     */
    payload?: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload;
}
/**
 * Response payload.
 * @export
 * @interface PromiseOrderResponsePayload
 */
export interface PromiseOrderResponsePayload {
    /**
     * Offer details indicating available quantity vs required quantify for offer
     * @type {Array<InlineResponse2002PayloadOffers>}
     * @memberof PromiseOrderResponsePayload
     */
    offers?: Array<InlineResponse2002PayloadOffers>;
    /**
     * Customer order destination details.
     * @type {Array<InlineResponse2002PayloadDestinations>}
     * @memberof PromiseOrderResponsePayload
     */
    destinations?: Array<InlineResponse2002PayloadDestinations>;
    /**
     * The identifier to identify the response.
     * @type {string}
     * @memberof PromiseOrderResponsePayload
     */
    prepurchaseHandle?: string;
    /**
     * Fulfillment plans details.
     * @type {Array<InlineResponse2002PayloadFulfillmentPlans>}
     * @memberof PromiseOrderResponsePayload
     */
    fulfillmentPlans?: Array<InlineResponse2002PayloadFulfillmentPlans>;
}
/**
 * 
 * @export
 * @interface PromiseOrderResponseWrapper
 */
export interface PromiseOrderResponseWrapper {
    /**
     * Response status.
     * @type {string}
     * @memberof PromiseOrderResponseWrapper
     */
    status?: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeader}
     * @memberof PromiseOrderResponseWrapper
     */
    header?: V3FulfillmentOrdersFulfillmentsHeader;
    /**
     * 
     * @type {InlineResponse2002Payload}
     * @memberof PromiseOrderResponseWrapper
     */
    payload?: InlineResponse2002Payload;
}
/**
 * Offer details indicating available quantity vs required quantify for offer
 * @export
 * @interface PromiseResponseOffer
 */
export interface PromiseResponseOffer {
    /**
     * 
     * @type {InlineResponse2002PayloadAvailableQuantity}
     * @memberof PromiseResponseOffer
     */
    availableQuantity?: InlineResponse2002PayloadAvailableQuantity;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity}
     * @memberof PromiseResponseOffer
     */
    requestedQuantity?: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity;
    /**
     * The identifier (UUID) for each line assigned by seller systems.
     * @type {string}
     * @memberof PromiseResponseOffer
     */
    lineId?: string;
    /**
     * Sales unit type. Currently supported type : \'EACH\'
     * @type {string}
     * @memberof PromiseResponseOffer
     */
    salesUnit?: string;
    /**
     * The identifier of the item in seller system (vendor sku).
     * @type {string}
     * @memberof PromiseResponseOffer
     */
    sku?: string;
}
/**
 * Quantity of the order
 * @export
 * @interface Quantity
 */
export interface Quantity {
    /**
     * The unit of measure in the item\'s weight (e.g., \'EACH\' or \'EA\')
     * @type {string}
     * @memberof Quantity
     */
    unitOfMeasure: string;
    /**
     * The quantity of the unit of measure for the item
     * @type {number}
     * @memberof Quantity
     */
    measurementValue: number;
}
/**
 * 
 * @export
 * @interface QuantityType
 */
export interface QuantityType {
    /**
     * 
     * @type {string}
     * @memberof QuantityType
     */
    unitOfMeasure: string;
    /**
     * 
     * @type {number}
     * @memberof QuantityType
     */
    measurementValue: number;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | sku | An arbitrary alphanumeric unique ID, seller-specified, identifying each item | string | gtin | Specifies a Global Trade Item Number (GTIN) search. GTIN must be 14 digits. | string
     * @type {string}
     * @memberof Query
     */
    field?: QueryFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof Query
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryFieldEnum {
    Sku = 'sku',
    Gtin = 'gtin'
}

/**
 * 
 * @export
 * @interface QuoteResponseV2Wrapper
 */
export interface QuoteResponseV2Wrapper {
    /**
     * 
     * @type {string}
     * @memberof QuoteResponseV2Wrapper
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteResponseV2Wrapper
     */
    shipmentNumber?: string;
    /**
     * 
     * @type {Array<InlineResponse2006RateQuote>}
     * @memberof QuoteResponseV2Wrapper
     */
    rateQuotes?: Array<InlineResponse2006RateQuote>;
}
/**
 * 
 * @export
 * @interface RateQuoteV2
 */
export interface RateQuoteV2 {
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    quoteId?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    estimatedDeliveryDateTime?: string;
    /**
     * 
     * @type {InlineResponse2006Carrier}
     * @memberof RateQuoteV2
     */
    carrier?: InlineResponse2006Carrier;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    discountCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    netCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    surchargeType?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    surchargeValue?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    totalBillingWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    transitDays?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    effectiveDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    expiryDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    sellerFreightClassCode?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    freightCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    fuelCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    totalWeight?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    totalVolume?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    equipmentTypeCode?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    serviceCode?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    numberOfPallets?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    nominalCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    assessorialCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    serviceCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    minimumCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    declaredValue?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    mixedSKUs?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    singleSKUs?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    freightReadyDate?: string;
}
/**
 * Requested Quantity Information of an item.
 * @export
 * @interface RequestedQuantity
 */
export interface RequestedQuantity {
    /**
     * Quantity of each item.
     * @type {number}
     * @memberof RequestedQuantity
     */
    measurementValue: number;
    /**
     * Unit of quantity. Currently supported type : \'EA\'
     * @type {string}
     * @memberof RequestedQuantity
     */
    unitOfMeasure: string;
}
/**
 * return address of seller
 * @export
 * @interface ReturnAddress
 */
export interface ReturnAddress {
    /**
     * Address details
     * @type {string}
     * @memberof ReturnAddress
     */
    addressLine1: string;
    /**
     * Address details continuation
     * @type {string}
     * @memberof ReturnAddress
     */
    addressLine2?: string;
    /**
     * City name
     * @type {string}
     * @memberof ReturnAddress
     */
    city: string;
    /**
     * State Code
     * @type {string}
     * @memberof ReturnAddress
     */
    stateCode: string;
    /**
     * Country code
     * @type {string}
     * @memberof ReturnAddress
     */
    countryCode: string;
    /**
     * Zip code
     * @type {string}
     * @memberof ReturnAddress
     */
    postalCode: string;
}
/**
 * 
 * @export
 * @interface ReturnLocation
 */
export interface ReturnLocation {
    /**
     * 
     * @type {string}
     * @memberof ReturnLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof ReturnLocation
     */
    address: InlineResponse2006OriginLocationAddress;
}
/**
 * 
 * @export
 * @interface ServiceHeader
 */
export interface ServiceHeader {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceHeader
     */
    headerAttributes?: { [key: string]: object; };
}
/**
 * Fulfillment service level agreement details.
 * @export
 * @interface ServiceLevelAgreement
 */
export interface ServiceLevelAgreement {
    /**
     * Service level agreement tier details.For example : \'TWO_DAY\'
     * @type {string}
     * @memberof ServiceLevelAgreement
     */
    tier?: string;
    /**
     * Ship method details. For example : \'Rush, Expedited, Value and Standard\'
     * @type {string}
     * @memberof ServiceLevelAgreement
     */
    speed?: string;
}
/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceResponse
     */
    status: ServiceResponseStatusEnum;
    /**
     * 
     * @type {InlineResponse200Header}
     * @memberof ServiceResponse
     */
    header?: InlineResponse200Header;
    /**
     * 
     * @type {Array<InlineResponse200Errors>}
     * @memberof ServiceResponse
     */
    errors?: Array<InlineResponse200Errors>;
    /**
     * 
     * @type {object}
     * @memberof ServiceResponse
     */
    payload?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ServiceResponseStatusEnum {
    Ok = 'OK',
    Created = 'CREATED',
    Accepted = 'ACCEPTED',
    NoContent = 'NO_CONTENT',
    Partial = 'PARTIAL',
    MovedPermanent = 'MOVED_PERMANENT',
    Found = 'FOUND',
    SeeOther = 'SEE_OTHER',
    NotModified = 'NOT_MODIFIED',
    TemporaryRedirect = 'TEMPORARY_REDIRECT',
    BadRequest = 'BAD_REQUEST',
    Unauthorized = 'UNAUTHORIZED',
    Forbidden = 'FORBIDDEN',
    NotFound = 'NOT_FOUND',
    MethodNotAllowed = 'METHOD_NOT_ALLOWED',
    NotAcceptable = 'NOT_ACCEPTABLE',
    RequestTimeout = 'REQUEST_TIMEOUT',
    Conflict = 'CONFLICT',
    RequestEntityTooLarge = 'REQUEST_ENTITY_TOO_LARGE',
    UnsupportedMediaType = 'UNSUPPORTED_MEDIA_TYPE',
    UnprocessableEntity = 'UNPROCESSABLE_ENTITY',
    TooManyRequests = 'TOO_MANY_REQUESTS',
    Fail = 'FAIL',
    BadGateway = 'BAD_GATEWAY',
    ServiceUnavailable = 'SERVICE_UNAVAILABLE',
    GatewayTimeout = 'GATEWAY_TIMEOUT'
}

/**
 * The address to which sellers need to inbound items
 * @export
 * @interface ShipToAddress
 */
export interface ShipToAddress {
    /**
     * Facility name
     * @type {string}
     * @memberof ShipToAddress
     */
    fcName?: string;
    /**
     * Address details 
     * @type {string}
     * @memberof ShipToAddress
     */
    addressLine1?: string;
    /**
     * Address details continuation
     * @type {string}
     * @memberof ShipToAddress
     */
    addressLine2?: string;
    /**
     * City name
     * @type {string}
     * @memberof ShipToAddress
     */
    city?: string;
    /**
     * State code
     * @type {string}
     * @memberof ShipToAddress
     */
    stateCode?: string;
    /**
     * Country code
     * @type {string}
     * @memberof ShipToAddress
     */
    countryCode?: string;
    /**
     * Zip code
     * @type {string}
     * @memberof ShipToAddress
     */
    postalCode?: string;
}
/**
 * createDate of the order
 * @export
 * @interface Shipment
 */
export interface Shipment {
    /**
     * Shipment status
     * @type {string}
     * @memberof Shipment
     */
    status?: string;
    /**
     * Shipment status description
     * @type {string}
     * @memberof Shipment
     */
    statusDescription?: string;
    /**
     * Shipment purchase Order Id
     * @type {string}
     * @memberof Shipment
     */
    purchaseOrderId?: string;
    /**
     * Shipment scac
     * @type {string}
     * @memberof Shipment
     */
    scac?: string;
    /**
     * Shipment tracking number
     * @type {string}
     * @memberof Shipment
     */
    trackingNo?: string;
    /**
     * Shipment tracking URL
     * @type {string}
     * @memberof Shipment
     */
    externalTrackingURL?: string;
    /**
     * Shipment number
     * @type {string}
     * @memberof Shipment
     */
    shipmentNo?: string;
    /**
     * Actual shipment date
     * @type {string}
     * @memberof Shipment
     */
    actualShipmentDate?: string;
    /**
     * Shipment packageASN number
     * @type {string}
     * @memberof Shipment
     */
    packageASN?: string;
    /**
     * Shipment carrier description
     * @type {string}
     * @memberof Shipment
     */
    carrierDescription?: string;
    /**
     * Shipment carrier service code
     * @type {string}
     * @memberof Shipment
     */
    carrierServiceCode?: string;
    /**
     * Shipment package Id
     * @type {string}
     * @memberof Shipment
     */
    packageId?: string;
    /**
     * Shipment lastModified date
     * @type {string}
     * @memberof Shipment
     */
    lastModified?: string;
    /**
     * Shipment line details
     * @type {Array<InlineResponse2009ShipmentLines>}
     * @memberof Shipment
     */
    shipmentLines?: Array<InlineResponse2009ShipmentLines>;
    /**
     * Shipment dates
     * @type {Array<InlineResponse2009ShipmentDates>}
     * @memberof Shipment
     */
    shipmentDates?: Array<InlineResponse2009ShipmentDates>;
}
/**
 * The items which needs to be send in the shipment
 * @export
 * @interface ShipmentItem
 */
export interface ShipmentItem {
    /**
     * Seller Item ID
     * @type {string}
     * @memberof ShipmentItem
     */
    vendorSku?: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof ShipmentItem
     */
    itemQty?: number;
}
/**
 * response payload
 * @export
 * @interface ShipmentItemDetails
 */
export interface ShipmentItemDetails {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    inboundOrderId?: string;
    /**
     * Unique ID identifying each shipment
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    shipmentId?: string;
    /**
     * Item barcode
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    gtin?: string;
    /**
     * Seller Item ID
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    sku?: string;
    /**
     * Item description
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    itemDesc?: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    itemQty?: number;
    /**
     * Total number of cases
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    vendorPackQty?: number;
    /**
     * Total number of sellable units per case
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    innerPackQty?: number;
    /**
     * Qty received in FC
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    receivedQty?: number;
    /**
     * Qty damaged while receiving in FC
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    damagedQty?: number;
    /**
     * Fill rate for this shipment item
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    fillRate?: number;
    /**
     * expected delivery date provided by seller
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    expectedDeliveryDate?: string;
    /**
     * update expected delivery date based on network capacity
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    updatedExpectedDeliveryDate?: string;
    /**
     * FC name
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    shipNodeName?: string;
}
/**
 * Shipment line details
 * @export
 * @interface ShipmentLine
 */
export interface ShipmentLine {
    /**
     * Shipment line number
     * @type {string}
     * @memberof ShipmentLine
     */
    shipmentLineNo?: string;
    /**
     * Shipment fulfiller LineId
     * @type {string}
     * @memberof ShipmentLine
     */
    fulfillerLineId?: string;
    /**
     * 
     * @type {InlineResponse2009Quantity}
     * @memberof ShipmentLine
     */
    quantity?: InlineResponse2009Quantity;
}
/**
 * 
 * @export
 * @interface ShipmentPackage
 */
export interface ShipmentPackage {
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    packageSequenceNumber: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    weight: number;
    /**
     * 
     * @type {string}
     * @memberof ShipmentPackage
     */
    weightUOM: string;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    length: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    width: number;
    /**
     * 
     * @type {string}
     * @memberof ShipmentPackage
     */
    lengthUOM: string;
    /**
     * 
     * @type {InlineResponse2006LabelInformation}
     * @memberof ShipmentPackage
     */
    labelInformation?: InlineResponse2006LabelInformation;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    billingWeight?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    netCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    nominalCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    assessorialCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    serviceCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof ShipmentPackage
     */
    packageType?: string;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    noOfPackages?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShipmentPackage
     */
    stackable?: boolean;
}
/**
 * response payload
 * @export
 * @interface ShipmentPlanDetails
 */
export interface ShipmentPlanDetails {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    inboundOrderId?: string;
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    shipmentId?: string;
    /**
     * 
     * @type {InlineResponse2003ShipToAddress}
     * @memberof ShipmentPlanDetails
     */
    shipToAddress?: InlineResponse2003ShipToAddress;
    /**
     * 
     * @type {InlineResponse2003ReturnAddress}
     * @memberof ShipmentPlanDetails
     */
    returnAddress?: InlineResponse2003ReturnAddress;
    /**
     * Current status of the shipment
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    status?: string;
    /**
     * creation date for shipment
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    createdDate?: string;
    /**
     * Total number of units in the shipment
     * @type {number}
     * @memberof ShipmentPlanDetails
     */
    shipmentUnits?: number;
    /**
     * Total number of units recived in FC for the shipment
     * @type {number}
     * @memberof ShipmentPlanDetails
     */
    receivedUnits?: number;
    /**
     * expected delivery date provided by seller
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    expectedDeliveryDate?: string;
    /**
     * update expected delivery date based on network capacity
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    updatedExpectedDeliveryDate?: string;
    /**
     * Actual delivery date of the shipment at FC
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    actualDeliveryDate?: string;
    /**
     * Tracking info for the shipment
     * @type {Array<string>}
     * @memberof ShipmentPlanDetails
     */
    trackingNo?: Array<string>;
    /**
     * Carrier of the shipment
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    carrierName?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | createdAt | when the item is last submitted/updated by Seller | string | updatedAt | when the item is last updated by Seller/Walmart | string |
     * @type {string}
     * @memberof Sort
     */
    field?: SortFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof Sort
     */
    order?: SortOrderEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SortFieldEnum {
    CreatedAt = 'createdAt',
    UpdatedAt = 'updatedAt'
}
/**
    * @export
    * @enum {string}
    */
export enum SortOrderEnum {
    Asc = 'ASC',
    Desc = 'DESC'
}

/**
 * Tax details
 * @export
 * @interface TaxDetails
 */
export interface TaxDetails {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit}
     * @memberof TaxDetails
     */
    taxPerLine?: V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit;
}
/**
 * 
 * @export
 * @interface TrackingInfoWrapper
 */
export interface TrackingInfoWrapper {
    /**
     * 
     * @type {string}
     * @memberof TrackingInfoWrapper
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof TrackingInfoWrapper
     */
    carrierName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingInfoWrapper
     */
    trackingInfo?: Array<string>;
}
/**
 * 
 * @export
 * @interface V3FulfillmentCarrierRateQuotesCustomer
 */
export interface V3FulfillmentCarrierRateQuotesCustomer {
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentCarrierRateQuotesCustomer
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentCarrierRateQuotesCustomer
     */
    customerName: string;
}
/**
 * 
 * @export
 * @interface V3FulfillmentCarrierRateQuotesLoadTypes
 */
export interface V3FulfillmentCarrierRateQuotesLoadTypes {
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentCarrierRateQuotesLoadTypes
     */
    count: string;
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentCarrierRateQuotesLoadTypes
     */
    loadType: string;
}
/**
 * Request Multi Tenant Header Wrapper
 * @export
 * @interface V3FulfillmentInboundPreviewHeader
 */
export interface V3FulfillmentInboundPreviewHeader {
    /**
     * 
     * @type {V3FulfillmentInboundPreviewHeaderHeaderAttributes}
     * @memberof V3FulfillmentInboundPreviewHeader
     */
    headerAttributes: V3FulfillmentInboundPreviewHeaderHeaderAttributes;
}
/**
 * Multi Tenant header attributes
 * @export
 * @interface V3FulfillmentInboundPreviewHeaderHeaderAttributes
 */
export interface V3FulfillmentInboundPreviewHeaderHeaderAttributes {
    /**
     * Business unit identifier and must be 0 for US market.
     * @type {string}
     * @memberof V3FulfillmentInboundPreviewHeaderHeaderAttributes
     */
    buId: string;
    /**
     * Market identifier and must be 0 for US market.
     * @type {string}
     * @memberof V3FulfillmentInboundPreviewHeaderHeaderAttributes
     */
    martId: string;
}
/**
 * Request Payload
 * @export
 * @interface V3FulfillmentInboundPreviewPayload
 */
export interface V3FulfillmentInboundPreviewPayload {
    /**
     * Unique identifier used for shipments
     * @type {string}
     * @memberof V3FulfillmentInboundPreviewPayload
     */
    inboundOrderId: string;
    /**
     * 
     * @type {InlineResponse2003ReturnAddress}
     * @memberof V3FulfillmentInboundPreviewPayload
     */
    returnAddress: InlineResponse2003ReturnAddress;
    /**
     * List of Order Items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof V3FulfillmentInboundPreviewPayload
     */
    orderItems: Array<V3FulfillmentInboundShipmentsOrderItems>;
}
/**
 * Requested inbound services such as ITS
 * @export
 * @interface V3FulfillmentInboundShipmentsInboundServices
 */
export interface V3FulfillmentInboundShipmentsInboundServices {
    /**
     * ITS Flag
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsInboundServices
     */
    inventoryTransferService?: string;
}
/**
 * inbound shipment request line items
 * @export
 * @interface V3FulfillmentInboundShipmentsOrderItems
 */
export interface V3FulfillmentInboundShipmentsOrderItems {
    /**
     * Unique ID identifying product
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    productId: string;
    /**
     * Supported product types are GTIN
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    productType: string;
    /**
     * Seller Item ID
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    sku: string;
    /**
     * Item description
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    itemDesc: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    itemQty: number;
    /**
     * Total number of cases
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    vendorPackQty: number;
    /**
     * Total number of sellable units per case
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    innerPackQty: number;
    /**
     * expected delivery date for shipment
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    expectedDeliveryDate: string;
    /**
     * Indicate whether add-on services (e.g. item labeling or poly bagging) are needed
     * @type {Array<string>}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    addOnServices?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    itemNbr?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    dimensions?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    itemWeightQty?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    nonSortItem?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    shipNode?: string;
}
/**
 * request payload
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsCancelPayload
 */
export interface V3FulfillmentOrdersFulfillmentsCancelPayload {
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsCancelPayload
     */
    sellerOrderId: string;
    /**
     * 
     * @type {Array<V3FulfillmentOrdersFulfillmentsCancelPayloadOrderItems>}
     * @memberof V3FulfillmentOrdersFulfillmentsCancelPayload
     */
    orderItems: Array<V3FulfillmentOrdersFulfillmentsCancelPayloadOrderItems>;
}
/**
 * 
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsCancelPayloadOrderItems
 */
export interface V3FulfillmentOrdersFulfillmentsCancelPayloadOrderItems {
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsCancelPayloadOrderItems
     */
    sellerLineId: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsCancelPayloadQty}
     * @memberof V3FulfillmentOrdersFulfillmentsCancelPayloadOrderItems
     */
    qty: V3FulfillmentOrdersFulfillmentsCancelPayloadQty;
}
/**
 * 
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsCancelPayloadQty
 */
export interface V3FulfillmentOrdersFulfillmentsCancelPayloadQty {
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsCancelPayloadQty
     */
    unitOfMeasure: string;
    /**
     * 
     * @type {number}
     * @memberof V3FulfillmentOrdersFulfillmentsCancelPayloadQty
     */
    measurementValue: number;
}
/**
 * Request payload.
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload
 */
export interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload {
    /**
     * The identifier to identify the request.
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload
     */
    requestId: string;
    /**
     * Customer order destination details.
     * @type {Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadDestinations>}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload
     */
    destinations: Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadDestinations>;
    /**
     * Offer Selection details. List of offers - number of offer inside offer selection should be less than or equal to 30.
     * @type {Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOfferSelections>}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayload
     */
    offerSelections: Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOfferSelections>;
}
/**
 * Address details.
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
 */
export interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress {
    /**
     * City where the address is located in.
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
     */
    city?: string;
    /**
     * The address type. For example: \'RESIDENTIAL\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
     */
    addressType?: string;
    /**
     * ZIP or postal code where the address is located in.
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
     */
    postalCode: string;
    /**
     * First line of the address.
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
     */
    addressLineOne?: string;
    /**
     * Second line of the address.
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
     */
    addressLineTwo?: string;
    /**
     * Country code where the address is located in.
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
     */
    countryCode?: string;
    /**
     * State (two letter) code where the address is located in.
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
     */
    stateCode: string;
    /**
     * PO box detail.
     * @type {boolean}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress
     */
    isPOBox?: boolean;
}
/**
 * Customer order destination details.
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadDestinations
 */
export interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadDestinations {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadDestinations
     */
    address: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadAddress;
    /**
     * Fulfillment Type of an order. Currently supported type : \'DELIVERY\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadDestinations
     */
    fulfillmentType: string;
}
/**
 * Offer Selection details. List of offers - number of offer inside offer selection should be less than or equal to 30.
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOfferSelections
 */
export interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOfferSelections {
    /**
     * Offer details. List of an items/vendor sku.
     * @type {Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers>}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOfferSelections
     */
    offers: Array<V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers>;
}
/**
 * Offer details. List of an items/vendor sku.
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers
 */
export interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers {
    /**
     * The identifier of the item in seller system (vendor sku).
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers
     */
    sku: string;
    /**
     * The identifier (UUID) for each line assigned by seller systems.
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers
     */
    lineId: string;
    /**
     * Sales unit type. Currently supported type : \'EACH\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers
     */
    salesUnit: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadOffers
     */
    requestedQuantity: V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity;
}
/**
 * Requested Quantity Information of an item.
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity
 */
export interface V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity {
    /**
     * Quantity of each item.
     * @type {number}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity
     */
    measurementValue: number;
    /**
     * Unit of quantity. Currently supported type : \'EA\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsFetchOrderPromiseOptionsPayloadRequestedQuantity
     */
    unitOfMeasure: string;
}
/**
 * header to support build and martId
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsHeader
 */
export interface V3FulfillmentOrdersFulfillmentsHeader {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsHeaderHeaderAttributes}
     * @memberof V3FulfillmentOrdersFulfillmentsHeader
     */
    headerAttributes?: V3FulfillmentOrdersFulfillmentsHeaderHeaderAttributes;
}
/**
 * Header attributes
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsHeaderHeaderAttributes
 */
export interface V3FulfillmentOrdersFulfillmentsHeaderHeaderAttributes {
    /**
     * martId of the seller. Currently supported: \'202\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsHeaderHeaderAttributes
     */
    martId?: string;
    /**
     * buId of the seller. Currently supported: \'0\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsHeaderHeaderAttributes
     */
    buId?: string;
}
/**
 * request payload
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayload
 */
export interface V3FulfillmentOrdersFulfillmentsPayload {
    /**
     * Unique ID identifying channels from where the orders have been generated. This ID is generated by Walmart at the time of on-boarding onto multichannel program and this cannot be a random number
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayload
     */
    orderChannelId: string;
    /**
     * Unique ID identifying customer order request. Preferred to attach seller short name as prefix. For example: \'seller001\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayload
     */
    sellerOrderId: string;
    /**
     * Order placed time at respective channels. Format: \'2022-03-25T21:58:30.143Z\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayload
     */
    orderPlacedTime: string;
    /**
     * Flag to identify if confirmation is needed. Currently supported: \'false\'
     * @type {boolean}
     * @memberof V3FulfillmentOrdersFulfillmentsPayload
     */
    needsConfirmation?: boolean;
    /**
     * Flag to identify if partial fulfilment is allowed. Currently supported: \'false\'
     * @type {boolean}
     * @memberof V3FulfillmentOrdersFulfillmentsPayload
     */
    partialFulfillments?: boolean;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomer}
     * @memberof V3FulfillmentOrdersFulfillmentsPayload
     */
    customer: V3FulfillmentOrdersFulfillmentsPayloadCustomer;
    /**
     * Order items details
     * @type {Array<V3FulfillmentOrdersFulfillmentsPayloadOrderItems>}
     * @memberof V3FulfillmentOrdersFulfillmentsPayload
     */
    orderItems: Array<V3FulfillmentOrdersFulfillmentsPayloadOrderItems>;
}
/**
 * Item charge details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadChargeDetails
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadChargeDetails {
    /**
     * Charge category, for example: \'PRODUCT\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadChargeDetails
     */
    chargeCategory: string;
    /**
     * Name of the charge, for example: \'Sale Price\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadChargeDetails
     */
    chargeName: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadChargeDetails
     */
    chargePerUnit: V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadTaxDetails}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadChargeDetails
     */
    taxDetails?: V3FulfillmentOrdersFulfillmentsPayloadTaxDetails;
}
/**
 * Currency type details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit {
    /**
     * Currency amount, preferred value: 0
     * @type {number}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit
     */
    currencyAmount: number;
    /**
     * Currency unit, for example: \'USD\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit
     */
    unit: V3FulfillmentOrdersFulfillmentsPayloadChargePerUnitUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum V3FulfillmentOrdersFulfillmentsPayloadChargePerUnitUnitEnum {
    Aed = 'AED',
    Afn = 'AFN',
    All = 'ALL',
    Amd = 'AMD',
    Ang = 'ANG',
    Aoa = 'AOA',
    Ars = 'ARS',
    Aud = 'AUD',
    Awg = 'AWG',
    Azn = 'AZN',
    Bam = 'BAM',
    Bbd = 'BBD',
    Bdt = 'BDT',
    Bgn = 'BGN',
    Bhd = 'BHD',
    Bif = 'BIF',
    Bmd = 'BMD',
    Bnd = 'BND',
    Bob = 'BOB',
    Brl = 'BRL',
    Bsd = 'BSD',
    Btn = 'BTN',
    Bwp = 'BWP',
    Byr = 'BYR',
    Bzd = 'BZD',
    Cad = 'CAD',
    Cdf = 'CDF',
    Chf = 'CHF',
    Clp = 'CLP',
    Cny = 'CNY',
    Cop = 'COP',
    Crc = 'CRC',
    Cup = 'CUP',
    Cve = 'CVE',
    Czk = 'CZK',
    Djf = 'DJF',
    Dkk = 'DKK',
    Dop = 'DOP',
    Dzd = 'DZD',
    Egp = 'EGP',
    Ern = 'ERN',
    Etb = 'ETB',
    Eur = 'EUR',
    Fjd = 'FJD',
    Fkp = 'FKP',
    Gbp = 'GBP',
    Gel = 'GEL',
    Ghs = 'GHS',
    Gip = 'GIP',
    Gmd = 'GMD',
    Gnf = 'GNF',
    Gtq = 'GTQ',
    Gyd = 'GYD',
    Hkd = 'HKD',
    Hnl = 'HNL',
    Hrk = 'HRK',
    Htg = 'HTG',
    Huf = 'HUF',
    Idr = 'IDR',
    Ils = 'ILS',
    Inr = 'INR',
    Iqd = 'IQD',
    Irr = 'IRR',
    Isk = 'ISK',
    Jmd = 'JMD',
    Jod = 'JOD',
    Jpy = 'JPY',
    Kes = 'KES',
    Kgs = 'KGS',
    Khr = 'KHR',
    Kmf = 'KMF',
    Kpw = 'KPW',
    Krw = 'KRW',
    Kwd = 'KWD',
    Kyd = 'KYD',
    Kzt = 'KZT',
    Lak = 'LAK',
    Lbp = 'LBP',
    Lkr = 'LKR',
    Lrd = 'LRD',
    Lsl = 'LSL',
    Ltl = 'LTL',
    Lvl = 'LVL',
    Lyd = 'LYD',
    Mad = 'MAD',
    Mdl = 'MDL',
    Mga = 'MGA',
    Mkd = 'MKD',
    Mmk = 'MMK',
    Mnt = 'MNT',
    Mop = 'MOP',
    Mro = 'MRO',
    Mur = 'MUR',
    Mvr = 'MVR',
    Mwk = 'MWK',
    Mxn = 'MXN',
    Myr = 'MYR',
    Mzn = 'MZN',
    Nad = 'NAD',
    Ngn = 'NGN',
    Nio = 'NIO',
    Nok = 'NOK',
    Npr = 'NPR',
    Nzd = 'NZD',
    Omr = 'OMR',
    Pab = 'PAB',
    Pen = 'PEN',
    Pgk = 'PGK',
    Php = 'PHP',
    Pkr = 'PKR',
    Pln = 'PLN',
    Pyg = 'PYG',
    Qar = 'QAR',
    Ron = 'RON',
    Rsd = 'RSD',
    Rub = 'RUB',
    Rur = 'RUR',
    Rwf = 'RWF',
    Sar = 'SAR',
    Sbd = 'SBD',
    Scr = 'SCR',
    Sdg = 'SDG',
    Sek = 'SEK',
    Sgd = 'SGD',
    Shp = 'SHP',
    Sll = 'SLL',
    Sos = 'SOS',
    Srd = 'SRD',
    Std = 'STD',
    Syp = 'SYP',
    Szl = 'SZL',
    Thb = 'THB',
    Tjs = 'TJS',
    Tmt = 'TMT',
    Tnd = 'TND',
    Top = 'TOP',
    Try = 'TRY',
    Ttd = 'TTD',
    Twd = 'TWD',
    Tzs = 'TZS',
    Uah = 'UAH',
    Ugx = 'UGX',
    Usd = 'USD',
    Uyu = 'UYU',
    Uzs = 'UZS',
    Vef = 'VEF',
    Vnd = 'VND',
    Vuv = 'VUV',
    Wst = 'WST',
    Xaf = 'XAF',
    Xag = 'XAG',
    Xau = 'XAU',
    Xba = 'XBA',
    Xbb = 'XBB',
    Xbc = 'XBC',
    Xbd = 'XBD',
    Xcd = 'XCD',
    Xdr = 'XDR',
    Xfu = 'XFU',
    Xof = 'XOF',
    Xpd = 'XPD',
    Xpf = 'XPF',
    Xpt = 'XPT',
    Xts = 'XTS',
    Xxx = 'XXX',
    Yer = 'YER',
    Zar = 'ZAR',
    Zmk = 'ZMK',
    Zwl = 'ZWL'
}

/**
 * Customer details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadCustomer
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadCustomer {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomerContact}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadCustomer
     */
    contact: V3FulfillmentOrdersFulfillmentsPayloadCustomerContact;
}
/**
 * Customer contact details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadCustomerContact
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadCustomerContact {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadCustomerContact
     */
    name: V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName;
    /**
     * Customer phone number
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadCustomerContact
     */
    phone: string;
    /**
     * Customer email address
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadCustomerContact
     */
    email: string;
}
/**
 * Name of the Customer
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName {
    /**
     * Customer first name
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName
     */
    firstName: string;
    /**
     * Customer last name
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadCustomerContactName
     */
    lastName: string;
}
/**
 * Details of an item
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadItemDetail
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadItemDetail {
    /**
     * The identifier of the item in seller system (vendor sku)
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadItemDetail
     */
    sku: string;
    /**
     * Description of the item
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadItemDetail
     */
    description?: string;
}
/**
 * Order items details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadOrderItems
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadOrderItems {
    /**
     * Fulfillment Type of an order. Currently supported type: \'DELIVERY\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadOrderItems
     */
    fulfillmentType?: string;
    /**
     * Unique Id for each line item, preferred sequence 1,2,3...
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadOrderItems
     */
    sellerLineId: string;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadItemDetail}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadOrderItems
     */
    itemDetail: V3FulfillmentOrdersFulfillmentsPayloadItemDetail;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadQty}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadOrderItems
     */
    qty: V3FulfillmentOrdersFulfillmentsPayloadQty;
    /**
     * Shipping method of an order. Currently supported type: \'EXPEDITED\', \'STANDARD\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadOrderItems
     */
    shippingMethod?: V3FulfillmentOrdersFulfillmentsPayloadOrderItemsShippingMethodEnum;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadShippingTo}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadOrderItems
     */
    shippingTo: V3FulfillmentOrdersFulfillmentsPayloadShippingTo;
    /**
     * Item charge details
     * @type {Array<V3FulfillmentOrdersFulfillmentsPayloadChargeDetails>}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadOrderItems
     */
    chargeDetails: Array<V3FulfillmentOrdersFulfillmentsPayloadChargeDetails>;
}

/**
    * @export
    * @enum {string}
    */
export enum V3FulfillmentOrdersFulfillmentsPayloadOrderItemsShippingMethodEnum {
    Expedited = 'EXPEDITED',
    Standard = 'STANDARD',
    Rush = 'RUSH'
}

/**
 * Item quantity details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadQty
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadQty {
    /**
     * Sales unit measure. Currently supported type : \'EACH\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadQty
     */
    unitOfMeasure: string;
    /**
     * Requested Quantity Information of an item
     * @type {number}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadQty
     */
    measurementValue: number;
}
/**
 * Shipping address details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadShippingTo
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadShippingTo {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadCustomerContact}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingTo
     */
    contact: V3FulfillmentOrdersFulfillmentsPayloadCustomerContact;
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingTo
     */
    address?: V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress;
}
/**
 * Customer address details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress {
    /**
     * First line of the address
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress
     */
    line1: string;
    /**
     * Second line of the address
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress
     */
    line2?: string;
    /**
     * City where the address is located in
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress
     */
    city: string;
    /**
     * State (two letter) code where the address is located in, for example: \'MI\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress
     */
    state: string;
    /**
     * Country code where the address is located in, for example: \'USA\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress
     */
    country: string;
    /**
     * ZIP or postal code where the address is located in, for example: \'48083\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress
     */
    zip: string;
    /**
     * The address type. Currently supported: \'RESIDENTIAL\'
     * @type {string}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadShippingToAddress
     */
    addressType?: string;
}
/**
 * Tax details
 * @export
 * @interface V3FulfillmentOrdersFulfillmentsPayloadTaxDetails
 */
export interface V3FulfillmentOrdersFulfillmentsPayloadTaxDetails {
    /**
     * 
     * @type {V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit}
     * @memberof V3FulfillmentOrdersFulfillmentsPayloadTaxDetails
     */
    taxPerLine?: V3FulfillmentOrdersFulfillmentsPayloadChargePerUnit;
}
/**
 * 
 * @export
 * @interface V3FulfillmentShipmentLabelLoadTypes
 */
export interface V3FulfillmentShipmentLabelLoadTypes {
    /**
     * 
     * @type {number}
     * @memberof V3FulfillmentShipmentLabelLoadTypes
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentShipmentLabelLoadTypes
     */
    loadType?: string;
}
/**
 * update shipment qty line items
 * @export
 * @interface V3FulfillmentShipmentQuantitiesOrderItems
 */
export interface V3FulfillmentShipmentQuantitiesOrderItems {
    /**
     * Seller Item ID
     * @type {string}
     * @memberof V3FulfillmentShipmentQuantitiesOrderItems
     */
    sku: string;
    /**
     * updated quantity
     * @type {number}
     * @memberof V3FulfillmentShipmentQuantitiesOrderItems
     */
    updatedShipmentQty: number;
}
/**
 * 
 * @export
 * @interface V3ItemsOnholdSearchFilters
 */
export interface V3ItemsOnholdSearchFilters {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | status | Item status | string
     * @type {string}
     * @memberof V3ItemsOnholdSearchFilters
     */
    field?: V3ItemsOnholdSearchFiltersFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof V3ItemsOnholdSearchFilters
     */
    op?: V3ItemsOnholdSearchFiltersOpEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof V3ItemsOnholdSearchFilters
     */
    values?: Array<V3ItemsOnholdSearchFiltersValuesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchFiltersFieldEnum {
    Status = 'status'
}
/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchFiltersOpEnum {
    Equals = 'equals'
}
/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchFiltersValuesEnum {
    Prohibited = 'PROHIBITED',
    InReview = 'IN_REVIEW',
    ActionNeeded = 'ACTION_NEEDED'
}

/**
 * 
 * @export
 * @interface V3ItemsOnholdSearchQuery
 */
export interface V3ItemsOnholdSearchQuery {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | sku | An arbitrary alphanumeric unique ID, seller-specified, identifying each item | string | gtin | Specifies a Global Trade Item Number (GTIN) search. GTIN must be 14 digits. | string
     * @type {string}
     * @memberof V3ItemsOnholdSearchQuery
     */
    field?: V3ItemsOnholdSearchQueryFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof V3ItemsOnholdSearchQuery
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchQueryFieldEnum {
    Sku = 'sku',
    Gtin = 'gtin'
}

/**
 * 
 * @export
 * @interface V3ItemsOnholdSearchSort
 */
export interface V3ItemsOnholdSearchSort {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | createdAt | when the item is last submitted/updated by Seller | string | updatedAt | when the item is last updated by Seller/Walmart | string |
     * @type {string}
     * @memberof V3ItemsOnholdSearchSort
     */
    field?: V3ItemsOnholdSearchSortFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof V3ItemsOnholdSearchSort
     */
    order?: V3ItemsOnholdSearchSortOrderEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchSortFieldEnum {
    CreatedAt = 'createdAt',
    UpdatedAt = 'updatedAt'
}
/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchSortOrderEnum {
    Asc = 'ASC',
    Desc = 'DESC'
}

/**
 * 
 * @export
 * @interface WercsFeedbackRequest
 */
export interface WercsFeedbackRequest {
    /**
     * 
     * @type {V3ItemsOnholdSearchQuery}
     * @memberof WercsFeedbackRequest
     */
    query?: V3ItemsOnholdSearchQuery;
    /**
     * 
     * @type {Array<V3ItemsOnholdSearchFilters>}
     * @memberof WercsFeedbackRequest
     */
    filters?: Array<V3ItemsOnholdSearchFilters>;
    /**
     * 
     * @type {V3ItemsOnholdSearchSort}
     * @memberof WercsFeedbackRequest
     */
    sort?: V3ItemsOnholdSearchSort;
}

/**
 * FulfillmentApi - axios parameter creator
 * @export
 */
export const FulfillmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The API is used to cancel the customer fulfilment orders created in the previous flow.
         * @summary Cancel Customer Order
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFulfillment: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('cancelFulfillment', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('cancelFulfillment', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('cancelFulfillment', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject6' is not null or undefined
            assertParamExists('cancelFulfillment', 'inlineObject6', inlineObject6)
            const localVarPath = `/v3/fulfillment/orders-fulfillments/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject6, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipments status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
         * @summary Cancel Inbound Shipment
         * @param {string} inboundOrderId Unique ID identifying inbound shipment request
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipment: async (inboundOrderId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inboundOrderId' is not null or undefined
            assertParamExists('cancelShipment', 'inboundOrderId', inboundOrderId)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('cancelShipment', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('cancelShipment', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('cancelShipment', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inbound-shipments/{inboundOrderId}`
                .replace(`{${"inboundOrderId"}}`, encodeURIComponent(String(inboundOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is for seller to confirm and accept the estimated carrier shipping charges, when choosing to use WFS Preferred Carrier Program - FedEx parcel to inbound inventory to Walmart fulfillment centers.
         * @summary Confirm Carrier Rate Quote
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject10} inlineObject10 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCarrierRateQuote: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject10: InlineObject10, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject10' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'inlineObject10', inlineObject10)
            const localVarPath = `/v3/fulfillment/carrier-rate-quote/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject10, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is used for converting existing Marketplace items to be WFS eligible. Once youve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
         * @summary Convert items for WFS
         * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {InlineObject12} [inlineObject12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertItemForWfs: async (feedType: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, inlineObject12?: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedType' is not null or undefined
            assertParamExists('convertItemForWfs', 'feedType', feedType)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('convertItemForWfs', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('convertItemForWfs', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('convertItemForWfs', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject12, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.  For the shipments sent by FedEx small parcel, you can ship packages up to 150 lb, up to 108\" in length, and 165\" in length plus girth. (Girth is 2x width + 2x height.). You can ship up to 200 packages per shipment.
         * @summary Create Carrier Rate Quote
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject9} inlineObject9 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCarrierRateQuotes: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject9: InlineObject9, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject9' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'inlineObject9', inlineObject9)
            const localVarPath = `/v3/fulfillment/carrier-rate-quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject9, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API is used to create customer fulfilment orders by the seller for Walmart Multichannel Solutions flow.
         * @summary Create Customer Order
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFulfillment: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createFulfillment', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createFulfillment', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createFulfillment', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject4' is not null or undefined
            assertParamExists('createFulfillment', 'inlineObject4', inlineObject4)
            const localVarPath = `/v3/fulfillment/orders-fulfillments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on sellers packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label (deprecated)
         * @param {string} shipmentId Unique ID identifying inbound shipment
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundShipmentLabel: async (shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'shipmentId', shipmentId)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/label/{shipmentId}`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to generate WFS Receiving Labels in various formats for receiving purposes. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against.Receiving labels are customizable:  1. 3 size and format options are available to choose from through the LabelSize and LabelFormat fields:   - 4 in. x 6 in. (PDF).   - 4 in. x 3 1/3 in. (PDF).   - 4 in. x 6 in. (ZPL). 2. Provide the type of the label (box or pallet) in the LoadType field and the number of the labels needed in the Count field. 3. Print the WFS receiving label. 4. Affix the WFS receiving labels to the boxes/ pallets.  If none of the above optional inputs are provided, a blank 4 in. x 6 in. PDF format label will be generated. Sellers must work with the warehouse/supplier to provide the required details before sending any Shipments to WFS FCs: 1. Print the WFS receiving label. 2. Fill out the FILL OUT section based on the sellers packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3. Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4. Affix the WFS receiving labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundShipmentLabelV2: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject3' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'inlineObject3', inlineObject3)
            const localVarPath = `/v3/fulfillment/shipment-label`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once youve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment . In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
         * @summary Create Inbound Shipment
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject7} inlineObject7 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipment: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject7: InlineObject7, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createShipment', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createShipment', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createShipment', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject7' is not null or undefined
            assertParamExists('createShipment', 'inlineObject7', inlineObject7)
            const localVarPath = `/v3/fulfillment/inbound-shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject7, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.
         * @summary Get Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} mode Shipment type.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierRateQuote: async (shipmentId: string, mode: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'shipmentId', shipmentId)
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'mode', mode)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/carrier-rate-quotes`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API provides the list of customer fulfillment orders with corresponding details.
         * @summary Get fulfillment orders status
         * @param {string} orgId Filtering the order based on an orgId.
         * @param {string} limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive.
         * @param {string} offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [orderNumber] Search the order based on an order number.
         * @param {string} [trackingNumber] Search the order based on a tracking number.
         * @param {string} [shipmentNumber] Search the order based on a shipment number.
         * @param {string} [fromOrderDate] Search the order based on a start date (Date in YYYY-MM-DD format).
         * @param {string} [toOrderDate] Search the order based on an endDate date (Date in YYYY-MM-DD format).
         * @param {string} [sortOrder] Order of sorting (asc/desc).
         * @param {string} [sortBy] Key on which sorting is done (Supported Attributes: orderDate).
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFulfillmentOrdersStatus: async (orgId: string, limit: string, offset: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, orderNumber?: string, trackingNumber?: string, shipmentNumber?: string, fromOrderDate?: string, toOrderDate?: string, sortOrder?: string, sortBy?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getFulfillmentOrdersStatus', 'orgId', orgId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getFulfillmentOrdersStatus', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getFulfillmentOrdersStatus', 'offset', offset)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getFulfillmentOrdersStatus', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getFulfillmentOrdersStatus', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getFulfillmentOrdersStatus', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/orders-fulfillments/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderNumber !== undefined) {
                localVarQueryParameter['orderNumber'] = orderNumber;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['trackingNumber'] = trackingNumber;
            }

            if (shipmentNumber !== undefined) {
                localVarQueryParameter['shipmentNumber'] = shipmentNumber;
            }

            if (fromOrderDate !== undefined) {
                localVarQueryParameter['fromOrderDate'] = fromOrderDate;
            }

            if (toOrderDate !== undefined) {
                localVarQueryParameter['toOrderDate'] = toOrderDate;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible. 
         * @summary Get Inbound Shipment errors
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundOrderErrors: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInboundOrderErrors', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInboundOrderErrors', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInboundOrderErrors', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inbound-shipment-errors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipmentId'] = shipmentId;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
         * @summary Get Inbound Shipment Items
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundShipmentItems: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInboundShipmentItems', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInboundShipmentItems', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInboundShipmentItems', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inbound-shipment-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipmentId'] = shipmentId;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
         * @summary Get Shipments
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [status] Current shipment status
         * @param {string} [fromCreateDate] Shipment create date starting range
         * @param {string} [toCreateDate] Shipment create date starting  end range
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundShipments: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, inboundOrderId?: string, shipmentId?: string, status?: string, fromCreateDate?: string, toCreateDate?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInboundShipments', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInboundShipments', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInboundShipments', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inbound-shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (inboundOrderId !== undefined) {
                localVarQueryParameter['inboundOrderId'] = inboundOrderId;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipmentId'] = shipmentId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromCreateDate !== undefined) {
                localVarQueryParameter['fromCreateDate'] = fromCreateDate;
            }

            if (toCreateDate !== undefined) {
                localVarQueryParameter['toCreateDate'] = toCreateDate;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the information associated with Seller\'s items that are set up on Walmart Fulfillment Services (WFS) platform.
         * @summary Get WFS Inventory Health Report
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryHealthReport: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInventoryHealthReport', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInventoryHealthReport', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInventoryHealthReport', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/report/wfs/getInventoryHealthReport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns activity log for any Seller\'s item that is stored in Walmart Fulfillment Centers (WFS) platform.
         * @summary Get Inventory Log for a WFS item
         * @param {string} gtin GTIN.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipmentId] Shipment Id.
         * @param {string} [transactionType] Transaction Type.
         * @param {string} [transactionLocation] Transaction Location.
         * @param {string} [startDate] Inventory log transaction time starting range (Date in YYYY-MM-DD format).
         * @param {string} [endDate] Inventory log transaction time ending range (Date in YYYY-MM-DD format).
         * @param {string} [sortBy] Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId).
         * @param {string} [sortOrder] Sort Order (ASC or DESC).
         * @param {string} [offset] Offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] limit is the number of records to be returned.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWFSInventoryLog: async (gtin: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipmentId?: string, transactionType?: string, transactionLocation?: string, startDate?: string, endDate?: string, sortBy?: string, sortOrder?: string, offset?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gtin' is not null or undefined
            assertParamExists('getWFSInventoryLog', 'gtin', gtin)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getWFSInventoryLog', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getWFSInventoryLog', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getWFSInventoryLog', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inventory-log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (gtin !== undefined) {
                localVarQueryParameter['gtin'] = gtin;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipmentId'] = shipmentId;
            }

            if (transactionType !== undefined) {
                localVarQueryParameter['transactionType'] = transactionType;
            }

            if (transactionLocation !== undefined) {
                localVarQueryParameter['transactionLocation'] = transactionLocation;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to give a preview of the estimated Inventory Transfer Service cost and shipment destinations between ITS and self-distribution.  Note: This API is only available to sellers eligible for the Inventory Transfer Service.
         * @summary Fetch Inbound Preview
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject8} inlineObject8 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundPreview: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject8: InlineObject8, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('inboundPreview', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('inboundPreview', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('inboundPreview', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject8' is not null or undefined
            assertParamExists('inboundPreview', 'inlineObject8', inlineObject8)
            const localVarPath = `/v3/fulfillment/inbound-preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject8, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is for sellers to print carrier shipping label.   To print carrier shipping label, please first specify a Ship Date. Note, carrier allows to select a ship date 10 days in advance.
         * @summary Print Carrier Label
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject11} inlineObject11 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printCarrierLabel: async (shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject11: InlineObject11, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('printCarrierLabel', 'shipmentId', shipmentId)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('printCarrierLabel', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('printCarrierLabel', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('printCarrierLabel', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject11' is not null or undefined
            assertParamExists('printCarrierLabel', 'inlineObject11', inlineObject11)
            const localVarPath = `/v3/fulfillment/carrier-label/{shipmentId}`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject11, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request provides fulfillment and delivery promise information for all valid item/offer to seller.
         * @summary Fetch Delivery Promise Details
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promiseFulfillments: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('promiseFulfillments', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('promiseFulfillments', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('promiseFulfillments', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject5' is not null or undefined
            assertParamExists('promiseFulfillments', 'inlineObject5', inlineObject5)
            const localVarPath = `/v3/fulfillment/orders-fulfillments/fetchOrderPromiseOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject5, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs quantity to 0  they must cancel the entire Inbound Order. 
         * @summary Update Shipment Quantities 
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipmentQuantity: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'inlineObject', inlineObject)
            const localVarPath = `/v3/fulfillment/shipment-quantities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
         * @summary Update Shipment Tracking
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipmentTrackingDetails: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'inlineObject2', inlineObject2)
            const localVarPath = `/v3/fulfillment/shipment-tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Cancel Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCarrierRateQuote: async (shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'shipmentId', shipmentId)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/carrier-rate-quote/{shipmentId}`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to see a list of items that are on hold for hazmat compliance review, including items with an In Review, Action Needed, and Prohibited status. Also use this API to review your Action Needed error descriptions and understand how to correct them for further assessment.
         * @summary Hazmat Items On hold
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wercsFeedback: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('wercsFeedback', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('wercsFeedback', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('wercsFeedback', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('wercsFeedback', 'accept', accept)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('wercsFeedback', 'inlineObject1', inlineObject1)
            const localVarPath = `/v3/items/onhold/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FulfillmentApi - functional programming interface
 * @export
 */
export const FulfillmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FulfillmentApiAxiosParamCreator(configuration)
    return {
        /**
         * The API is used to cancel the customer fulfilment orders created in the previous flow.
         * @summary Cancel Customer Order
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelFulfillment(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelFulfillment(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject6, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipments status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
         * @summary Cancel Inbound Shipment
         * @param {string} inboundOrderId Unique ID identifying inbound shipment request
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelShipment(inboundOrderId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelShipment(inboundOrderId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is for seller to confirm and accept the estimated carrier shipping charges, when choosing to use WFS Preferred Carrier Program - FedEx parcel to inbound inventory to Walmart fulfillment centers.
         * @summary Confirm Carrier Rate Quote
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject10} inlineObject10 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmCarrierRateQuote(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject10: InlineObject10, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmCarrierRateQuote(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject10, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used for converting existing Marketplace items to be WFS eligible. Once youve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
         * @summary Convert items for WFS
         * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {InlineObject12} [inlineObject12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertItemForWfs(feedType: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, inlineObject12?: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertItemForWfs(feedType, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, inlineObject12, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.  For the shipments sent by FedEx small parcel, you can ship packages up to 150 lb, up to 108\" in length, and 165\" in length plus girth. (Girth is 2x width + 2x height.). You can ship up to 200 packages per shipment.
         * @summary Create Carrier Rate Quote
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject9} inlineObject9 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCarrierRateQuotes(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject9: InlineObject9, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCarrierRateQuotes(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject9, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The API is used to create customer fulfilment orders by the seller for Walmart Multichannel Solutions flow.
         * @summary Create Customer Order
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFulfillment(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFulfillment(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject4, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on sellers packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label (deprecated)
         * @param {string} shipmentId Unique ID identifying inbound shipment
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInboundShipmentLabel(shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInboundShipmentLabel(shipmentId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to generate WFS Receiving Labels in various formats for receiving purposes. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against.Receiving labels are customizable:  1. 3 size and format options are available to choose from through the LabelSize and LabelFormat fields:   - 4 in. x 6 in. (PDF).   - 4 in. x 3 1/3 in. (PDF).   - 4 in. x 6 in. (ZPL). 2. Provide the type of the label (box or pallet) in the LoadType field and the number of the labels needed in the Count field. 3. Print the WFS receiving label. 4. Affix the WFS receiving labels to the boxes/ pallets.  If none of the above optional inputs are provided, a blank 4 in. x 6 in. PDF format label will be generated. Sellers must work with the warehouse/supplier to provide the required details before sending any Shipments to WFS FCs: 1. Print the WFS receiving label. 2. Fill out the FILL OUT section based on the sellers packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3. Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4. Affix the WFS receiving labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInboundShipmentLabelV2(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInboundShipmentLabelV2(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject3, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Once youve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment . In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
         * @summary Create Inbound Shipment
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject7} inlineObject7 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipment(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject7: InlineObject7, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipment(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject7, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.
         * @summary Get Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} mode Shipment type.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarrierRateQuote(shipmentId: string, mode: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarrierRateQuote(shipmentId, mode, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The API provides the list of customer fulfillment orders with corresponding details.
         * @summary Get fulfillment orders status
         * @param {string} orgId Filtering the order based on an orgId.
         * @param {string} limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive.
         * @param {string} offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [orderNumber] Search the order based on an order number.
         * @param {string} [trackingNumber] Search the order based on a tracking number.
         * @param {string} [shipmentNumber] Search the order based on a shipment number.
         * @param {string} [fromOrderDate] Search the order based on a start date (Date in YYYY-MM-DD format).
         * @param {string} [toOrderDate] Search the order based on an endDate date (Date in YYYY-MM-DD format).
         * @param {string} [sortOrder] Order of sorting (asc/desc).
         * @param {string} [sortBy] Key on which sorting is done (Supported Attributes: orderDate).
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFulfillmentOrdersStatus(orgId: string, limit: string, offset: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, orderNumber?: string, trackingNumber?: string, shipmentNumber?: string, fromOrderDate?: string, toOrderDate?: string, sortOrder?: string, sortBy?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFulfillmentOrdersStatus(orgId, limit, offset, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, orderNumber, trackingNumber, shipmentNumber, fromOrderDate, toOrderDate, sortOrder, sortBy, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible. 
         * @summary Get Inbound Shipment errors
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboundOrderErrors(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboundOrderErrors(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, shipmentId, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
         * @summary Get Inbound Shipment Items
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboundShipmentItems(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboundShipmentItems(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, shipmentId, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
         * @summary Get Shipments
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [status] Current shipment status
         * @param {string} [fromCreateDate] Shipment create date starting range
         * @param {string} [toCreateDate] Shipment create date starting  end range
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboundShipments(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, inboundOrderId?: string, shipmentId?: string, status?: string, fromCreateDate?: string, toCreateDate?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboundShipments(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, inboundOrderId, shipmentId, status, fromCreateDate, toCreateDate, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the information associated with Seller\'s items that are set up on Walmart Fulfillment Services (WFS) platform.
         * @summary Get WFS Inventory Health Report
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventoryHealthReport(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventoryHealthReport(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns activity log for any Seller\'s item that is stored in Walmart Fulfillment Centers (WFS) platform.
         * @summary Get Inventory Log for a WFS item
         * @param {string} gtin GTIN.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipmentId] Shipment Id.
         * @param {string} [transactionType] Transaction Type.
         * @param {string} [transactionLocation] Transaction Location.
         * @param {string} [startDate] Inventory log transaction time starting range (Date in YYYY-MM-DD format).
         * @param {string} [endDate] Inventory log transaction time ending range (Date in YYYY-MM-DD format).
         * @param {string} [sortBy] Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId).
         * @param {string} [sortOrder] Sort Order (ASC or DESC).
         * @param {string} [offset] Offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] limit is the number of records to be returned.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWFSInventoryLog(gtin: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipmentId?: string, transactionType?: string, transactionLocation?: string, startDate?: string, endDate?: string, sortBy?: string, sortOrder?: string, offset?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWFSInventoryLog(gtin, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, shipmentId, transactionType, transactionLocation, startDate, endDate, sortBy, sortOrder, offset, limit, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to give a preview of the estimated Inventory Transfer Service cost and shipment destinations between ITS and self-distribution.  Note: This API is only available to sellers eligible for the Inventory Transfer Service.
         * @summary Fetch Inbound Preview
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject8} inlineObject8 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inboundPreview(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject8: InlineObject8, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inboundPreview(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject8, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is for sellers to print carrier shipping label.   To print carrier shipping label, please first specify a Ship Date. Note, carrier allows to select a ship date 10 days in advance.
         * @summary Print Carrier Label
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject11} inlineObject11 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printCarrierLabel(shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject11: InlineObject11, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.printCarrierLabel(shipmentId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject11, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request provides fulfillment and delivery promise information for all valid item/offer to seller.
         * @summary Fetch Delivery Promise Details
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promiseFulfillments(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promiseFulfillments(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject5, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs quantity to 0  they must cancel the entire Inbound Order. 
         * @summary Update Shipment Quantities 
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShipmentQuantity(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShipmentQuantity(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
         * @summary Update Shipment Tracking
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShipmentTrackingDetails(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShipmentTrackingDetails(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject2, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Cancel Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidCarrierRateQuote(shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidCarrierRateQuote(shipmentId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to see a list of items that are on hold for hazmat compliance review, including items with an In Review, Action Needed, and Prohibited status. Also use this API to review your Action Needed error descriptions and understand how to correct them for further assessment.
         * @summary Hazmat Items On hold
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wercsFeedback(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wercsFeedback(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, inlineObject1, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FulfillmentApi - factory interface
 * @export
 */
export const FulfillmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FulfillmentApiFp(configuration)
    return {
        /**
         * The API is used to cancel the customer fulfilment orders created in the previous flow.
         * @summary Cancel Customer Order
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFulfillment(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.cancelFulfillment(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject6, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipments status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
         * @summary Cancel Inbound Shipment
         * @param {string} inboundOrderId Unique ID identifying inbound shipment request
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipment(inboundOrderId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.cancelShipment(inboundOrderId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is for seller to confirm and accept the estimated carrier shipping charges, when choosing to use WFS Preferred Carrier Program - FedEx parcel to inbound inventory to Walmart fulfillment centers.
         * @summary Confirm Carrier Rate Quote
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject10} inlineObject10 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCarrierRateQuote(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject10: InlineObject10, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.confirmCarrierRateQuote(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject10, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used for converting existing Marketplace items to be WFS eligible. Once youve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
         * @summary Convert items for WFS
         * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {InlineObject12} [inlineObject12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertItemForWfs(feedType: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, inlineObject12?: InlineObject12, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.convertItemForWfs(feedType, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, inlineObject12, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.  For the shipments sent by FedEx small parcel, you can ship packages up to 150 lb, up to 108\" in length, and 165\" in length plus girth. (Girth is 2x width + 2x height.). You can ship up to 200 packages per shipment.
         * @summary Create Carrier Rate Quote
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject9} inlineObject9 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCarrierRateQuotes(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject9: InlineObject9, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.createCarrierRateQuotes(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject9, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The API is used to create customer fulfilment orders by the seller for Walmart Multichannel Solutions flow.
         * @summary Create Customer Order
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFulfillment(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.createFulfillment(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject4, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on sellers packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label (deprecated)
         * @param {string} shipmentId Unique ID identifying inbound shipment
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundShipmentLabel(shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<string> {
            return localVarFp.createInboundShipmentLabel(shipmentId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to generate WFS Receiving Labels in various formats for receiving purposes. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against.Receiving labels are customizable:  1. 3 size and format options are available to choose from through the LabelSize and LabelFormat fields:   - 4 in. x 6 in. (PDF).   - 4 in. x 3 1/3 in. (PDF).   - 4 in. x 6 in. (ZPL). 2. Provide the type of the label (box or pallet) in the LoadType field and the number of the labels needed in the Count field. 3. Print the WFS receiving label. 4. Affix the WFS receiving labels to the boxes/ pallets.  If none of the above optional inputs are provided, a blank 4 in. x 6 in. PDF format label will be generated. Sellers must work with the warehouse/supplier to provide the required details before sending any Shipments to WFS FCs: 1. Print the WFS receiving label. 2. Fill out the FILL OUT section based on the sellers packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3. Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4. Affix the WFS receiving labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundShipmentLabelV2(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<string> {
            return localVarFp.createInboundShipmentLabelV2(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject3, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Once youve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment . In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
         * @summary Create Inbound Shipment
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject7} inlineObject7 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipment(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject7: InlineObject7, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.createShipment(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject7, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.
         * @summary Get Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} mode Shipment type.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierRateQuote(shipmentId: string, mode: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getCarrierRateQuote(shipmentId, mode, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The API provides the list of customer fulfillment orders with corresponding details.
         * @summary Get fulfillment orders status
         * @param {string} orgId Filtering the order based on an orgId.
         * @param {string} limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive.
         * @param {string} offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [orderNumber] Search the order based on an order number.
         * @param {string} [trackingNumber] Search the order based on a tracking number.
         * @param {string} [shipmentNumber] Search the order based on a shipment number.
         * @param {string} [fromOrderDate] Search the order based on a start date (Date in YYYY-MM-DD format).
         * @param {string} [toOrderDate] Search the order based on an endDate date (Date in YYYY-MM-DD format).
         * @param {string} [sortOrder] Order of sorting (asc/desc).
         * @param {string} [sortBy] Key on which sorting is done (Supported Attributes: orderDate).
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFulfillmentOrdersStatus(orgId: string, limit: string, offset: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, orderNumber?: string, trackingNumber?: string, shipmentNumber?: string, fromOrderDate?: string, toOrderDate?: string, sortOrder?: string, sortBy?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.getFulfillmentOrdersStatus(orgId, limit, offset, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, orderNumber, trackingNumber, shipmentNumber, fromOrderDate, toOrderDate, sortOrder, sortBy, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible. 
         * @summary Get Inbound Shipment errors
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundOrderErrors(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.getInboundOrderErrors(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, shipmentId, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
         * @summary Get Inbound Shipment Items
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundShipmentItems(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.getInboundShipmentItems(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, shipmentId, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
         * @summary Get Shipments
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [status] Current shipment status
         * @param {string} [fromCreateDate] Shipment create date starting range
         * @param {string} [toCreateDate] Shipment create date starting  end range
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundShipments(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, inboundOrderId?: string, shipmentId?: string, status?: string, fromCreateDate?: string, toCreateDate?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getInboundShipments(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, inboundOrderId, shipmentId, status, fromCreateDate, toCreateDate, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the information associated with Seller\'s items that are set up on Walmart Fulfillment Services (WFS) platform.
         * @summary Get WFS Inventory Health Report
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryHealthReport(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getInventoryHealthReport(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns activity log for any Seller\'s item that is stored in Walmart Fulfillment Centers (WFS) platform.
         * @summary Get Inventory Log for a WFS item
         * @param {string} gtin GTIN.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [shipmentId] Shipment Id.
         * @param {string} [transactionType] Transaction Type.
         * @param {string} [transactionLocation] Transaction Location.
         * @param {string} [startDate] Inventory log transaction time starting range (Date in YYYY-MM-DD format).
         * @param {string} [endDate] Inventory log transaction time ending range (Date in YYYY-MM-DD format).
         * @param {string} [sortBy] Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId).
         * @param {string} [sortOrder] Sort Order (ASC or DESC).
         * @param {string} [offset] Offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] limit is the number of records to be returned.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWFSInventoryLog(gtin: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, shipmentId?: string, transactionType?: string, transactionLocation?: string, startDate?: string, endDate?: string, sortBy?: string, sortOrder?: string, offset?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.getWFSInventoryLog(gtin, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, shipmentId, transactionType, transactionLocation, startDate, endDate, sortBy, sortOrder, offset, limit, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to give a preview of the estimated Inventory Transfer Service cost and shipment destinations between ITS and self-distribution.  Note: This API is only available to sellers eligible for the Inventory Transfer Service.
         * @summary Fetch Inbound Preview
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject8} inlineObject8 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundPreview(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject8: InlineObject8, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.inboundPreview(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject8, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is for sellers to print carrier shipping label.   To print carrier shipping label, please first specify a Ship Date. Note, carrier allows to select a ship date 10 days in advance.
         * @summary Print Carrier Label
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject11} inlineObject11 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printCarrierLabel(shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject11: InlineObject11, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.printCarrierLabel(shipmentId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject11, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This request provides fulfillment and delivery promise information for all valid item/offer to seller.
         * @summary Fetch Delivery Promise Details
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promiseFulfillments(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.promiseFulfillments(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject5, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs quantity to 0  they must cancel the entire Inbound Order. 
         * @summary Update Shipment Quantities 
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipmentQuantity(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.updateShipmentQuantity(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
         * @summary Update Shipment Tracking
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipmentTrackingDetails(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.updateShipmentTrackingDetails(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject2, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Cancel Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCarrierRateQuote(shipmentId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.voidCarrierRateQuote(shipmentId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to see a list of items that are on hold for hazmat compliance review, including items with an In Review, Action Needed, and Prohibited status. Also use this API to review your Action Needed error descriptions and understand how to correct them for further assessment.
         * @summary Hazmat Items On hold
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wercsFeedback(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.wercsFeedback(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, inlineObject1, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelFulfillment operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCancelFulfillmentRequest
 */
export interface FulfillmentApiCancelFulfillmentRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCancelFulfillment
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCancelFulfillment
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCancelFulfillment
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject6}
     * @memberof FulfillmentApiCancelFulfillment
     */
    readonly inlineObject6: InlineObject6

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCancelFulfillment
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for cancelShipment operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCancelShipmentRequest
 */
export interface FulfillmentApiCancelShipmentRequest {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly inboundOrderId: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for confirmCarrierRateQuote operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiConfirmCarrierRateQuoteRequest
 */
export interface FulfillmentApiConfirmCarrierRateQuoteRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject10}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly inlineObject10: InlineObject10

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for convertItemForWfs operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiConvertItemForWfsRequest
 */
export interface FulfillmentApiConvertItemForWfsRequest {
    /**
     * Includes details of each entity in the feed. Do not set this parameter to true.
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly feedType: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly wMCONSUMERCHANNELTYPE?: string

    /**
     * 
     * @type {InlineObject12}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly inlineObject12?: InlineObject12
}

/**
 * Request parameters for createCarrierRateQuotes operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateCarrierRateQuotesRequest
 */
export interface FulfillmentApiCreateCarrierRateQuotesRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject9}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly inlineObject9: InlineObject9

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createFulfillment operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateFulfillmentRequest
 */
export interface FulfillmentApiCreateFulfillmentRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateFulfillment
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateFulfillment
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateFulfillment
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject4}
     * @memberof FulfillmentApiCreateFulfillment
     */
    readonly inlineObject4: InlineObject4

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateFulfillment
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createInboundShipmentLabel operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateInboundShipmentLabelRequest
 */
export interface FulfillmentApiCreateInboundShipmentLabelRequest {
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly shipmentId: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createInboundShipmentLabelV2 operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateInboundShipmentLabelV2Request
 */
export interface FulfillmentApiCreateInboundShipmentLabelV2Request {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject3}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly inlineObject3: InlineObject3

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createShipment operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateShipmentRequest
 */
export interface FulfillmentApiCreateShipmentRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject7}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly inlineObject7: InlineObject7

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getCarrierRateQuote operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetCarrierRateQuoteRequest
 */
export interface FulfillmentApiGetCarrierRateQuoteRequest {
    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly shipmentId: string

    /**
     * Shipment type.
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly mode: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getFulfillmentOrdersStatus operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetFulfillmentOrdersStatusRequest
 */
export interface FulfillmentApiGetFulfillmentOrdersStatusRequest {
    /**
     * Filtering the order based on an orgId.
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly orgId: string

    /**
     * Limiting the number of records fetched. Valid range is from 1 to 50 inclusive.
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly limit: string

    /**
     * Setting an offset to skip records. Valid range is from 0 to 50000 inclusive.
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly offset: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly wMSVCNAME: string

    /**
     * Search the order based on an order number.
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly orderNumber?: string

    /**
     * Search the order based on a tracking number.
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly trackingNumber?: string

    /**
     * Search the order based on a shipment number.
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly shipmentNumber?: string

    /**
     * Search the order based on a start date (Date in YYYY-MM-DD format).
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly fromOrderDate?: string

    /**
     * Search the order based on an endDate date (Date in YYYY-MM-DD format).
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly toOrderDate?: string

    /**
     * Order of sorting (asc/desc).
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly sortOrder?: string

    /**
     * Key on which sorting is done (Supported Attributes: orderDate).
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly sortBy?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetFulfillmentOrdersStatus
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getInboundOrderErrors operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundOrderErrorsRequest
 */
export interface FulfillmentApiGetInboundOrderErrorsRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly wMSVCNAME: string

    /**
     * offset is the number of records you wish to skip before selecting records.
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly offset?: string

    /**
     * The number of Purchase Orders to be returned.
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly limit?: string

    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly shipmentId?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getInboundShipmentItems operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundShipmentItemsRequest
 */
export interface FulfillmentApiGetInboundShipmentItemsRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly wMSVCNAME: string

    /**
     * offset is the number of records you wish to skip before selecting records.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly offset?: string

    /**
     * The number of Purchase Orders to be returned.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly limit?: string

    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly shipmentId?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getInboundShipments operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundShipmentsRequest
 */
export interface FulfillmentApiGetInboundShipmentsRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly wMSVCNAME: string

    /**
     * offset is the number of records you wish to skip before selecting records.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly offset?: string

    /**
     * The number of Purchase Orders to be returned.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly limit?: string

    /**
     * Unique ID identifying inbound shipment request.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly inboundOrderId?: string

    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly shipmentId?: string

    /**
     * Current shipment status
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly status?: string

    /**
     * Shipment create date starting range
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly fromCreateDate?: string

    /**
     * Shipment create date starting  end range
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly toCreateDate?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getInventoryHealthReport operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInventoryHealthReportRequest
 */
export interface FulfillmentApiGetInventoryHealthReportRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getWFSInventoryLog operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetWFSInventoryLogRequest
 */
export interface FulfillmentApiGetWFSInventoryLogRequest {
    /**
     * GTIN.
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly gtin: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly wMSVCNAME: string

    /**
     * Shipment Id.
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly shipmentId?: string

    /**
     * Transaction Type.
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly transactionType?: string

    /**
     * Transaction Location.
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly transactionLocation?: string

    /**
     * Inventory log transaction time starting range (Date in YYYY-MM-DD format).
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly startDate?: string

    /**
     * Inventory log transaction time ending range (Date in YYYY-MM-DD format).
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly endDate?: string

    /**
     * Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId).
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly sortBy?: string

    /**
     * Sort Order (ASC or DESC).
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly sortOrder?: string

    /**
     * Offset is the number of records you wish to skip before selecting records.
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly offset?: string

    /**
     * limit is the number of records to be returned.
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly limit?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetWFSInventoryLog
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for inboundPreview operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiInboundPreviewRequest
 */
export interface FulfillmentApiInboundPreviewRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiInboundPreview
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiInboundPreview
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiInboundPreview
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject8}
     * @memberof FulfillmentApiInboundPreview
     */
    readonly inlineObject8: InlineObject8

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiInboundPreview
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for printCarrierLabel operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiPrintCarrierLabelRequest
 */
export interface FulfillmentApiPrintCarrierLabelRequest {
    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly shipmentId: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject11}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly inlineObject11: InlineObject11

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for promiseFulfillments operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiPromiseFulfillmentsRequest
 */
export interface FulfillmentApiPromiseFulfillmentsRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiPromiseFulfillments
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiPromiseFulfillments
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiPromiseFulfillments
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject5}
     * @memberof FulfillmentApiPromiseFulfillments
     */
    readonly inlineObject5: InlineObject5

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiPromiseFulfillments
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updateShipmentQuantity operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiUpdateShipmentQuantityRequest
 */
export interface FulfillmentApiUpdateShipmentQuantityRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly inlineObject: InlineObject

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updateShipmentTrackingDetails operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiUpdateShipmentTrackingDetailsRequest
 */
export interface FulfillmentApiUpdateShipmentTrackingDetailsRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject2}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly inlineObject2: InlineObject2

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for voidCarrierRateQuote operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiVoidCarrierRateQuoteRequest
 */
export interface FulfillmentApiVoidCarrierRateQuoteRequest {
    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly shipmentId: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for wercsFeedback operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiWercsFeedbackRequest
 */
export interface FulfillmentApiWercsFeedbackRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly wMSVCNAME: string

    /**
     * Only supported Media Type : application/json
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly accept: string

    /**
     * 
     * @type {InlineObject1}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly inlineObject1: InlineObject1

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * FulfillmentApi - object-oriented interface
 * @export
 * @class FulfillmentApi
 * @extends {BaseAPI}
 */
export class FulfillmentApi extends BaseAPI {
    /**
     * The API is used to cancel the customer fulfilment orders created in the previous flow.
     * @summary Cancel Customer Order
     * @param {FulfillmentApiCancelFulfillmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public cancelFulfillment(requestParameters: FulfillmentApiCancelFulfillmentRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).cancelFulfillment(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject6, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipments status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
     * @summary Cancel Inbound Shipment
     * @param {FulfillmentApiCancelShipmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public cancelShipment(requestParameters: FulfillmentApiCancelShipmentRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).cancelShipment(requestParameters.inboundOrderId, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is for seller to confirm and accept the estimated carrier shipping charges, when choosing to use WFS Preferred Carrier Program - FedEx parcel to inbound inventory to Walmart fulfillment centers.
     * @summary Confirm Carrier Rate Quote
     * @param {FulfillmentApiConfirmCarrierRateQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public confirmCarrierRateQuote(requestParameters: FulfillmentApiConfirmCarrierRateQuoteRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).confirmCarrierRateQuote(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject10, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used for converting existing Marketplace items to be WFS eligible. Once youve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
     * @summary Convert items for WFS
     * @param {FulfillmentApiConvertItemForWfsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public convertItemForWfs(requestParameters: FulfillmentApiConvertItemForWfsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).convertItemForWfs(requestParameters.feedType, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.  For the shipments sent by FedEx small parcel, you can ship packages up to 150 lb, up to 108\" in length, and 165\" in length plus girth. (Girth is 2x width + 2x height.). You can ship up to 200 packages per shipment.
     * @summary Create Carrier Rate Quote
     * @param {FulfillmentApiCreateCarrierRateQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createCarrierRateQuotes(requestParameters: FulfillmentApiCreateCarrierRateQuotesRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).createCarrierRateQuotes(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject9, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The API is used to create customer fulfilment orders by the seller for Walmart Multichannel Solutions flow.
     * @summary Create Customer Order
     * @param {FulfillmentApiCreateFulfillmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createFulfillment(requestParameters: FulfillmentApiCreateFulfillmentRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).createFulfillment(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject4, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on sellers packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets. 
     * @summary Create Inbound Shipment label (deprecated)
     * @param {FulfillmentApiCreateInboundShipmentLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createInboundShipmentLabel(requestParameters: FulfillmentApiCreateInboundShipmentLabelRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).createInboundShipmentLabel(requestParameters.shipmentId, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to generate WFS Receiving Labels in various formats for receiving purposes. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against.Receiving labels are customizable:  1. 3 size and format options are available to choose from through the LabelSize and LabelFormat fields:   - 4 in. x 6 in. (PDF).   - 4 in. x 3 1/3 in. (PDF).   - 4 in. x 6 in. (ZPL). 2. Provide the type of the label (box or pallet) in the LoadType field and the number of the labels needed in the Count field. 3. Print the WFS receiving label. 4. Affix the WFS receiving labels to the boxes/ pallets.  If none of the above optional inputs are provided, a blank 4 in. x 6 in. PDF format label will be generated. Sellers must work with the warehouse/supplier to provide the required details before sending any Shipments to WFS FCs: 1. Print the WFS receiving label. 2. Fill out the FILL OUT section based on the sellers packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3. Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4. Affix the WFS receiving labels to the boxes/ pallets. 
     * @summary Create Inbound Shipment label
     * @param {FulfillmentApiCreateInboundShipmentLabelV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createInboundShipmentLabelV2(requestParameters: FulfillmentApiCreateInboundShipmentLabelV2Request, options?: any) {
        return FulfillmentApiFp(this.configuration).createInboundShipmentLabelV2(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject3, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once youve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment . In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
     * @summary Create Inbound Shipment
     * @param {FulfillmentApiCreateShipmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createShipment(requestParameters: FulfillmentApiCreateShipmentRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).createShipment(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject7, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.
     * @summary Get Carrier Rate Quote
     * @param {FulfillmentApiGetCarrierRateQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getCarrierRateQuote(requestParameters: FulfillmentApiGetCarrierRateQuoteRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getCarrierRateQuote(requestParameters.shipmentId, requestParameters.mode, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The API provides the list of customer fulfillment orders with corresponding details.
     * @summary Get fulfillment orders status
     * @param {FulfillmentApiGetFulfillmentOrdersStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getFulfillmentOrdersStatus(requestParameters: FulfillmentApiGetFulfillmentOrdersStatusRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getFulfillmentOrdersStatus(requestParameters.orgId, requestParameters.limit, requestParameters.offset, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.orderNumber, requestParameters.trackingNumber, requestParameters.shipmentNumber, requestParameters.fromOrderDate, requestParameters.toOrderDate, requestParameters.sortOrder, requestParameters.sortBy, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible. 
     * @summary Get Inbound Shipment errors
     * @param {FulfillmentApiGetInboundOrderErrorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getInboundOrderErrors(requestParameters: FulfillmentApiGetInboundOrderErrorsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getInboundOrderErrors(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.offset, requestParameters.limit, requestParameters.shipmentId, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
     * @summary Get Inbound Shipment Items
     * @param {FulfillmentApiGetInboundShipmentItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getInboundShipmentItems(requestParameters: FulfillmentApiGetInboundShipmentItemsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getInboundShipmentItems(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.offset, requestParameters.limit, requestParameters.shipmentId, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
     * @summary Get Shipments
     * @param {FulfillmentApiGetInboundShipmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getInboundShipments(requestParameters: FulfillmentApiGetInboundShipmentsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getInboundShipments(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.offset, requestParameters.limit, requestParameters.inboundOrderId, requestParameters.shipmentId, requestParameters.status, requestParameters.fromCreateDate, requestParameters.toCreateDate, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the information associated with Seller\'s items that are set up on Walmart Fulfillment Services (WFS) platform.
     * @summary Get WFS Inventory Health Report
     * @param {FulfillmentApiGetInventoryHealthReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getInventoryHealthReport(requestParameters: FulfillmentApiGetInventoryHealthReportRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getInventoryHealthReport(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns activity log for any Seller\'s item that is stored in Walmart Fulfillment Centers (WFS) platform.
     * @summary Get Inventory Log for a WFS item
     * @param {FulfillmentApiGetWFSInventoryLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getWFSInventoryLog(requestParameters: FulfillmentApiGetWFSInventoryLogRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getWFSInventoryLog(requestParameters.gtin, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.shipmentId, requestParameters.transactionType, requestParameters.transactionLocation, requestParameters.startDate, requestParameters.endDate, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.offset, requestParameters.limit, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to give a preview of the estimated Inventory Transfer Service cost and shipment destinations between ITS and self-distribution.  Note: This API is only available to sellers eligible for the Inventory Transfer Service.
     * @summary Fetch Inbound Preview
     * @param {FulfillmentApiInboundPreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public inboundPreview(requestParameters: FulfillmentApiInboundPreviewRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).inboundPreview(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject8, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is for sellers to print carrier shipping label.   To print carrier shipping label, please first specify a Ship Date. Note, carrier allows to select a ship date 10 days in advance.
     * @summary Print Carrier Label
     * @param {FulfillmentApiPrintCarrierLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public printCarrierLabel(requestParameters: FulfillmentApiPrintCarrierLabelRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).printCarrierLabel(requestParameters.shipmentId, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject11, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request provides fulfillment and delivery promise information for all valid item/offer to seller.
     * @summary Fetch Delivery Promise Details
     * @param {FulfillmentApiPromiseFulfillmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public promiseFulfillments(requestParameters: FulfillmentApiPromiseFulfillmentsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).promiseFulfillments(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject5, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs quantity to 0  they must cancel the entire Inbound Order. 
     * @summary Update Shipment Quantities 
     * @param {FulfillmentApiUpdateShipmentQuantityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public updateShipmentQuantity(requestParameters: FulfillmentApiUpdateShipmentQuantityRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).updateShipmentQuantity(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
     * @summary Update Shipment Tracking
     * @param {FulfillmentApiUpdateShipmentTrackingDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public updateShipmentTrackingDetails(requestParameters: FulfillmentApiUpdateShipmentTrackingDetailsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).updateShipmentTrackingDetails(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject2, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
     * @summary Cancel Carrier Rate Quote
     * @param {FulfillmentApiVoidCarrierRateQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public voidCarrierRateQuote(requestParameters: FulfillmentApiVoidCarrierRateQuoteRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).voidCarrierRateQuote(requestParameters.shipmentId, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to see a list of items that are on hold for hazmat compliance review, including items with an In Review, Action Needed, and Prohibited status. Also use this API to review your Action Needed error descriptions and understand how to correct them for further assessment.
     * @summary Hazmat Items On hold
     * @param {FulfillmentApiWercsFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public wercsFeedback(requestParameters: FulfillmentApiWercsFeedbackRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).wercsFeedback(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.accept, requestParameters.inlineObject1, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


