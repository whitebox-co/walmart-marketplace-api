/* tslint:disable */
/* eslint-disable */
/**
 * Fulfillment Management
 * With Walmart Fulfillment Services, you can focus on sales while we expertly take care of fast shipping, seamless returns, and customer service. Simply send your inventory to Walmart fulfillment centers, where we will store your products securely and prepare them swiftly for shipping when an order is placed.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    stateCode: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    phone?: string;
}
/**
 * 
 * @export
 * @interface Carrier
 */
export interface Carrier {
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    carrierId?: string;
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    carrierName?: string;
}
/**
 * 
 * @export
 * @interface CarrierLabelRequestWrapper
 */
export interface CarrierLabelRequestWrapper {
    /**
     * 
     * @type {string}
     * @memberof CarrierLabelRequestWrapper
     */
    shipDate: string;
}
/**
 * 
 * @export
 * @interface CarrierQuoteConfirmRequestWrapper
 */
export interface CarrierQuoteConfirmRequestWrapper {
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteConfirmRequestWrapper
     */
    shipmentId: string;
}
/**
 * 
 * @export
 * @interface CarrierQuoteRequestV2Wrapper
 */
export interface CarrierQuoteRequestV2Wrapper {
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    shipmentSource: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    pickupFromDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    pickupToDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    deliveryFromDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    deliveryToDateTime?: string;
    /**
     * 
     * @type {V3FulfillmentCarrierRateQuotesCustomer}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    customer: V3FulfillmentCarrierRateQuotesCustomer;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    originLocation: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    destinationLocation: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006ReturnLocation}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    returnLocation: InlineResponse2006ReturnLocation;
    /**
     * 
     * @type {Array<InlineResponse2006ShipmentPackages>}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    shipmentPackages: Array<InlineResponse2006ShipmentPackages>;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    mode: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    freightClass?: string;
    /**
     * 
     * @type {number}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    declaredValue?: number;
    /**
     * 
     * @type {Array<V3FulfillmentCarrierRateQuotesLoadTypes>}
     * @memberof CarrierQuoteRequestV2Wrapper
     */
    loadTypes?: Array<V3FulfillmentCarrierRateQuotesLoadTypes>;
}
/**
 * 
 * @export
 * @interface Cause
 */
export interface Cause {
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    customerName: string;
}
/**
 * 
 * @export
 * @interface DestinationLocation
 */
export interface DestinationLocation {
    /**
     * 
     * @type {string}
     * @memberof DestinationLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof DestinationLocation
     */
    address: InlineResponse2006OriginLocationAddress;
    /**
     * 
     * @type {string}
     * @memberof DestinationLocation
     */
    locationId?: string;
}
/**
 * 
 * @export
 * @interface FeedId
 */
export interface FeedId {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
     * @type {string}
     * @memberof FeedId
     */
    feedId?: string;
    /**
     * 
     * @type {object}
     * @memberof FeedId
     */
    additionalAttributes?: object | null;
    /**
     * 
     * @type {object}
     * @memberof FeedId
     */
    errors?: object | null;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | status | Item status | string
     * @type {string}
     * @memberof Filter
     */
    field?: FilterFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    op?: FilterOpEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Filter
     */
    values?: Array<FilterValuesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum FilterFieldEnum {
    Status = 'status'
}
/**
    * @export
    * @enum {string}
    */
export enum FilterOpEnum {
    Equals = 'equals'
}
/**
    * @export
    * @enum {string}
    */
export enum FilterValuesEnum {
    Prohibited = 'PROHIBITED',
    InReview = 'IN_REVIEW',
    ActionNeeded = 'ACTION_NEEDED'
}

/**
 * 
 * @export
 * @interface GetRateQuoteInfoResponseWrapper
 */
export interface GetRateQuoteInfoResponseWrapper {
    /**
     * 
     * @type {string}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    quoteId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    estimatedDeliveryDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    quoteCreationDate?: string;
    /**
     * 
     * @type {InlineResponse2006Carrier}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    carrier?: InlineResponse2006Carrier;
    /**
     * 
     * @type {InlineResponse2006RateQuote}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    rateQuote?: InlineResponse2006RateQuote;
    /**
     * 
     * @type {Array<InlineResponse2006ShipmentPackages>}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    shipmentPackages?: Array<InlineResponse2006ShipmentPackages>;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    originLocation?: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    destinationLocation?: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006ReturnLocation}
     * @memberof GetRateQuoteInfoResponseWrapper
     */
    returnLocation?: InlineResponse2006ReturnLocation;
}
/**
 * 
 * @export
 * @interface GetShipmentItemsDTO
 */
export interface GetShipmentItemsDTO {
    /**
     * 
     * @type {InlineResponse200Headers}
     * @memberof GetShipmentItemsDTO
     */
    headers?: InlineResponse200Headers;
    /**
     * response payload
     * @type {Array<InlineResponse2003Payload>}
     * @memberof GetShipmentItemsDTO
     */
    payload?: Array<InlineResponse2003Payload>;
}
/**
 * 
 * @export
 * @interface GetShipmentPlanDTO
 */
export interface GetShipmentPlanDTO {
    /**
     * 
     * @type {InlineResponse200Headers}
     * @memberof GetShipmentPlanDTO
     */
    headers?: InlineResponse200Headers;
    /**
     * response payload
     * @type {Array<InlineResponse200Payload>}
     * @memberof GetShipmentPlanDTO
     */
    payload?: Array<InlineResponse200Payload>;
}
/**
 * 
 * @export
 * @interface Headers
 */
export interface Headers {
    /**
     * total number of POs for provided GET request.
     * @type {number}
     * @memberof Headers
     */
    totalCount?: number;
    /**
     * provided limit value in the request
     * @type {number}
     * @memberof Headers
     */
    limit?: number;
    /**
     * provided offset value in the request.
     * @type {number}
     * @memberof Headers
     */
    offset?: number;
}
/**
 * response payload
 * @export
 * @interface InboundShipmentCreateResponseWrapper
 */
export interface InboundShipmentCreateResponseWrapper {
    /**
     * Unique ID identifying each shipment
     * @type {string}
     * @memberof InboundShipmentCreateResponseWrapper
     */
    shipmentId?: string;
    /**
     * 
     * @type {InlineResponse200ShipToAddress}
     * @memberof InboundShipmentCreateResponseWrapper
     */
    shipToAddress?: InlineResponse200ShipToAddress;
    /**
     * The items which needs to be send in the shipment
     * @type {Array<InlineResponse2001ShipmentItems>}
     * @memberof InboundShipmentCreateResponseWrapper
     */
    shipmentItems?: Array<InlineResponse2001ShipmentItems>;
    /**
     * expected delivery date for inbounding shipment. Can be different from provided in the rquest based on network capacity
     * @type {string}
     * @memberof InboundShipmentCreateResponseWrapper
     */
    expectedDeliveryDate?: string;
}
/**
 * 
 * @export
 * @interface InboundShipmentCreateResponseWrapperDTO
 */
export interface InboundShipmentCreateResponseWrapperDTO {
    /**
     * 
     * @type {string}
     * @memberof InboundShipmentCreateResponseWrapperDTO
     */
    status?: string;
    /**
     * response payload
     * @type {Array<InlineResponse2001Payload>}
     * @memberof InboundShipmentCreateResponseWrapperDTO
     */
    payload?: Array<InlineResponse2001Payload>;
}
/**
 * 
 * @export
 * @interface InboundShipmentErrorResponseWrapperDTO
 */
export interface InboundShipmentErrorResponseWrapperDTO {
    /**
     * 
     * @type {InlineResponse200Headers}
     * @memberof InboundShipmentErrorResponseWrapperDTO
     */
    headers?: InlineResponse200Headers;
    /**
     * response payload
     * @type {Array<InlineResponse2002Payload>}
     * @memberof InboundShipmentErrorResponseWrapperDTO
     */
    payload?: Array<InlineResponse2002Payload>;
}
/**
 * response payload
 * @export
 * @interface InboundShipmentErrorsResponseWrapper
 */
export interface InboundShipmentErrorsResponseWrapper {
    /**
     * Unique ID identifying inbound shipment requests
     * @type {string}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    inboundOrderId?: string;
    /**
     * created date for the request
     * @type {string}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    createdDate?: string;
    /**
     * 
     * @type {InlineResponse200ReturnAddress}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    returnAddress?: InlineResponse200ReturnAddress;
    /**
     * inbound shipment request line items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
    /**
     * Error in inbound shipment creation
     * @type {Array<InlineResponse2002Errors>}
     * @memberof InboundShipmentErrorsResponseWrapper
     */
    errors?: Array<InlineResponse2002Errors>;
}
/**
 * 
 * @export
 * @interface InboundShipmentRequestWrapper
 */
export interface InboundShipmentRequestWrapper {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InboundShipmentRequestWrapper
     */
    inboundOrderId: string;
    /**
     * 
     * @type {InlineResponse200ReturnAddress}
     * @memberof InboundShipmentRequestWrapper
     */
    returnAddress: InlineResponse200ReturnAddress;
    /**
     * inbound shipment request line items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof InboundShipmentRequestWrapper
     */
    orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
}
/**
 * 
 * @export
 * @interface InboundShipmentUpdateQtyWrapper
 */
export interface InboundShipmentUpdateQtyWrapper {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InboundShipmentUpdateQtyWrapper
     */
    inboundOrderId: string;
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof InboundShipmentUpdateQtyWrapper
     */
    shipmentId: string;
    /**
     * update shipment qty line items
     * @type {Array<V3FulfillmentShipmentQuantitiesOrderItems>}
     * @memberof InboundShipmentUpdateQtyWrapper
     */
    orderItems?: Array<V3FulfillmentShipmentQuantitiesOrderItems>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InlineObject
     */
    inboundOrderId: string;
    /**
     * 
     * @type {InlineResponse200ReturnAddress}
     * @memberof InlineObject
     */
    returnAddress: InlineResponse200ReturnAddress;
    /**
     * inbound shipment request line items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof InlineObject
     */
    orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InlineObject1
     */
    inboundOrderId: string;
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof InlineObject1
     */
    shipmentId: string;
    /**
     * update shipment qty line items
     * @type {Array<V3FulfillmentShipmentQuantitiesOrderItems>}
     * @memberof InlineObject1
     */
    orderItems?: Array<V3FulfillmentShipmentQuantitiesOrderItems>;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    labelSize?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    labelFormat?: string;
    /**
     * 
     * @type {Array<V3FulfillmentShipmentLabelLoadTypes>}
     * @memberof InlineObject2
     */
    loadTypes?: Array<V3FulfillmentShipmentLabelLoadTypes>;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    carrierName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject3
     */
    trackingInfo?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {any}
     * @memberof InlineObject4
     */
    file?: any;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {V3ItemsOnholdSearchQuery}
     * @memberof InlineObject5
     */
    query?: V3ItemsOnholdSearchQuery;
    /**
     * 
     * @type {Array<V3ItemsOnholdSearchFilters>}
     * @memberof InlineObject5
     */
    filters?: Array<V3ItemsOnholdSearchFilters>;
    /**
     * 
     * @type {V3ItemsOnholdSearchSort}
     * @memberof InlineObject5
     */
    sort?: V3ItemsOnholdSearchSort;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    shipmentSource: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    pickupFromDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    pickupToDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    deliveryFromDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    deliveryToDateTime?: string;
    /**
     * 
     * @type {V3FulfillmentCarrierRateQuotesCustomer}
     * @memberof InlineObject6
     */
    customer: V3FulfillmentCarrierRateQuotesCustomer;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof InlineObject6
     */
    originLocation: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof InlineObject6
     */
    destinationLocation: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006ReturnLocation}
     * @memberof InlineObject6
     */
    returnLocation: InlineResponse2006ReturnLocation;
    /**
     * 
     * @type {Array<InlineResponse2006ShipmentPackages>}
     * @memberof InlineObject6
     */
    shipmentPackages: Array<InlineResponse2006ShipmentPackages>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    mode: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    freightClass?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    declaredValue?: number;
    /**
     * 
     * @type {Array<V3FulfillmentCarrierRateQuotesLoadTypes>}
     * @memberof InlineObject6
     */
    loadTypes?: Array<V3FulfillmentCarrierRateQuotesLoadTypes>;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    shipmentId: string;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    shipDate: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200Headers}
     * @memberof InlineResponse200
     */
    headers?: InlineResponse200Headers;
    /**
     * response payload
     * @type {Array<InlineResponse200Payload>}
     * @memberof InlineResponse200
     */
    payload?: Array<InlineResponse200Payload>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    status?: string;
    /**
     * response payload
     * @type {Array<InlineResponse2001Payload>}
     * @memberof InlineResponse2001
     */
    payload?: Array<InlineResponse2001Payload>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse2001Payload
 */
export interface InlineResponse2001Payload {
    /**
     * Unique ID identifying each shipment
     * @type {string}
     * @memberof InlineResponse2001Payload
     */
    shipmentId?: string;
    /**
     * 
     * @type {InlineResponse200ShipToAddress}
     * @memberof InlineResponse2001Payload
     */
    shipToAddress?: InlineResponse200ShipToAddress;
    /**
     * The items which needs to be send in the shipment
     * @type {Array<InlineResponse2001ShipmentItems>}
     * @memberof InlineResponse2001Payload
     */
    shipmentItems?: Array<InlineResponse2001ShipmentItems>;
    /**
     * expected delivery date for inbounding shipment. Can be different from provided in the rquest based on network capacity
     * @type {string}
     * @memberof InlineResponse2001Payload
     */
    expectedDeliveryDate?: string;
}
/**
 * The items which needs to be send in the shipment
 * @export
 * @interface InlineResponse2001ShipmentItems
 */
export interface InlineResponse2001ShipmentItems {
    /**
     * Seller Item ID
     * @type {string}
     * @memberof InlineResponse2001ShipmentItems
     */
    vendorSku?: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof InlineResponse2001ShipmentItems
     */
    itemQty?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {InlineResponse200Headers}
     * @memberof InlineResponse2002
     */
    headers?: InlineResponse200Headers;
    /**
     * response payload
     * @type {Array<InlineResponse2002Payload>}
     * @memberof InlineResponse2002
     */
    payload?: Array<InlineResponse2002Payload>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Causes
 */
export interface InlineResponse2002Causes {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Causes
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Causes
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Causes
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Causes
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Errors
 */
export interface InlineResponse2002Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Errors
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Errors
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Errors
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Errors
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Errors
     */
    severity?: InlineResponse2002ErrorsSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Errors
     */
    category?: InlineResponse2002ErrorsCategoryEnum;
    /**
     * 
     * @type {Array<InlineResponse2002Causes>}
     * @memberof InlineResponse2002Errors
     */
    causes?: Array<InlineResponse2002Causes>;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2002ErrorsSeverityEnum {
    Info = 'INFO',
    Warn = 'WARN',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2002ErrorsCategoryEnum {
    Application = 'APPLICATION',
    System = 'SYSTEM',
    Request = 'REQUEST',
    Data = 'DATA'
}

/**
 * response payload
 * @export
 * @interface InlineResponse2002Payload
 */
export interface InlineResponse2002Payload {
    /**
     * Unique ID identifying inbound shipment requests
     * @type {string}
     * @memberof InlineResponse2002Payload
     */
    inboundOrderId?: string;
    /**
     * created date for the request
     * @type {string}
     * @memberof InlineResponse2002Payload
     */
    createdDate?: string;
    /**
     * 
     * @type {InlineResponse200ReturnAddress}
     * @memberof InlineResponse2002Payload
     */
    returnAddress?: InlineResponse200ReturnAddress;
    /**
     * inbound shipment request line items
     * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
     * @memberof InlineResponse2002Payload
     */
    orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
    /**
     * Error in inbound shipment creation
     * @type {Array<InlineResponse2002Errors>}
     * @memberof InlineResponse2002Payload
     */
    errors?: Array<InlineResponse2002Errors>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {InlineResponse200Headers}
     * @memberof InlineResponse2003
     */
    headers?: InlineResponse200Headers;
    /**
     * response payload
     * @type {Array<InlineResponse2003Payload>}
     * @memberof InlineResponse2003
     */
    payload?: Array<InlineResponse2003Payload>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse2003Payload
 */
export interface InlineResponse2003Payload {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    inboundOrderId?: string;
    /**
     * Unique ID identifying each shipment
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    shipmentId?: string;
    /**
     * Item barcode
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    gtin?: string;
    /**
     * Seller Item ID
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    sku?: string;
    /**
     * Item description
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    itemDesc?: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof InlineResponse2003Payload
     */
    itemQty?: number;
    /**
     * Total number of cases
     * @type {number}
     * @memberof InlineResponse2003Payload
     */
    vendorPackQty?: number;
    /**
     * Total number of sellable units per case
     * @type {number}
     * @memberof InlineResponse2003Payload
     */
    innerPackQty?: number;
    /**
     * Qty received in FC
     * @type {number}
     * @memberof InlineResponse2003Payload
     */
    receivedQty?: number;
    /**
     * Qty damaged while receiving in FC
     * @type {number}
     * @memberof InlineResponse2003Payload
     */
    damagedQty?: number;
    /**
     * Fill rate for this shipment item
     * @type {number}
     * @memberof InlineResponse2003Payload
     */
    fillRate?: number;
    /**
     * expected delivery date provided by seller
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    expectedDeliveryDate?: string;
    /**
     * update expected delivery date based on network capacity
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    updatedExpectedDeliveryDate?: string;
    /**
     * FC name
     * @type {string}
     * @memberof InlineResponse2003Payload
     */
    shipNodeName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    status: InlineResponse2004StatusEnum;
    /**
     * 
     * @type {InlineResponse2004Header}
     * @memberof InlineResponse2004
     */
    header?: InlineResponse2004Header;
    /**
     * 
     * @type {Array<InlineResponse2002Errors>}
     * @memberof InlineResponse2004
     */
    errors?: Array<InlineResponse2002Errors>;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2004
     */
    payload?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2004StatusEnum {
    Ok = 'OK',
    Created = 'CREATED',
    Accepted = 'ACCEPTED',
    NoContent = 'NO_CONTENT',
    Partial = 'PARTIAL',
    MovedPermanent = 'MOVED_PERMANENT',
    Found = 'FOUND',
    SeeOther = 'SEE_OTHER',
    NotModified = 'NOT_MODIFIED',
    TemporaryRedirect = 'TEMPORARY_REDIRECT',
    BadRequest = 'BAD_REQUEST',
    Unauthorized = 'UNAUTHORIZED',
    Forbidden = 'FORBIDDEN',
    NotFound = 'NOT_FOUND',
    MethodNotAllowed = 'METHOD_NOT_ALLOWED',
    NotAcceptable = 'NOT_ACCEPTABLE',
    RequestTimeout = 'REQUEST_TIMEOUT',
    Conflict = 'CONFLICT',
    RequestEntityTooLarge = 'REQUEST_ENTITY_TOO_LARGE',
    UnsupportedMediaType = 'UNSUPPORTED_MEDIA_TYPE',
    UnprocessableEntity = 'UNPROCESSABLE_ENTITY',
    Fail = 'FAIL',
    BadGateway = 'BAD_GATEWAY',
    ServiceUnavailable = 'SERVICE_UNAVAILABLE',
    GatewayTimeout = 'GATEWAY_TIMEOUT'
}

/**
 * 
 * @export
 * @interface InlineResponse2004Header
 */
export interface InlineResponse2004Header {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse2004Header
     */
    headerAttributes?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
     * @type {string}
     * @memberof InlineResponse2005
     */
    feedId?: string;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2005
     */
    additionalAttributes?: object | null;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2005
     */
    errors?: object | null;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    quoteId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    estimatedDeliveryDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    quoteCreationDate?: string;
    /**
     * 
     * @type {InlineResponse2006Carrier}
     * @memberof InlineResponse2006
     */
    carrier?: InlineResponse2006Carrier;
    /**
     * 
     * @type {InlineResponse2006RateQuote}
     * @memberof InlineResponse2006
     */
    rateQuote?: InlineResponse2006RateQuote;
    /**
     * 
     * @type {Array<InlineResponse2006ShipmentPackages>}
     * @memberof InlineResponse2006
     */
    shipmentPackages?: Array<InlineResponse2006ShipmentPackages>;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof InlineResponse2006
     */
    originLocation?: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006OriginLocation}
     * @memberof InlineResponse2006
     */
    destinationLocation?: InlineResponse2006OriginLocation;
    /**
     * 
     * @type {InlineResponse2006ReturnLocation}
     * @memberof InlineResponse2006
     */
    returnLocation?: InlineResponse2006ReturnLocation;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Carrier
 */
export interface InlineResponse2006Carrier {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Carrier
     */
    carrierId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Carrier
     */
    carrierName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006LabelInformation
 */
export interface InlineResponse2006LabelInformation {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    labelData?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    labelFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    trackingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    referenceTrackingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    epTrackerId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    packageAsn?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006LabelInformation
     */
    masterTrackingCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006LabelInformation
     */
    master?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2006OriginLocation
 */
export interface InlineResponse2006OriginLocation {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof InlineResponse2006OriginLocation
     */
    address: InlineResponse2006OriginLocationAddress;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocation
     */
    locationId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006OriginLocationAddress
 */
export interface InlineResponse2006OriginLocationAddress {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    stateCode: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006OriginLocationAddress
     */
    phone?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006RateQuote
 */
export interface InlineResponse2006RateQuote {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    quoteId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    estimatedDeliveryDateTime?: string;
    /**
     * 
     * @type {InlineResponse2006Carrier}
     * @memberof InlineResponse2006RateQuote
     */
    carrier?: InlineResponse2006Carrier;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    discountCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    netCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    surchargeType?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    surchargeValue?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    totalBillingWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    transitDays?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    effectiveDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    expiryDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    sellerFreightClassCode?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    freightCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    fuelCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    totalWeight?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    totalVolume?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    equipmentTypeCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    serviceCode?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    numberOfPallets?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    nominalCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    assessorialCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    serviceCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    minimumCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    declaredValue?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    mixedSKUs?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006RateQuote
     */
    singleSKUs?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006RateQuote
     */
    freightReadyDate?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006ReturnLocation
 */
export interface InlineResponse2006ReturnLocation {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ReturnLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof InlineResponse2006ReturnLocation
     */
    address: InlineResponse2006OriginLocationAddress;
}
/**
 * 
 * @export
 * @interface InlineResponse2006ShipmentPackages
 */
export interface InlineResponse2006ShipmentPackages {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    packageSequenceNumber: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    weight: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ShipmentPackages
     */
    weightUOM: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    length: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    width: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ShipmentPackages
     */
    lengthUOM: string;
    /**
     * 
     * @type {InlineResponse2006LabelInformation}
     * @memberof InlineResponse2006ShipmentPackages
     */
    labelInformation?: InlineResponse2006LabelInformation;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    billingWeight?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    netCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    nominalCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    assessorialCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    serviceCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ShipmentPackages
     */
    packageType?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006ShipmentPackages
     */
    noOfPackages?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006ShipmentPackages
     */
    stackable?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    shipmentNumber?: string;
    /**
     * 
     * @type {Array<InlineResponse2006RateQuote>}
     * @memberof InlineResponse2007
     */
    rateQuotes?: Array<InlineResponse2006RateQuote>;
}
/**
 * 
 * @export
 * @interface InlineResponse200Headers
 */
export interface InlineResponse200Headers {
    /**
     * total number of POs for provided GET request.
     * @type {number}
     * @memberof InlineResponse200Headers
     */
    totalCount?: number;
    /**
     * provided limit value in the request
     * @type {number}
     * @memberof InlineResponse200Headers
     */
    limit?: number;
    /**
     * provided offset value in the request.
     * @type {number}
     * @memberof InlineResponse200Headers
     */
    offset?: number;
}
/**
 * response payload
 * @export
 * @interface InlineResponse200Payload
 */
export interface InlineResponse200Payload {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    inboundOrderId?: string;
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    shipmentId?: string;
    /**
     * 
     * @type {InlineResponse200ShipToAddress}
     * @memberof InlineResponse200Payload
     */
    shipToAddress?: InlineResponse200ShipToAddress;
    /**
     * 
     * @type {InlineResponse200ReturnAddress}
     * @memberof InlineResponse200Payload
     */
    returnAddress?: InlineResponse200ReturnAddress;
    /**
     * Current status of the shipment
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    status?: string;
    /**
     * creation date for shipment
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    createdDate?: string;
    /**
     * Total number of units in the shipment
     * @type {number}
     * @memberof InlineResponse200Payload
     */
    shipmentUnits?: number;
    /**
     * Total number of units recived in FC for the shipment
     * @type {number}
     * @memberof InlineResponse200Payload
     */
    receivedUnits?: number;
    /**
     * expected delivery date provided by seller
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    expectedDeliveryDate?: string;
    /**
     * update expected delivery date based on network capacity
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    updatedExpectedDeliveryDate?: string;
    /**
     * Actual delivery date of the shipment at FC
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    actualDeliveryDate?: string;
    /**
     * Tracking info for the shipment
     * @type {Array<string>}
     * @memberof InlineResponse200Payload
     */
    trackingNo?: Array<string>;
    /**
     * Carrier of the shipment
     * @type {string}
     * @memberof InlineResponse200Payload
     */
    carrierName?: string;
}
/**
 * Retrun address for seller
 * @export
 * @interface InlineResponse200ReturnAddress
 */
export interface InlineResponse200ReturnAddress {
    /**
     * Address details
     * @type {string}
     * @memberof InlineResponse200ReturnAddress
     */
    addressLine1: string;
    /**
     * Address details continuation
     * @type {string}
     * @memberof InlineResponse200ReturnAddress
     */
    addressLine2?: string;
    /**
     * City name
     * @type {string}
     * @memberof InlineResponse200ReturnAddress
     */
    city: string;
    /**
     * State Code
     * @type {string}
     * @memberof InlineResponse200ReturnAddress
     */
    stateCode: string;
    /**
     * Country code
     * @type {string}
     * @memberof InlineResponse200ReturnAddress
     */
    countryCode: string;
    /**
     * Zip code
     * @type {string}
     * @memberof InlineResponse200ReturnAddress
     */
    postalCode: string;
}
/**
 * The address to which sellers need to inbound items
 * @export
 * @interface InlineResponse200ShipToAddress
 */
export interface InlineResponse200ShipToAddress {
    /**
     * Facility name
     * @type {string}
     * @memberof InlineResponse200ShipToAddress
     */
    fcName?: string;
    /**
     * Address details 
     * @type {string}
     * @memberof InlineResponse200ShipToAddress
     */
    addressLine1?: string;
    /**
     * Address details continuation
     * @type {string}
     * @memberof InlineResponse200ShipToAddress
     */
    addressLine2?: string;
    /**
     * City name
     * @type {string}
     * @memberof InlineResponse200ShipToAddress
     */
    city?: string;
    /**
     * State code
     * @type {string}
     * @memberof InlineResponse200ShipToAddress
     */
    stateCode?: string;
    /**
     * Country code
     * @type {string}
     * @memberof InlineResponse200ShipToAddress
     */
    countryCode?: string;
    /**
     * Zip code
     * @type {string}
     * @memberof InlineResponse200ShipToAddress
     */
    postalCode?: string;
}
/**
 * 
 * @export
 * @interface LabelInformation
 */
export interface LabelInformation {
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    labelData?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    labelFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    trackingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    referenceTrackingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    epTrackerId?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    packageAsn?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelInformation
     */
    masterTrackingCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LabelInformation
     */
    master?: boolean;
}
/**
 * 
 * @export
 * @interface LabelV2RequestWrapper
 */
export interface LabelV2RequestWrapper {
    /**
     * 
     * @type {string}
     * @memberof LabelV2RequestWrapper
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof LabelV2RequestWrapper
     */
    labelSize?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelV2RequestWrapper
     */
    labelFormat?: string;
    /**
     * 
     * @type {Array<V3FulfillmentShipmentLabelLoadTypes>}
     * @memberof LabelV2RequestWrapper
     */
    loadTypes?: Array<V3FulfillmentShipmentLabelLoadTypes>;
}
/**
 * 
 * @export
 * @interface LoadType
 */
export interface LoadType {
    /**
     * 
     * @type {number}
     * @memberof LoadType
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof LoadType
     */
    loadType?: string;
}
/**
 * 
 * @export
 * @interface LoadTypeDetails
 */
export interface LoadTypeDetails {
    /**
     * 
     * @type {string}
     * @memberof LoadTypeDetails
     */
    count: string;
    /**
     * 
     * @type {string}
     * @memberof LoadTypeDetails
     */
    loadType: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    severity?: ModelErrorSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    category?: ModelErrorCategoryEnum;
    /**
     * 
     * @type {Array<InlineResponse2002Causes>}
     * @memberof ModelError
     */
    causes?: Array<InlineResponse2002Causes>;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelErrorSeverityEnum {
    Info = 'INFO',
    Warn = 'WARN',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum ModelErrorCategoryEnum {
    Application = 'APPLICATION',
    System = 'SYSTEM',
    Request = 'REQUEST',
    Data = 'DATA'
}

/**
 * inbound shipment request line items
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * Unique ID identifying product
     * @type {string}
     * @memberof OrderItem
     */
    productId: string;
    /**
     * Supported product types are GTIN,UPC,EAN
     * @type {string}
     * @memberof OrderItem
     */
    productType: string;
    /**
     * Seller Item ID
     * @type {string}
     * @memberof OrderItem
     */
    sku: string;
    /**
     * Item description
     * @type {string}
     * @memberof OrderItem
     */
    itemDesc: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof OrderItem
     */
    itemQty: number;
    /**
     * Total number of cases
     * @type {number}
     * @memberof OrderItem
     */
    vendorPackQty: number;
    /**
     * Total number of sellable units per case
     * @type {number}
     * @memberof OrderItem
     */
    innerPackQty: number;
    /**
     * expected delivery date for shipment
     * @type {string}
     * @memberof OrderItem
     */
    expectedDeliveryDate: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    itemNbr?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof OrderItem
     */
    dimensions?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    itemWeightQty?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderItem
     */
    nonSortItem?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    shipNode?: string;
}
/**
 * update shipment qty line items
 * @export
 * @interface OrderItemUpdate
 */
export interface OrderItemUpdate {
    /**
     * Seller Item ID
     * @type {string}
     * @memberof OrderItemUpdate
     */
    sku: string;
    /**
     * updated quantity
     * @type {number}
     * @memberof OrderItemUpdate
     */
    updatedShipmentQty: number;
}
/**
 * 
 * @export
 * @interface OriginLocation
 */
export interface OriginLocation {
    /**
     * 
     * @type {string}
     * @memberof OriginLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof OriginLocation
     */
    address: InlineResponse2006OriginLocationAddress;
    /**
     * 
     * @type {string}
     * @memberof OriginLocation
     */
    locationId?: string;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | sku | An arbitrary alphanumeric unique ID, seller-specified, identifying each item | string | gtin | Specifies a Global Trade Item Number (GTIN) search. GTIN must be 14 digits. | string
     * @type {string}
     * @memberof Query
     */
    field?: QueryFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof Query
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryFieldEnum {
    Sku = 'sku',
    Gtin = 'gtin'
}

/**
 * 
 * @export
 * @interface QuoteResponseV2Wrapper
 */
export interface QuoteResponseV2Wrapper {
    /**
     * 
     * @type {string}
     * @memberof QuoteResponseV2Wrapper
     */
    shipmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteResponseV2Wrapper
     */
    shipmentNumber?: string;
    /**
     * 
     * @type {Array<InlineResponse2006RateQuote>}
     * @memberof QuoteResponseV2Wrapper
     */
    rateQuotes?: Array<InlineResponse2006RateQuote>;
}
/**
 * 
 * @export
 * @interface RateQuoteV2
 */
export interface RateQuoteV2 {
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    quoteId?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    estimatedDeliveryDateTime?: string;
    /**
     * 
     * @type {InlineResponse2006Carrier}
     * @memberof RateQuoteV2
     */
    carrier?: InlineResponse2006Carrier;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    discountCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    netCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    surchargeType?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    surchargeValue?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    totalBillingWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    transitDays?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    effectiveDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    expiryDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    sellerFreightClassCode?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    freightCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    fuelCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    totalWeight?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    totalVolume?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    equipmentTypeCode?: string;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    serviceCode?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    numberOfPallets?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    nominalCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    assessorialCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    serviceCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    minimumCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    declaredValue?: string;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    mixedSKUs?: number;
    /**
     * 
     * @type {number}
     * @memberof RateQuoteV2
     */
    singleSKUs?: number;
    /**
     * 
     * @type {string}
     * @memberof RateQuoteV2
     */
    freightReadyDate?: string;
}
/**
 * Retrun address for seller
 * @export
 * @interface ReturnAddress
 */
export interface ReturnAddress {
    /**
     * Address details
     * @type {string}
     * @memberof ReturnAddress
     */
    addressLine1: string;
    /**
     * Address details continuation
     * @type {string}
     * @memberof ReturnAddress
     */
    addressLine2?: string;
    /**
     * City name
     * @type {string}
     * @memberof ReturnAddress
     */
    city: string;
    /**
     * State Code
     * @type {string}
     * @memberof ReturnAddress
     */
    stateCode: string;
    /**
     * Country code
     * @type {string}
     * @memberof ReturnAddress
     */
    countryCode: string;
    /**
     * Zip code
     * @type {string}
     * @memberof ReturnAddress
     */
    postalCode: string;
}
/**
 * 
 * @export
 * @interface ReturnLocation
 */
export interface ReturnLocation {
    /**
     * 
     * @type {string}
     * @memberof ReturnLocation
     */
    locationName: string;
    /**
     * 
     * @type {InlineResponse2006OriginLocationAddress}
     * @memberof ReturnLocation
     */
    address: InlineResponse2006OriginLocationAddress;
}
/**
 * 
 * @export
 * @interface ServiceHeader
 */
export interface ServiceHeader {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceHeader
     */
    headerAttributes?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceResponse
     */
    status: ServiceResponseStatusEnum;
    /**
     * 
     * @type {InlineResponse2004Header}
     * @memberof ServiceResponse
     */
    header?: InlineResponse2004Header;
    /**
     * 
     * @type {Array<InlineResponse2002Errors>}
     * @memberof ServiceResponse
     */
    errors?: Array<InlineResponse2002Errors>;
    /**
     * 
     * @type {object}
     * @memberof ServiceResponse
     */
    payload?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ServiceResponseStatusEnum {
    Ok = 'OK',
    Created = 'CREATED',
    Accepted = 'ACCEPTED',
    NoContent = 'NO_CONTENT',
    Partial = 'PARTIAL',
    MovedPermanent = 'MOVED_PERMANENT',
    Found = 'FOUND',
    SeeOther = 'SEE_OTHER',
    NotModified = 'NOT_MODIFIED',
    TemporaryRedirect = 'TEMPORARY_REDIRECT',
    BadRequest = 'BAD_REQUEST',
    Unauthorized = 'UNAUTHORIZED',
    Forbidden = 'FORBIDDEN',
    NotFound = 'NOT_FOUND',
    MethodNotAllowed = 'METHOD_NOT_ALLOWED',
    NotAcceptable = 'NOT_ACCEPTABLE',
    RequestTimeout = 'REQUEST_TIMEOUT',
    Conflict = 'CONFLICT',
    RequestEntityTooLarge = 'REQUEST_ENTITY_TOO_LARGE',
    UnsupportedMediaType = 'UNSUPPORTED_MEDIA_TYPE',
    UnprocessableEntity = 'UNPROCESSABLE_ENTITY',
    Fail = 'FAIL',
    BadGateway = 'BAD_GATEWAY',
    ServiceUnavailable = 'SERVICE_UNAVAILABLE',
    GatewayTimeout = 'GATEWAY_TIMEOUT'
}

/**
 * The address to which sellers need to inbound items
 * @export
 * @interface ShipToAddress
 */
export interface ShipToAddress {
    /**
     * Facility name
     * @type {string}
     * @memberof ShipToAddress
     */
    fcName?: string;
    /**
     * Address details 
     * @type {string}
     * @memberof ShipToAddress
     */
    addressLine1?: string;
    /**
     * Address details continuation
     * @type {string}
     * @memberof ShipToAddress
     */
    addressLine2?: string;
    /**
     * City name
     * @type {string}
     * @memberof ShipToAddress
     */
    city?: string;
    /**
     * State code
     * @type {string}
     * @memberof ShipToAddress
     */
    stateCode?: string;
    /**
     * Country code
     * @type {string}
     * @memberof ShipToAddress
     */
    countryCode?: string;
    /**
     * Zip code
     * @type {string}
     * @memberof ShipToAddress
     */
    postalCode?: string;
}
/**
 * The items which needs to be send in the shipment
 * @export
 * @interface ShipmentItem
 */
export interface ShipmentItem {
    /**
     * Seller Item ID
     * @type {string}
     * @memberof ShipmentItem
     */
    vendorSku?: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof ShipmentItem
     */
    itemQty?: number;
}
/**
 * response payload
 * @export
 * @interface ShipmentItemDetails
 */
export interface ShipmentItemDetails {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    inboundOrderId?: string;
    /**
     * Unique ID identifying each shipment
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    shipmentId?: string;
    /**
     * Item barcode
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    gtin?: string;
    /**
     * Seller Item ID
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    sku?: string;
    /**
     * Item description
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    itemDesc?: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    itemQty?: number;
    /**
     * Total number of cases
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    vendorPackQty?: number;
    /**
     * Total number of sellable units per case
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    innerPackQty?: number;
    /**
     * Qty received in FC
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    receivedQty?: number;
    /**
     * Qty damaged while receiving in FC
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    damagedQty?: number;
    /**
     * Fill rate for this shipment item
     * @type {number}
     * @memberof ShipmentItemDetails
     */
    fillRate?: number;
    /**
     * expected delivery date provided by seller
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    expectedDeliveryDate?: string;
    /**
     * update expected delivery date based on network capacity
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    updatedExpectedDeliveryDate?: string;
    /**
     * FC name
     * @type {string}
     * @memberof ShipmentItemDetails
     */
    shipNodeName?: string;
}
/**
 * 
 * @export
 * @interface ShipmentPackage
 */
export interface ShipmentPackage {
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    packageSequenceNumber: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    weight: number;
    /**
     * 
     * @type {string}
     * @memberof ShipmentPackage
     */
    weightUOM: string;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    length: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    width: number;
    /**
     * 
     * @type {string}
     * @memberof ShipmentPackage
     */
    lengthUOM: string;
    /**
     * 
     * @type {InlineResponse2006LabelInformation}
     * @memberof ShipmentPackage
     */
    labelInformation?: InlineResponse2006LabelInformation;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    billingWeight?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    netCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    nominalCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    assessorialCharge?: number;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    serviceCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof ShipmentPackage
     */
    packageType?: string;
    /**
     * 
     * @type {number}
     * @memberof ShipmentPackage
     */
    noOfPackages?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShipmentPackage
     */
    stackable?: boolean;
}
/**
 * response payload
 * @export
 * @interface ShipmentPlanDetails
 */
export interface ShipmentPlanDetails {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    inboundOrderId?: string;
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    shipmentId?: string;
    /**
     * 
     * @type {InlineResponse200ShipToAddress}
     * @memberof ShipmentPlanDetails
     */
    shipToAddress?: InlineResponse200ShipToAddress;
    /**
     * 
     * @type {InlineResponse200ReturnAddress}
     * @memberof ShipmentPlanDetails
     */
    returnAddress?: InlineResponse200ReturnAddress;
    /**
     * Current status of the shipment
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    status?: string;
    /**
     * creation date for shipment
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    createdDate?: string;
    /**
     * Total number of units in the shipment
     * @type {number}
     * @memberof ShipmentPlanDetails
     */
    shipmentUnits?: number;
    /**
     * Total number of units recived in FC for the shipment
     * @type {number}
     * @memberof ShipmentPlanDetails
     */
    receivedUnits?: number;
    /**
     * expected delivery date provided by seller
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    expectedDeliveryDate?: string;
    /**
     * update expected delivery date based on network capacity
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    updatedExpectedDeliveryDate?: string;
    /**
     * Actual delivery date of the shipment at FC
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    actualDeliveryDate?: string;
    /**
     * Tracking info for the shipment
     * @type {Array<string>}
     * @memberof ShipmentPlanDetails
     */
    trackingNo?: Array<string>;
    /**
     * Carrier of the shipment
     * @type {string}
     * @memberof ShipmentPlanDetails
     */
    carrierName?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | createdAt | when the item is last submitted/updated by Seller | string | updatedAt | when the item is last updated by Seller/Walmart | string |
     * @type {string}
     * @memberof Sort
     */
    field?: SortFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof Sort
     */
    order?: SortOrderEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SortFieldEnum {
    CreatedAt = 'createdAt',
    UpdatedAt = 'updatedAt'
}
/**
    * @export
    * @enum {string}
    */
export enum SortOrderEnum {
    Asc = 'ASC',
    Desc = 'DESC'
}

/**
 * 
 * @export
 * @interface TrackingInfoWrapper
 */
export interface TrackingInfoWrapper {
    /**
     * 
     * @type {string}
     * @memberof TrackingInfoWrapper
     */
    shipmentId: string;
    /**
     * 
     * @type {string}
     * @memberof TrackingInfoWrapper
     */
    carrierName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingInfoWrapper
     */
    trackingInfo?: Array<string>;
}
/**
 * 
 * @export
 * @interface V3FulfillmentCarrierRateQuotesCustomer
 */
export interface V3FulfillmentCarrierRateQuotesCustomer {
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentCarrierRateQuotesCustomer
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentCarrierRateQuotesCustomer
     */
    customerName: string;
}
/**
 * 
 * @export
 * @interface V3FulfillmentCarrierRateQuotesLoadTypes
 */
export interface V3FulfillmentCarrierRateQuotesLoadTypes {
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentCarrierRateQuotesLoadTypes
     */
    count: string;
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentCarrierRateQuotesLoadTypes
     */
    loadType: string;
}
/**
 * inbound shipment request line items
 * @export
 * @interface V3FulfillmentInboundShipmentsOrderItems
 */
export interface V3FulfillmentInboundShipmentsOrderItems {
    /**
     * Unique ID identifying product
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    productId: string;
    /**
     * Supported product types are GTIN,UPC,EAN
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    productType: string;
    /**
     * Seller Item ID
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    sku: string;
    /**
     * Item description
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    itemDesc: string;
    /**
     * Total number of sellable units
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    itemQty: number;
    /**
     * Total number of cases
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    vendorPackQty: number;
    /**
     * Total number of sellable units per case
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    innerPackQty: number;
    /**
     * expected delivery date for shipment
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    expectedDeliveryDate: string;
    /**
     * 
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    itemNbr?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    dimensions?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    itemWeightQty?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    nonSortItem?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentInboundShipmentsOrderItems
     */
    shipNode?: string;
}
/**
 * 
 * @export
 * @interface V3FulfillmentShipmentLabelLoadTypes
 */
export interface V3FulfillmentShipmentLabelLoadTypes {
    /**
     * 
     * @type {number}
     * @memberof V3FulfillmentShipmentLabelLoadTypes
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof V3FulfillmentShipmentLabelLoadTypes
     */
    loadType?: string;
}
/**
 * update shipment qty line items
 * @export
 * @interface V3FulfillmentShipmentQuantitiesOrderItems
 */
export interface V3FulfillmentShipmentQuantitiesOrderItems {
    /**
     * Seller Item ID
     * @type {string}
     * @memberof V3FulfillmentShipmentQuantitiesOrderItems
     */
    sku: string;
    /**
     * updated quantity
     * @type {number}
     * @memberof V3FulfillmentShipmentQuantitiesOrderItems
     */
    updatedShipmentQty: number;
}
/**
 * 
 * @export
 * @interface V3ItemsOnholdSearchFilters
 */
export interface V3ItemsOnholdSearchFilters {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | status | Item status | string
     * @type {string}
     * @memberof V3ItemsOnholdSearchFilters
     */
    field?: V3ItemsOnholdSearchFiltersFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof V3ItemsOnholdSearchFilters
     */
    op?: V3ItemsOnholdSearchFiltersOpEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof V3ItemsOnholdSearchFilters
     */
    values?: Array<V3ItemsOnholdSearchFiltersValuesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchFiltersFieldEnum {
    Status = 'status'
}
/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchFiltersOpEnum {
    Equals = 'equals'
}
/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchFiltersValuesEnum {
    Prohibited = 'PROHIBITED',
    InReview = 'IN_REVIEW',
    ActionNeeded = 'ACTION_NEEDED'
}

/**
 * 
 * @export
 * @interface V3ItemsOnholdSearchQuery
 */
export interface V3ItemsOnholdSearchQuery {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | sku | An arbitrary alphanumeric unique ID, seller-specified, identifying each item | string | gtin | Specifies a Global Trade Item Number (GTIN) search. GTIN must be 14 digits. | string
     * @type {string}
     * @memberof V3ItemsOnholdSearchQuery
     */
    field?: V3ItemsOnholdSearchQueryFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof V3ItemsOnholdSearchQuery
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchQueryFieldEnum {
    Sku = 'sku',
    Gtin = 'gtin'
}

/**
 * 
 * @export
 * @interface V3ItemsOnholdSearchSort
 */
export interface V3ItemsOnholdSearchSort {
    /**
     * | Attribute | Description | Data Type | --- | ----------- | ------- | createdAt | when the item is last submitted/updated by Seller | string | updatedAt | when the item is last updated by Seller/Walmart | string |
     * @type {string}
     * @memberof V3ItemsOnholdSearchSort
     */
    field?: V3ItemsOnholdSearchSortFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof V3ItemsOnholdSearchSort
     */
    order?: V3ItemsOnholdSearchSortOrderEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchSortFieldEnum {
    CreatedAt = 'createdAt',
    UpdatedAt = 'updatedAt'
}
/**
    * @export
    * @enum {string}
    */
export enum V3ItemsOnholdSearchSortOrderEnum {
    Asc = 'ASC',
    Desc = 'DESC'
}

/**
 * 
 * @export
 * @interface WercsFeedbackRequest
 */
export interface WercsFeedbackRequest {
    /**
     * 
     * @type {V3ItemsOnholdSearchQuery}
     * @memberof WercsFeedbackRequest
     */
    query?: V3ItemsOnholdSearchQuery;
    /**
     * 
     * @type {Array<V3ItemsOnholdSearchFilters>}
     * @memberof WercsFeedbackRequest
     */
    filters?: Array<V3ItemsOnholdSearchFilters>;
    /**
     * 
     * @type {V3ItemsOnholdSearchSort}
     * @memberof WercsFeedbackRequest
     */
    sort?: V3ItemsOnholdSearchSort;
}

/**
 * FulfillmentApi - axios parameter creator
 * @export
 */
export const FulfillmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipment’s status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
         * @summary Cancel Inbound Shipment
         * @param {string} inboundOrderId Unique ID identifying inbound shipment request
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipment: async (inboundOrderId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inboundOrderId' is not null or undefined
            assertParamExists('cancelShipment', 'inboundOrderId', inboundOrderId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('cancelShipment', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('cancelShipment', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('cancelShipment', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('cancelShipment', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inbound-shipments/{inboundOrderId}`
                .replace(`{${"inboundOrderId"}}`, encodeURIComponent(String(inboundOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is for seller to confirm and accept the estimated carrier shipping charges, when choosing to use WFS Preferred Carrier Program - FedEx parcel to inbound inventory to Walmart fulfillment centers.
         * @summary Confirm Carrier Rate Quote
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject7} inlineObject7 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCarrierRateQuote: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject7: InlineObject7, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject7' is not null or undefined
            assertParamExists('confirmCarrierRateQuote', 'inlineObject7', inlineObject7)
            const localVarPath = `/v3/fulfillment/carrier-rate-quote/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject7, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is used for converting existing Marketplace items to be WFS eligible. Once you’ve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
         * @summary Convert items for WFS
         * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertItemForWfs: async (feedType: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedType' is not null or undefined
            assertParamExists('convertItemForWfs', 'feedType', feedType)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('convertItemForWfs', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('convertItemForWfs', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('convertItemForWfs', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('convertItemForWfs', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.  For the shipments sent by FedEx small parcel, you can ship packages up to 150 lb, up to 108\" in length, and 165\" in length plus girth. (Girth is 2x width + 2x height.). You can ship up to 200 packages per shipment.
         * @summary Create Carrier Rate Quote
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCarrierRateQuotes: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject6' is not null or undefined
            assertParamExists('createCarrierRateQuotes', 'inlineObject6', inlineObject6)
            const localVarPath = `/v3/fulfillment/carrier-rate-quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject6, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label (deprecated)
         * @param {string} shipmentId Unique ID identifying inbound shipment
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundShipmentLabel: async (shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'shipmentId', shipmentId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createInboundShipmentLabel', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/label/{shipmentId}`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to generate WFS Receiving Labels in various formats for receiving purposes. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against.Receiving labels are customizable:  1. 3 size and format options are available to choose from through the LabelSize and LabelFormat fields:   - 4 in. x 6 in. (PDF).   - 4 in. x 3 1/3 in. (PDF).   - 4 in. x 6 in. (ZPL). 2. Provide the type of the label (box or pallet) in the LoadType field and the number of the labels needed in the Count field. 3. Print the WFS receiving label. 4. Affix the WFS receiving labels to the boxes/ pallets.  If none of the above optional inputs are provided, a blank 4 in. x 6 in. PDF format label will be generated. Sellers must work with the warehouse/supplier to provide the required details before sending any Shipments to WFS FCs: 1. Print the WFS receiving label. 2. Fill out the FILL OUT section based on the seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3. Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4. Affix the WFS receiving labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundShipmentLabelV2: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('createInboundShipmentLabelV2', 'inlineObject2', inlineObject2)
            const localVarPath = `/v3/fulfillment/shipment-label`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once you’ve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment. In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
         * @summary Create Inbound Shipment
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipment: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createShipment', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createShipment', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createShipment', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createShipment', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('createShipment', 'inlineObject', inlineObject)
            const localVarPath = `/v3/fulfillment/inbound-shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Get Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} mode Shipment type.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierRateQuote: async (shipmentId: string, mode: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'shipmentId', shipmentId)
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'mode', mode)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getCarrierRateQuote', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/carrier-rate-quotes`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible. 
         * @summary Get Inbound Shipment errors
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundOrderErrors: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getInboundOrderErrors', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInboundOrderErrors', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInboundOrderErrors', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInboundOrderErrors', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inbound-shipment-errors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipmentId'] = shipmentId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
         * @summary Get Inbound Shipment Items
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundShipmentItems: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getInboundShipmentItems', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInboundShipmentItems', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInboundShipmentItems', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInboundShipmentItems', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inbound-shipment-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipmentId'] = shipmentId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
         * @summary Get Shipments
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [status] Current shipment status
         * @param {string} [fromCreateDate] Shipment create date starting range
         * @param {string} [toCreateDate] Shipment create date starting  end range
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundShipments: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, inboundOrderId?: string, shipmentId?: string, status?: string, fromCreateDate?: string, toCreateDate?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getInboundShipments', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInboundShipments', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInboundShipments', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInboundShipments', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/inbound-shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (inboundOrderId !== undefined) {
                localVarQueryParameter['inboundOrderId'] = inboundOrderId;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipmentId'] = shipmentId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromCreateDate !== undefined) {
                localVarQueryParameter['fromCreateDate'] = fromCreateDate;
            }

            if (toCreateDate !== undefined) {
                localVarQueryParameter['toCreateDate'] = toCreateDate;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the information associated with Seller\'s items that are set up on Walmart Fulfillment Services (WFS) platform.
         * @summary Get WFS Inventory Health Report
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryHealthReport: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getInventoryHealthReport', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getInventoryHealthReport', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getInventoryHealthReport', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getInventoryHealthReport', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/report/wfs/getInventoryHealthReport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is for sellers to print carrier shipping label.   To print carrier shipping label, please first specify a Ship Date. Note, carrier allows to select a ship date 10 days in advance.
         * @summary Print Carrier Label
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject8} inlineObject8 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printCarrierLabel: async (shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject8: InlineObject8, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('printCarrierLabel', 'shipmentId', shipmentId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('printCarrierLabel', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('printCarrierLabel', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('printCarrierLabel', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('printCarrierLabel', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject8' is not null or undefined
            assertParamExists('printCarrierLabel', 'inlineObject8', inlineObject8)
            const localVarPath = `/v3/fulfillment/carrier-label/{shipmentId}`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject8, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs’ quantity to 0 – they must cancel the entire Inbound Order. 
         * @summary Update Shipment Quantities 
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipmentQuantity: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('updateShipmentQuantity', 'inlineObject1', inlineObject1)
            const localVarPath = `/v3/fulfillment/shipment-quantities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
         * @summary Update Shipment Tracking
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipmentTrackingDetails: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject3' is not null or undefined
            assertParamExists('updateShipmentTrackingDetails', 'inlineObject3', inlineObject3)
            const localVarPath = `/v3/fulfillment/shipment-tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Cancel Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCarrierRateQuote: async (shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'shipmentId', shipmentId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('voidCarrierRateQuote', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/fulfillment/carrier-rate-quote/{shipmentId}`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to see a list of items that are on hold for hazmat compliance review, including items with an In Review, Action Needed, and Prohibited status. Also use this API to review your Action Needed error descriptions and understand how to correct them for further assessment.
         * @summary Hazmat Items On hold
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wercsFeedback: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('wercsFeedback', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('wercsFeedback', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('wercsFeedback', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('wercsFeedback', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('wercsFeedback', 'accept', accept)
            // verify required parameter 'inlineObject5' is not null or undefined
            assertParamExists('wercsFeedback', 'inlineObject5', inlineObject5)
            const localVarPath = `/v3/items/onhold/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject5, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FulfillmentApi - functional programming interface
 * @export
 */
export const FulfillmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FulfillmentApiAxiosParamCreator(configuration)
    return {
        /**
         * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipment’s status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
         * @summary Cancel Inbound Shipment
         * @param {string} inboundOrderId Unique ID identifying inbound shipment request
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelShipment(inboundOrderId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelShipment(inboundOrderId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is for seller to confirm and accept the estimated carrier shipping charges, when choosing to use WFS Preferred Carrier Program - FedEx parcel to inbound inventory to Walmart fulfillment centers.
         * @summary Confirm Carrier Rate Quote
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject7} inlineObject7 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmCarrierRateQuote(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject7: InlineObject7, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmCarrierRateQuote(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject7, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used for converting existing Marketplace items to be WFS eligible. Once you’ve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
         * @summary Convert items for WFS
         * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertItemForWfs(feedType: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertItemForWfs(feedType, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.  For the shipments sent by FedEx small parcel, you can ship packages up to 150 lb, up to 108\" in length, and 165\" in length plus girth. (Girth is 2x width + 2x height.). You can ship up to 200 packages per shipment.
         * @summary Create Carrier Rate Quote
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCarrierRateQuotes(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCarrierRateQuotes(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject6, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label (deprecated)
         * @param {string} shipmentId Unique ID identifying inbound shipment
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInboundShipmentLabel(shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInboundShipmentLabel(shipmentId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to generate WFS Receiving Labels in various formats for receiving purposes. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against.Receiving labels are customizable:  1. 3 size and format options are available to choose from through the LabelSize and LabelFormat fields:   - 4 in. x 6 in. (PDF).   - 4 in. x 3 1/3 in. (PDF).   - 4 in. x 6 in. (ZPL). 2. Provide the type of the label (box or pallet) in the LoadType field and the number of the labels needed in the Count field. 3. Print the WFS receiving label. 4. Affix the WFS receiving labels to the boxes/ pallets.  If none of the above optional inputs are provided, a blank 4 in. x 6 in. PDF format label will be generated. Sellers must work with the warehouse/supplier to provide the required details before sending any Shipments to WFS FCs: 1. Print the WFS receiving label. 2. Fill out the FILL OUT section based on the seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3. Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4. Affix the WFS receiving labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInboundShipmentLabelV2(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInboundShipmentLabelV2(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject2, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Once you’ve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment. In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
         * @summary Create Inbound Shipment
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipment(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipment(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Get Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} mode Shipment type.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarrierRateQuote(shipmentId: string, mode: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarrierRateQuote(shipmentId, mode, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible. 
         * @summary Get Inbound Shipment errors
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboundOrderErrors(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboundOrderErrors(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, shipmentId, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
         * @summary Get Inbound Shipment Items
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboundShipmentItems(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboundShipmentItems(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, shipmentId, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
         * @summary Get Shipments
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [status] Current shipment status
         * @param {string} [fromCreateDate] Shipment create date starting range
         * @param {string} [toCreateDate] Shipment create date starting  end range
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboundShipments(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, inboundOrderId?: string, shipmentId?: string, status?: string, fromCreateDate?: string, toCreateDate?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboundShipments(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, inboundOrderId, shipmentId, status, fromCreateDate, toCreateDate, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the information associated with Seller\'s items that are set up on Walmart Fulfillment Services (WFS) platform.
         * @summary Get WFS Inventory Health Report
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventoryHealthReport(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventoryHealthReport(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is for sellers to print carrier shipping label.   To print carrier shipping label, please first specify a Ship Date. Note, carrier allows to select a ship date 10 days in advance.
         * @summary Print Carrier Label
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject8} inlineObject8 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printCarrierLabel(shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject8: InlineObject8, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.printCarrierLabel(shipmentId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject8, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs’ quantity to 0 – they must cancel the entire Inbound Order. 
         * @summary Update Shipment Quantities 
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShipmentQuantity(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShipmentQuantity(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject1, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
         * @summary Update Shipment Tracking
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShipmentTrackingDetails(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShipmentTrackingDetails(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject3, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Cancel Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidCarrierRateQuote(shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidCarrierRateQuote(shipmentId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to see a list of items that are on hold for hazmat compliance review, including items with an In Review, Action Needed, and Prohibited status. Also use this API to review your Action Needed error descriptions and understand how to correct them for further assessment.
         * @summary Hazmat Items On hold
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wercsFeedback(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wercsFeedback(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, inlineObject5, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FulfillmentApi - factory interface
 * @export
 */
export const FulfillmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FulfillmentApiFp(configuration)
    return {
        /**
         * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipment’s status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
         * @summary Cancel Inbound Shipment
         * @param {string} inboundOrderId Unique ID identifying inbound shipment request
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipment(inboundOrderId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.cancelShipment(inboundOrderId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is for seller to confirm and accept the estimated carrier shipping charges, when choosing to use WFS Preferred Carrier Program - FedEx parcel to inbound inventory to Walmart fulfillment centers.
         * @summary Confirm Carrier Rate Quote
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject7} inlineObject7 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCarrierRateQuote(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject7: InlineObject7, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.confirmCarrierRateQuote(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject7, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used for converting existing Marketplace items to be WFS eligible. Once you’ve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
         * @summary Convert items for WFS
         * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertItemForWfs(feedType: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, file?: any, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.convertItemForWfs(feedType, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, file, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.  For the shipments sent by FedEx small parcel, you can ship packages up to 150 lb, up to 108\" in length, and 165\" in length plus girth. (Girth is 2x width + 2x height.). You can ship up to 200 packages per shipment.
         * @summary Create Carrier Rate Quote
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCarrierRateQuotes(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.createCarrierRateQuotes(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject6, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label (deprecated)
         * @param {string} shipmentId Unique ID identifying inbound shipment
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundShipmentLabel(shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<string> {
            return localVarFp.createInboundShipmentLabel(shipmentId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to generate WFS Receiving Labels in various formats for receiving purposes. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against.Receiving labels are customizable:  1. 3 size and format options are available to choose from through the LabelSize and LabelFormat fields:   - 4 in. x 6 in. (PDF).   - 4 in. x 3 1/3 in. (PDF).   - 4 in. x 6 in. (ZPL). 2. Provide the type of the label (box or pallet) in the LoadType field and the number of the labels needed in the Count field. 3. Print the WFS receiving label. 4. Affix the WFS receiving labels to the boxes/ pallets.  If none of the above optional inputs are provided, a blank 4 in. x 6 in. PDF format label will be generated. Sellers must work with the warehouse/supplier to provide the required details before sending any Shipments to WFS FCs: 1. Print the WFS receiving label. 2. Fill out the FILL OUT section based on the seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3. Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4. Affix the WFS receiving labels to the boxes/ pallets. 
         * @summary Create Inbound Shipment label
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundShipmentLabelV2(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<string> {
            return localVarFp.createInboundShipmentLabelV2(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject2, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Once you’ve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment. In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
         * @summary Create Inbound Shipment
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipment(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.createShipment(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Get Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} mode Shipment type.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierRateQuote(shipmentId: string, mode: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getCarrierRateQuote(shipmentId, mode, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible. 
         * @summary Get Inbound Shipment errors
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundOrderErrors(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getInboundOrderErrors(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, shipmentId, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
         * @summary Get Inbound Shipment Items
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundShipmentItems(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, shipmentId?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getInboundShipmentItems(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, shipmentId, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
         * @summary Get Shipments
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
         * @param {string} [limit] The number of Purchase Orders to be returned.
         * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
         * @param {string} [shipmentId] Unique ID identifying each shipment.
         * @param {string} [status] Current shipment status
         * @param {string} [fromCreateDate] Shipment create date starting range
         * @param {string} [toCreateDate] Shipment create date starting  end range
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundShipments(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, offset?: string, limit?: string, inboundOrderId?: string, shipmentId?: string, status?: string, fromCreateDate?: string, toCreateDate?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getInboundShipments(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, offset, limit, inboundOrderId, shipmentId, status, fromCreateDate, toCreateDate, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the information associated with Seller\'s items that are set up on Walmart Fulfillment Services (WFS) platform.
         * @summary Get WFS Inventory Health Report
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryHealthReport(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getInventoryHealthReport(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is for sellers to print carrier shipping label.   To print carrier shipping label, please first specify a Ship Date. Note, carrier allows to select a ship date 10 days in advance.
         * @summary Print Carrier Label
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject8} inlineObject8 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printCarrierLabel(shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject8: InlineObject8, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.printCarrierLabel(shipmentId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject8, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs’ quantity to 0 – they must cancel the entire Inbound Order. 
         * @summary Update Shipment Quantities 
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipmentQuantity(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.updateShipmentQuantity(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject1, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
         * @summary Update Shipment Tracking
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipmentTrackingDetails(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.updateShipmentTrackingDetails(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject3, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
         * @summary Cancel Carrier Rate Quote
         * @param {string} shipmentId Unique ID identifying each shipment.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCarrierRateQuote(shipmentId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.voidCarrierRateQuote(shipmentId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to see a list of items that are on hold for hazmat compliance review, including items with an In Review, Action Needed, and Prohibited status. Also use this API to review your Action Needed error descriptions and understand how to correct them for further assessment.
         * @summary Hazmat Items On hold
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wercsFeedback(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.wercsFeedback(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, inlineObject5, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelShipment operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCancelShipmentRequest
 */
export interface FulfillmentApiCancelShipmentRequest {
    /**
     * Unique ID identifying inbound shipment request
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly inboundOrderId: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCancelShipment
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for confirmCarrierRateQuote operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiConfirmCarrierRateQuoteRequest
 */
export interface FulfillmentApiConfirmCarrierRateQuoteRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject7}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly inlineObject7: InlineObject7

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiConfirmCarrierRateQuote
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for convertItemForWfs operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiConvertItemForWfsRequest
 */
export interface FulfillmentApiConvertItemForWfsRequest {
    /**
     * Includes details of each entity in the feed. Do not set this parameter to true.
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly feedType: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly wMCONSUMERCHANNELTYPE?: string

    /**
     * 
     * @type {any}
     * @memberof FulfillmentApiConvertItemForWfs
     */
    readonly file?: any
}

/**
 * Request parameters for createCarrierRateQuotes operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateCarrierRateQuotesRequest
 */
export interface FulfillmentApiCreateCarrierRateQuotesRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject6}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly inlineObject6: InlineObject6

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateCarrierRateQuotes
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createInboundShipmentLabel operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateInboundShipmentLabelRequest
 */
export interface FulfillmentApiCreateInboundShipmentLabelRequest {
    /**
     * Unique ID identifying inbound shipment
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly shipmentId: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabel
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createInboundShipmentLabelV2 operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateInboundShipmentLabelV2Request
 */
export interface FulfillmentApiCreateInboundShipmentLabelV2Request {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject2}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly inlineObject2: InlineObject2

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateInboundShipmentLabelV2
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createShipment operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateShipmentRequest
 */
export interface FulfillmentApiCreateShipmentRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly inlineObject: InlineObject

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiCreateShipment
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getCarrierRateQuote operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetCarrierRateQuoteRequest
 */
export interface FulfillmentApiGetCarrierRateQuoteRequest {
    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly shipmentId: string

    /**
     * Shipment type.
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly mode: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetCarrierRateQuote
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getInboundOrderErrors operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundOrderErrorsRequest
 */
export interface FulfillmentApiGetInboundOrderErrorsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly wMSVCNAME: string

    /**
     * offset is the number of records you wish to skip before selecting records.
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly offset?: string

    /**
     * The number of Purchase Orders to be returned.
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly limit?: string

    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly shipmentId?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetInboundOrderErrors
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getInboundShipmentItems operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundShipmentItemsRequest
 */
export interface FulfillmentApiGetInboundShipmentItemsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly wMSVCNAME: string

    /**
     * offset is the number of records you wish to skip before selecting records.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly offset?: string

    /**
     * The number of Purchase Orders to be returned.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly limit?: string

    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly shipmentId?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipmentItems
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getInboundShipments operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundShipmentsRequest
 */
export interface FulfillmentApiGetInboundShipmentsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly wMSVCNAME: string

    /**
     * offset is the number of records you wish to skip before selecting records.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly offset?: string

    /**
     * The number of Purchase Orders to be returned.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly limit?: string

    /**
     * Unique ID identifying inbound shipment request.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly inboundOrderId?: string

    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly shipmentId?: string

    /**
     * Current shipment status
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly status?: string

    /**
     * Shipment create date starting range
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly fromCreateDate?: string

    /**
     * Shipment create date starting  end range
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly toCreateDate?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetInboundShipments
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getInventoryHealthReport operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInventoryHealthReportRequest
 */
export interface FulfillmentApiGetInventoryHealthReportRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiGetInventoryHealthReport
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for printCarrierLabel operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiPrintCarrierLabelRequest
 */
export interface FulfillmentApiPrintCarrierLabelRequest {
    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly shipmentId: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject8}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly inlineObject8: InlineObject8

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiPrintCarrierLabel
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updateShipmentQuantity operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiUpdateShipmentQuantityRequest
 */
export interface FulfillmentApiUpdateShipmentQuantityRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject1}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly inlineObject1: InlineObject1

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentQuantity
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updateShipmentTrackingDetails operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiUpdateShipmentTrackingDetailsRequest
 */
export interface FulfillmentApiUpdateShipmentTrackingDetailsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject3}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly inlineObject3: InlineObject3

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiUpdateShipmentTrackingDetails
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for voidCarrierRateQuote operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiVoidCarrierRateQuoteRequest
 */
export interface FulfillmentApiVoidCarrierRateQuoteRequest {
    /**
     * Unique ID identifying each shipment.
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly shipmentId: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiVoidCarrierRateQuote
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for wercsFeedback operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiWercsFeedbackRequest
 */
export interface FulfillmentApiWercsFeedbackRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly wMSVCNAME: string

    /**
     * Only supported Media Type : application/json
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly accept: string

    /**
     * 
     * @type {InlineObject5}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly inlineObject5: InlineObject5

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof FulfillmentApiWercsFeedback
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * FulfillmentApi - object-oriented interface
 * @export
 * @class FulfillmentApi
 * @extends {BaseAPI}
 */
export class FulfillmentApi extends BaseAPI {
    /**
     * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipment’s status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
     * @summary Cancel Inbound Shipment
     * @param {FulfillmentApiCancelShipmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public cancelShipment(requestParameters: FulfillmentApiCancelShipmentRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).cancelShipment(requestParameters.inboundOrderId, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is for seller to confirm and accept the estimated carrier shipping charges, when choosing to use WFS Preferred Carrier Program - FedEx parcel to inbound inventory to Walmart fulfillment centers.
     * @summary Confirm Carrier Rate Quote
     * @param {FulfillmentApiConfirmCarrierRateQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public confirmCarrierRateQuote(requestParameters: FulfillmentApiConfirmCarrierRateQuoteRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).confirmCarrierRateQuote(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject7, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used for converting existing Marketplace items to be WFS eligible. Once you’ve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
     * @summary Convert items for WFS
     * @param {FulfillmentApiConvertItemForWfsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public convertItemForWfs(requestParameters: FulfillmentApiConvertItemForWfsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).convertItemForWfs(requestParameters.feedType, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to get the carrier rate quotes for WFS Preferred Carrier Program - FedEx parcel solution, when inbounding seller items from seller pickup point to Walmart fulfillment centers.  For the shipments sent by FedEx small parcel, you can ship packages up to 150 lb, up to 108\" in length, and 165\" in length plus girth. (Girth is 2x width + 2x height.). You can ship up to 200 packages per shipment.
     * @summary Create Carrier Rate Quote
     * @param {FulfillmentApiCreateCarrierRateQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createCarrierRateQuotes(requestParameters: FulfillmentApiCreateCarrierRateQuotesRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).createCarrierRateQuotes(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject6, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets. 
     * @summary Create Inbound Shipment label (deprecated)
     * @param {FulfillmentApiCreateInboundShipmentLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createInboundShipmentLabel(requestParameters: FulfillmentApiCreateInboundShipmentLabelRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).createInboundShipmentLabel(requestParameters.shipmentId, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to generate WFS Receiving Labels in various formats for receiving purposes. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against.Receiving labels are customizable:  1. 3 size and format options are available to choose from through the LabelSize and LabelFormat fields:   - 4 in. x 6 in. (PDF).   - 4 in. x 3 1/3 in. (PDF).   - 4 in. x 6 in. (ZPL). 2. Provide the type of the label (box or pallet) in the LoadType field and the number of the labels needed in the Count field. 3. Print the WFS receiving label. 4. Affix the WFS receiving labels to the boxes/ pallets.  If none of the above optional inputs are provided, a blank 4 in. x 6 in. PDF format label will be generated. Sellers must work with the warehouse/supplier to provide the required details before sending any Shipments to WFS FCs: 1. Print the WFS receiving label. 2. Fill out the FILL OUT section based on the seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3. Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4. Affix the WFS receiving labels to the boxes/ pallets. 
     * @summary Create Inbound Shipment label
     * @param {FulfillmentApiCreateInboundShipmentLabelV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createInboundShipmentLabelV2(requestParameters: FulfillmentApiCreateInboundShipmentLabelV2Request, options?: any) {
        return FulfillmentApiFp(this.configuration).createInboundShipmentLabelV2(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject2, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once you’ve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment. In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
     * @summary Create Inbound Shipment
     * @param {FulfillmentApiCreateShipmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public createShipment(requestParameters: FulfillmentApiCreateShipmentRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).createShipment(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
     * @summary Get Carrier Rate Quote
     * @param {FulfillmentApiGetCarrierRateQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getCarrierRateQuote(requestParameters: FulfillmentApiGetCarrierRateQuoteRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getCarrierRateQuote(requestParameters.shipmentId, requestParameters.mode, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible. 
     * @summary Get Inbound Shipment errors
     * @param {FulfillmentApiGetInboundOrderErrorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getInboundOrderErrors(requestParameters: FulfillmentApiGetInboundOrderErrorsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getInboundOrderErrors(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.offset, requestParameters.limit, requestParameters.shipmentId, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
     * @summary Get Inbound Shipment Items
     * @param {FulfillmentApiGetInboundShipmentItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getInboundShipmentItems(requestParameters: FulfillmentApiGetInboundShipmentItemsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getInboundShipmentItems(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.offset, requestParameters.limit, requestParameters.shipmentId, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
     * @summary Get Shipments
     * @param {FulfillmentApiGetInboundShipmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getInboundShipments(requestParameters: FulfillmentApiGetInboundShipmentsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getInboundShipments(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.offset, requestParameters.limit, requestParameters.inboundOrderId, requestParameters.shipmentId, requestParameters.status, requestParameters.fromCreateDate, requestParameters.toCreateDate, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the information associated with Seller\'s items that are set up on Walmart Fulfillment Services (WFS) platform.
     * @summary Get WFS Inventory Health Report
     * @param {FulfillmentApiGetInventoryHealthReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getInventoryHealthReport(requestParameters: FulfillmentApiGetInventoryHealthReportRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).getInventoryHealthReport(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is for sellers to print carrier shipping label.   To print carrier shipping label, please first specify a Ship Date. Note, carrier allows to select a ship date 10 days in advance.
     * @summary Print Carrier Label
     * @param {FulfillmentApiPrintCarrierLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public printCarrierLabel(requestParameters: FulfillmentApiPrintCarrierLabelRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).printCarrierLabel(requestParameters.shipmentId, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject8, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs’ quantity to 0 – they must cancel the entire Inbound Order. 
     * @summary Update Shipment Quantities 
     * @param {FulfillmentApiUpdateShipmentQuantityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public updateShipmentQuantity(requestParameters: FulfillmentApiUpdateShipmentQuantityRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).updateShipmentQuantity(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject1, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
     * @summary Update Shipment Tracking
     * @param {FulfillmentApiUpdateShipmentTrackingDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public updateShipmentTrackingDetails(requestParameters: FulfillmentApiUpdateShipmentTrackingDetailsRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).updateShipmentTrackingDetails(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject3, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The purpose of this service is for seller to void the carrier shipping charges, within 24 hours after the estimated carrier charges have been accepted by the seller.
     * @summary Cancel Carrier Rate Quote
     * @param {FulfillmentApiVoidCarrierRateQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public voidCarrierRateQuote(requestParameters: FulfillmentApiVoidCarrierRateQuoteRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).voidCarrierRateQuote(requestParameters.shipmentId, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to see a list of items that are on hold for hazmat compliance review, including items with an In Review, Action Needed, and Prohibited status. Also use this API to review your Action Needed error descriptions and understand how to correct them for further assessment.
     * @summary Hazmat Items On hold
     * @param {FulfillmentApiWercsFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public wercsFeedback(requestParameters: FulfillmentApiWercsFeedbackRequest, options?: any) {
        return FulfillmentApiFp(this.configuration).wercsFeedback(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.accept, requestParameters.inlineObject5, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


