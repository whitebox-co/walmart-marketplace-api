/* tslint:disable */
/* eslint-disable */
/**
 * Price Management
 * The price is a fundamental building block for your listing on Walmart.com. You can use the price management APIs to set up and manage the price for a given item
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CapProgramResponse
 */
export interface CapProgramResponse {
    /**
     * A unique ID that a user or seller uses for a marketplace.
     * @type {string}
     * @memberof CapProgramResponse
     */
    martId?: string;
    /**
     * 
     * @type {InlineObject6}
     * @memberof CapProgramResponse
     */
    statusInfo?: InlineObject6;
}
/**
 * 
 * @export
 * @interface Cause
 */
export interface Cause {
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Cause
     */
    description?: string;
}
/**
 * This is applicable only for promotions
 * @export
 * @interface ComparisonPrice
 */
export interface ComparisonPrice {
    /**
     * 
     * @type {string}
     * @memberof ComparisonPrice
     */
    currency?: ComparisonPriceCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof ComparisonPrice
     */
    amount?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ComparisonPriceCurrencyEnum {
    Usd = 'USD',
    Cad = 'CAD'
}

/**
 * 
 * @export
 * @interface CurrentPrice
 */
export interface CurrentPrice {
    /**
     * 
     * @type {string}
     * @memberof CurrentPrice
     */
    currency?: CurrentPriceCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof CurrentPrice
     */
    amount?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum CurrentPriceCurrencyEnum {
    Usd = 'USD',
    Cad = 'CAD'
}

/**
 * 
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseDto
     */
    errorMessage?: string;
}
/**
 * 
 * @export
 * @interface FeedId
 */
export interface FeedId {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
     * @type {string}
     * @memberof FeedId
     */
    feedId?: string;
    /**
     * 
     * @type {object}
     * @memberof FeedId
     */
    additionalAttributes?: object | null;
    /**
     * 
     * @type {object}
     * @memberof FeedId
     */
    errors?: object | null;
}
/**
 * 
 * @export
 * @interface FeedItemsHeaderRequestDTO
 */
export interface FeedItemsHeaderRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof FeedItemsHeaderRequestDTO
     */
    processMode?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedItemsHeaderRequestDTO
     */
    subset?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedItemsHeaderRequestDTO
     */
    mart?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedItemsHeaderRequestDTO
     */
    sellingChannel?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedItemsHeaderRequestDTO
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedItemsHeaderRequestDTO
     */
    locale?: string;
}
/**
 * 
 * @export
 * @interface FeedItemsRequestDTO
 */
export interface FeedItemsRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof FeedItemsRequestDTO
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedItemsRequestDTO
     */
    repricerStrategy?: string;
    /**
     * 
     * @type {number}
     * @memberof FeedItemsRequestDTO
     */
    minimumSellerAllowedPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedItemsRequestDTO
     */
    maximumSellerAllowedPrice?: number;
}
/**
 * 
 * @export
 * @interface FeedUploadRequestDTO
 */
export interface FeedUploadRequestDTO {
    /**
     * 
     * @type {V3RepricerFeedsItemFeedHeader}
     * @memberof FeedUploadRequestDTO
     */
    ItemFeedHeader?: V3RepricerFeedsItemFeedHeader;
    /**
     * 
     * @type {Array<V3RepricerFeedsItem>}
     * @memberof FeedUploadRequestDTO
     */
    Item?: Array<V3RepricerFeedsItem>;
}
/**
 * 
 * @export
 * @interface FeedUploadResponseDTO
 */
export interface FeedUploadResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof FeedUploadResponseDTO
     */
    feedId?: string;
}
/**
 * 
 * @export
 * @interface GatewayError
 */
export interface GatewayError {
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    severity?: GatewayErrorSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    category?: GatewayErrorCategoryEnum;
    /**
     * 
     * @type {Array<InlineResponse2004Causes>}
     * @memberof GatewayError
     */
    causes?: Array<InlineResponse2004Causes>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof GatewayError
     */
    errorIdentifiers?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    component?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    gatewayErrorCategory?: GatewayErrorGatewayErrorCategoryEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GatewayErrorSeverityEnum {
    Info = 'INFO',
    Warn = 'WARN',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum GatewayErrorCategoryEnum {
    Application = 'APPLICATION',
    System = 'SYSTEM',
    Request = 'REQUEST',
    Data = 'DATA'
}
/**
    * @export
    * @enum {string}
    */
export enum GatewayErrorGatewayErrorCategoryEnum {
    InternalDataError = 'INTERNAL_DATA_ERROR',
    ExternalDataError = 'EXTERNAL_DATA_ERROR',
    SystemError = 'SYSTEM_ERROR'
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Name of the Strategy Collection
     * @type {string}
     * @memberof InlineObject
     */
    repricerStrategy?: string;
    /**
     * Status of the Strategy Collection
     * @type {boolean}
     * @memberof InlineObject
     */
    enabled?: boolean;
    /**
     * Status of item on promotions to be enable on repricer
     * @type {boolean}
     * @memberof InlineObject
     */
    enableRepricerForPromotion?: boolean;
    /**
     * Strategies
     * @type {Array<V3RepricerStrategyStrategyCollectionIdStrategies>}
     * @memberof InlineObject
     */
    strategies?: Array<V3RepricerStrategyStrategyCollectionIdStrategies>;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * selected skus
     * @type {Array<string>}
     * @memberof InlineObject1
     */
    skus: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof InlineObject2
     */
    offerId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    sku: string;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof InlineObject2
     */
    replaceAll?: InlineObject2ReplaceAllEnum;
    /**
     * 
     * @type {Array<V3PricePricing>}
     * @memberof InlineObject2
     */
    pricing: Array<V3PricePricing>;
    /**
     * 
     * @type {object}
     * @memberof InlineObject2
     */
    definitions?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject2ReplaceAllEnum {
    True = 'true',
    False = 'false'
}

/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {V3RepricerFeedsItemFeedHeader}
     * @memberof InlineObject3
     */
    ItemFeedHeader?: V3RepricerFeedsItemFeedHeader;
    /**
     * 
     * @type {Array<V3RepricerFeedsItem>}
     * @memberof InlineObject3
     */
    Item?: Array<V3RepricerFeedsItem>;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * Name of the Strategy Collection
     * @type {string}
     * @memberof InlineObject4
     */
    repricerStrategy?: string;
    /**
     * Status of the Strategy Collection
     * @type {boolean}
     * @memberof InlineObject4
     */
    enabled?: boolean;
    /**
     * Status of item on promotions to be enable on repricer
     * @type {boolean}
     * @memberof InlineObject4
     */
    enableRepricerForPromotion?: boolean;
    /**
     * Strategies
     * @type {Array<V3RepricerStrategyStrategyCollectionIdStrategies>}
     * @memberof InlineObject4
     */
    strategies?: Array<V3RepricerStrategyStrategyCollectionIdStrategies>;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * A Boolean parameter that allows all sellers to completely enroll in or out of the Competitive Price Adjustment program
     * @type {boolean}
     * @memberof InlineObject6
     */
    subsidyEnrolled?: boolean;
    /**
     * A Boolean parameter that determines whether offer level subsidy setting override seller level subsidy setting
     * @type {boolean}
     * @memberof InlineObject6
     */
    subsidyPreference?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    repricerStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    strategyCollectionId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    enableRepricerForPromotion?: boolean;
    /**
     * 
     * @type {Array<V3RepricerStrategyStrategyCollectionIdStrategies>}
     * @memberof InlineResponse200
     */
    strategies?: Array<V3RepricerStrategyStrategyCollectionIdStrategies>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    totalItems?: number;
    /**
     * 
     * @type {Array<InlineResponse2002Items>}
     * @memberof InlineResponse2002
     */
    items?: Array<InlineResponse2002Items>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Items
 */
export interface InlineResponse2002Items {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Items
     */
    productName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Items
     */
    skuId?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Items
     */
    sellerPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Items
     */
    floorPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Items
     */
    incentiveLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Items
     */
    incentiveStartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Items
     */
    incentiveEndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Items
     */
    shippingPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Items
     */
    competitivePrice?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Items
     */
    competitorShippingPrice?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Items
     */
    competitorUrl?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    feedId?: string;
    /**
     * 
     * @type {Array<InlineResponse2003Errors>}
     * @memberof InlineResponse2003
     */
    errors?: Array<InlineResponse2003Errors>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003Errors
 */
export interface InlineResponse2003Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Errors
     */
    errorMessage?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<InlineResponse2004Errors>}
     * @memberof InlineResponse2004
     */
    errors?: Array<InlineResponse2004Errors>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    statusCode?: number;
    /**
     * Marketplace name. Example: Walmart-US
     * @type {string}
     * @memberof InlineResponse2004
     */
    mart?: string;
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InlineResponse2004
     */
    sku?: string;
    /**
     * A message of acknowledgement for a price update
     * @type {string}
     * @memberof InlineResponse2004
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Causes
 */
export interface InlineResponse2004Causes {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Causes
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Causes
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Causes
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Causes
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Errors
 */
export interface InlineResponse2004Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    severity?: InlineResponse2004ErrorsSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    category?: InlineResponse2004ErrorsCategoryEnum;
    /**
     * 
     * @type {Array<InlineResponse2004Causes>}
     * @memberof InlineResponse2004Errors
     */
    causes?: Array<InlineResponse2004Causes>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse2004Errors
     */
    errorIdentifiers?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    component?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Errors
     */
    gatewayErrorCategory?: InlineResponse2004ErrorsGatewayErrorCategoryEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2004ErrorsSeverityEnum {
    Info = 'INFO',
    Warn = 'WARN',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2004ErrorsCategoryEnum {
    Application = 'APPLICATION',
    System = 'SYSTEM',
    Request = 'REQUEST',
    Data = 'DATA'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2004ErrorsGatewayErrorCategoryEnum {
    InternalDataError = 'INTERNAL_DATA_ERROR',
    ExternalDataError = 'EXTERNAL_DATA_ERROR',
    SystemError = 'SYSTEM_ERROR'
}

/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    feedId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
     * @type {string}
     * @memberof InlineResponse2006
     */
    feedId?: string;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2006
     */
    additionalAttributes?: object | null;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2006
     */
    errors?: object | null;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * A unique ID that a user or seller uses for a marketplace.
     * @type {string}
     * @memberof InlineResponse2007
     */
    martId?: string;
    /**
     * 
     * @type {InlineObject6}
     * @memberof InlineResponse2007
     */
    statusInfo?: InlineObject6;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    totalElements?: number;
    /**
     * 
     * @type {Array<InlineResponse2008StrategyCollections>}
     * @memberof InlineResponse2008
     */
    strategyCollections?: Array<InlineResponse2008StrategyCollections>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008StrategyCollections
 */
export interface InlineResponse2008StrategyCollections {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008StrategyCollections
     */
    repricerStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008StrategyCollections
     */
    strategyCollectionId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008StrategyCollections
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008StrategyCollections
     */
    assignedCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008StrategyCollections
     */
    enableRepricerForPromotion?: boolean;
    /**
     * 
     * @type {Array<V3RepricerStrategyStrategyCollectionIdStrategies>}
     * @memberof InlineResponse2008StrategyCollections
     */
    strategies?: Array<V3RepricerStrategyStrategyCollectionIdStrategies>;
}
/**
 * 
 * @export
 * @interface ItemPriceResponse
 */
export interface ItemPriceResponse {
    /**
     * 
     * @type {Array<InlineResponse2004Errors>}
     * @memberof ItemPriceResponse
     */
    errors?: Array<InlineResponse2004Errors>;
    /**
     * 
     * @type {number}
     * @memberof ItemPriceResponse
     */
    statusCode?: number;
    /**
     * Marketplace name. Example: Walmart-US
     * @type {string}
     * @memberof ItemPriceResponse
     */
    mart?: string;
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof ItemPriceResponse
     */
    sku?: string;
    /**
     * A message of acknowledgement for a price update
     * @type {string}
     * @memberof ItemPriceResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof Price
     */
    offerId?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    sku: string;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof Price
     */
    replaceAll?: PriceReplaceAllEnum;
    /**
     * 
     * @type {Array<V3PricePricing>}
     * @memberof Price
     */
    pricing: Array<V3PricePricing>;
    /**
     * 
     * @type {object}
     * @memberof Price
     */
    definitions?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum PriceReplaceAllEnum {
    True = 'true',
    False = 'false'
}

/**
 * 
 * @export
 * @interface Pricing
 */
export interface Pricing {
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof Pricing
     */
    effectiveDate?: string;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof Pricing
     */
    expirationDate?: string;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof Pricing
     */
    promoId?: string;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof Pricing
     */
    processMode?: PricingProcessModeEnum;
    /**
     * This is applicable only for both promotions and price
     * @type {string}
     * @memberof Pricing
     */
    currentPriceType: PricingCurrentPriceTypeEnum;
    /**
     * 
     * @type {V3PriceCurrentPrice}
     * @memberof Pricing
     */
    currentPrice: V3PriceCurrentPrice;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof Pricing
     */
    comparisonPriceType?: PricingComparisonPriceTypeEnum;
    /**
     * 
     * @type {V3PriceComparisonPrice}
     * @memberof Pricing
     */
    comparisonPrice?: V3PriceComparisonPrice;
    /**
     * Represent promo placement. This is applicable only for promotions
     * @type {string}
     * @memberof Pricing
     */
    priceDisplayCodes?: PricingPriceDisplayCodesEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PricingProcessModeEnum {
    Upsert = 'UPSERT',
    Delete = 'DELETE'
}
/**
    * @export
    * @enum {string}
    */
export enum PricingCurrentPriceTypeEnum {
    Base = 'BASE',
    Reduced = 'REDUCED',
    Clearance = 'CLEARANCE'
}
/**
    * @export
    * @enum {string}
    */
export enum PricingComparisonPriceTypeEnum {
    Base = 'BASE'
}
/**
    * @export
    * @enum {string}
    */
export enum PricingPriceDisplayCodesEnum {
    Cart = 'CART',
    Checkout = 'CHECKOUT'
}

/**
 * 
 * @export
 * @interface RepricerEntityCollectionResponse
 */
export interface RepricerEntityCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof RepricerEntityCollectionResponse
     */
    totalElements?: number;
    /**
     * 
     * @type {Array<InlineResponse2008StrategyCollections>}
     * @memberof RepricerEntityCollectionResponse
     */
    strategyCollections?: Array<InlineResponse2008StrategyCollections>;
}
/**
 * 
 * @export
 * @interface RepricerEntityDeleteResponse
 */
export interface RepricerEntityDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof RepricerEntityDeleteResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface RepricerEntityGetResponse
 */
export interface RepricerEntityGetResponse {
    /**
     * 
     * @type {string}
     * @memberof RepricerEntityGetResponse
     */
    repricerStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof RepricerEntityGetResponse
     */
    strategyCollectionId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RepricerEntityGetResponse
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RepricerEntityGetResponse
     */
    assignedCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RepricerEntityGetResponse
     */
    enableRepricerForPromotion?: boolean;
    /**
     * 
     * @type {Array<V3RepricerStrategyStrategyCollectionIdStrategies>}
     * @memberof RepricerEntityGetResponse
     */
    strategies?: Array<V3RepricerStrategyStrategyCollectionIdStrategies>;
}
/**
 * 
 * @export
 * @interface RepricerEntityRequest
 */
export interface RepricerEntityRequest {
    /**
     * Name of the Strategy Collection
     * @type {string}
     * @memberof RepricerEntityRequest
     */
    repricerStrategy?: string;
    /**
     * Status of the Strategy Collection
     * @type {boolean}
     * @memberof RepricerEntityRequest
     */
    enabled?: boolean;
    /**
     * Status of item on promotions to be enable on repricer
     * @type {boolean}
     * @memberof RepricerEntityRequest
     */
    enableRepricerForPromotion?: boolean;
    /**
     * Strategies
     * @type {Array<V3RepricerStrategyStrategyCollectionIdStrategies>}
     * @memberof RepricerEntityRequest
     */
    strategies?: Array<V3RepricerStrategyStrategyCollectionIdStrategies>;
}
/**
 * 
 * @export
 * @interface RepricerEntityResponse
 */
export interface RepricerEntityResponse {
    /**
     * 
     * @type {string}
     * @memberof RepricerEntityResponse
     */
    repricerStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof RepricerEntityResponse
     */
    strategyCollectionId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RepricerEntityResponse
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RepricerEntityResponse
     */
    enableRepricerForPromotion?: boolean;
    /**
     * 
     * @type {Array<V3RepricerStrategyStrategyCollectionIdStrategies>}
     * @memberof RepricerEntityResponse
     */
    strategies?: Array<V3RepricerStrategyStrategyCollectionIdStrategies>;
}
/**
 * 
 * @export
 * @interface RepricerIncentiveCollectionResponse
 */
export interface RepricerIncentiveCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof RepricerIncentiveCollectionResponse
     */
    totalItems?: number;
    /**
     * 
     * @type {Array<InlineResponse2002Items>}
     * @memberof RepricerIncentiveCollectionResponse
     */
    items?: Array<InlineResponse2002Items>;
}
/**
 * 
 * @export
 * @interface RepricerIncentiveItems
 */
export interface RepricerIncentiveItems {
    /**
     * 
     * @type {string}
     * @memberof RepricerIncentiveItems
     */
    productName?: string;
    /**
     * 
     * @type {string}
     * @memberof RepricerIncentiveItems
     */
    skuId?: string;
    /**
     * 
     * @type {number}
     * @memberof RepricerIncentiveItems
     */
    sellerPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof RepricerIncentiveItems
     */
    floorPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof RepricerIncentiveItems
     */
    incentiveLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof RepricerIncentiveItems
     */
    incentiveStartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RepricerIncentiveItems
     */
    incentiveEndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof RepricerIncentiveItems
     */
    shippingPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof RepricerIncentiveItems
     */
    competitivePrice?: number;
    /**
     * 
     * @type {number}
     * @memberof RepricerIncentiveItems
     */
    competitorShippingPrice?: number;
    /**
     * 
     * @type {string}
     * @memberof RepricerIncentiveItems
     */
    competitorUrl?: string;
}
/**
 * 
 * @export
 * @interface RepricerStrategyType
 */
export interface RepricerStrategyType {
    /**
     * 
     * @type {string}
     * @memberof RepricerStrategyType
     */
    strategyType?: RepricerStrategyTypeStrategyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RepricerStrategyType
     */
    adjustmentType?: RepricerStrategyTypeAdjustmentTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof RepricerStrategyType
     */
    adjustmentValue?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum RepricerStrategyTypeStrategyTypeEnum {
    BuyBoxPrice = 'Buy Box Price',
    ExternalPrice = 'External Price',
    CompetitivePrice = 'Competitive Price'
}
/**
    * @export
    * @enum {string}
    */
export enum RepricerStrategyTypeAdjustmentTypeEnum {
    Unit = 'UNIT',
    Percentage = 'PERCENTAGE'
}

/**
 * 
 * @export
 * @interface StatusInfo
 */
export interface StatusInfo {
    /**
     * A Boolean parameter that allows all sellers to completely enroll in or out of the Competitive Price Adjustment program
     * @type {boolean}
     * @memberof StatusInfo
     */
    subsidyEnrolled?: boolean;
    /**
     * A Boolean parameter that determines whether offer level subsidy setting override seller level subsidy setting
     * @type {boolean}
     * @memberof StatusInfo
     */
    subsidyPreference?: boolean;
}
/**
 * 
 * @export
 * @interface StrategyDetailsRequestDTO
 */
export interface StrategyDetailsRequestDTO {
    /**
     * 
     * @type {V3RepricerFeedsStrategy}
     * @memberof StrategyDetailsRequestDTO
     */
    Strategy?: V3RepricerFeedsStrategy;
}
/**
 * 
 * @export
 * @interface UpdateRepricerIncentiveRequest
 */
export interface UpdateRepricerIncentiveRequest {
    /**
     * selected skus
     * @type {Array<string>}
     * @memberof UpdateRepricerIncentiveRequest
     */
    skus: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateRepricerIncentiveResponse
 */
export interface UpdateRepricerIncentiveResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateRepricerIncentiveResponse
     */
    feedId?: string;
    /**
     * 
     * @type {Array<InlineResponse2003Errors>}
     * @memberof UpdateRepricerIncentiveResponse
     */
    errors?: Array<InlineResponse2003Errors>;
}
/**
 * This is applicable only for promotions
 * @export
 * @interface V3PriceComparisonPrice
 */
export interface V3PriceComparisonPrice {
    /**
     * 
     * @type {string}
     * @memberof V3PriceComparisonPrice
     */
    currency?: V3PriceComparisonPriceCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof V3PriceComparisonPrice
     */
    amount?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum V3PriceComparisonPriceCurrencyEnum {
    Usd = 'USD',
    Cad = 'CAD'
}

/**
 * 
 * @export
 * @interface V3PriceCurrentPrice
 */
export interface V3PriceCurrentPrice {
    /**
     * 
     * @type {string}
     * @memberof V3PriceCurrentPrice
     */
    currency?: V3PriceCurrentPriceCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof V3PriceCurrentPrice
     */
    amount?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum V3PriceCurrentPriceCurrencyEnum {
    Usd = 'USD',
    Cad = 'CAD'
}

/**
 * 
 * @export
 * @interface V3PricePricing
 */
export interface V3PricePricing {
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof V3PricePricing
     */
    effectiveDate?: string;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof V3PricePricing
     */
    expirationDate?: string;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof V3PricePricing
     */
    promoId?: string;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof V3PricePricing
     */
    processMode?: V3PricePricingProcessModeEnum;
    /**
     * This is applicable only for both promotions and price
     * @type {string}
     * @memberof V3PricePricing
     */
    currentPriceType: V3PricePricingCurrentPriceTypeEnum;
    /**
     * 
     * @type {V3PriceCurrentPrice}
     * @memberof V3PricePricing
     */
    currentPrice: V3PriceCurrentPrice;
    /**
     * This is applicable only for promotions
     * @type {string}
     * @memberof V3PricePricing
     */
    comparisonPriceType?: V3PricePricingComparisonPriceTypeEnum;
    /**
     * 
     * @type {V3PriceComparisonPrice}
     * @memberof V3PricePricing
     */
    comparisonPrice?: V3PriceComparisonPrice;
    /**
     * Represent promo placement. This is applicable only for promotions
     * @type {string}
     * @memberof V3PricePricing
     */
    priceDisplayCodes?: V3PricePricingPriceDisplayCodesEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum V3PricePricingProcessModeEnum {
    Upsert = 'UPSERT',
    Delete = 'DELETE'
}
/**
    * @export
    * @enum {string}
    */
export enum V3PricePricingCurrentPriceTypeEnum {
    Base = 'BASE',
    Reduced = 'REDUCED',
    Clearance = 'CLEARANCE'
}
/**
    * @export
    * @enum {string}
    */
export enum V3PricePricingComparisonPriceTypeEnum {
    Base = 'BASE'
}
/**
    * @export
    * @enum {string}
    */
export enum V3PricePricingPriceDisplayCodesEnum {
    Cart = 'CART',
    Checkout = 'CHECKOUT'
}

/**
 * 
 * @export
 * @interface V3RepricerFeedsItem
 */
export interface V3RepricerFeedsItem {
    /**
     * 
     * @type {V3RepricerFeedsStrategy}
     * @memberof V3RepricerFeedsItem
     */
    Strategy?: V3RepricerFeedsStrategy;
}
/**
 * 
 * @export
 * @interface V3RepricerFeedsItemFeedHeader
 */
export interface V3RepricerFeedsItemFeedHeader {
    /**
     * 
     * @type {string}
     * @memberof V3RepricerFeedsItemFeedHeader
     */
    processMode?: string;
    /**
     * 
     * @type {string}
     * @memberof V3RepricerFeedsItemFeedHeader
     */
    subset?: string;
    /**
     * 
     * @type {string}
     * @memberof V3RepricerFeedsItemFeedHeader
     */
    mart?: string;
    /**
     * 
     * @type {string}
     * @memberof V3RepricerFeedsItemFeedHeader
     */
    sellingChannel?: string;
    /**
     * 
     * @type {string}
     * @memberof V3RepricerFeedsItemFeedHeader
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof V3RepricerFeedsItemFeedHeader
     */
    locale?: string;
}
/**
 * 
 * @export
 * @interface V3RepricerFeedsStrategy
 */
export interface V3RepricerFeedsStrategy {
    /**
     * 
     * @type {string}
     * @memberof V3RepricerFeedsStrategy
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof V3RepricerFeedsStrategy
     */
    repricerStrategy?: string;
    /**
     * 
     * @type {number}
     * @memberof V3RepricerFeedsStrategy
     */
    minimumSellerAllowedPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof V3RepricerFeedsStrategy
     */
    maximumSellerAllowedPrice?: number;
}
/**
 * 
 * @export
 * @interface V3RepricerStrategyStrategyCollectionIdStrategies
 */
export interface V3RepricerStrategyStrategyCollectionIdStrategies {
    /**
     * 
     * @type {string}
     * @memberof V3RepricerStrategyStrategyCollectionIdStrategies
     */
    strategyType?: V3RepricerStrategyStrategyCollectionIdStrategiesStrategyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V3RepricerStrategyStrategyCollectionIdStrategies
     */
    adjustmentType?: V3RepricerStrategyStrategyCollectionIdStrategiesAdjustmentTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof V3RepricerStrategyStrategyCollectionIdStrategies
     */
    adjustmentValue?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum V3RepricerStrategyStrategyCollectionIdStrategiesStrategyTypeEnum {
    BuyBoxPrice = 'Buy Box Price',
    ExternalPrice = 'External Price',
    CompetitivePrice = 'Competitive Price'
}
/**
    * @export
    * @enum {string}
    */
export enum V3RepricerStrategyStrategyCollectionIdStrategiesAdjustmentTypeEnum {
    Unit = 'UNIT',
    Percentage = 'PERCENTAGE'
}


/**
 * PricesApi - axios parameter creator
 * @export
 */
export const PricesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new strategy for the seller
         * @summary Create Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStrategy: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createStrategy', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createStrategy', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createStrategy', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject4' is not null or undefined
            assertParamExists('createStrategy', 'inlineObject4', inlineObject4)
            const localVarPath = `/v3/repricer/strategy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the strategy
         * @summary Delete Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStrategy: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('deleteStrategy', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('deleteStrategy', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('deleteStrategy', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/repricer/strategy/{strategyCollectionId}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/Remove one or more items from a strategy
         * @summary Assign/Unassign items to/from Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepricerFeed: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getRepricerFeed', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getRepricerFeed', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getRepricerFeed', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject3' is not null or undefined
            assertParamExists('getRepricerFeed', 'inlineObject3', inlineObject3)
            const localVarPath = `/v3/repricerFeeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of incentive items
         * @summary List of Incentive Items
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {number} [limit] Specify number of items to return.
         * @param {number} [offset] Specify the offset of item list to be returned.
         * @param {string} [sortBy] Specify the sort criteria for items. Examples of the allowed values are INCENTIVE_END_DATE or INCENTIVE_LIMIT
         * @param {string} [sortOrder] Specify the sort order for given sort criteria. Examples of the allowed values are ASC or DESC
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepricerIncentive: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getRepricerIncentive', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getRepricerIncentive', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getRepricerIncentive', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/repricer/incentive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of strategies
         * @summary List of Repricer Strategies
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategies: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getStrategies', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getStrategies', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getStrategies', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/repricer/strategies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API helps Sellers to completely opt-in or opt-out from CAP program.  If the subsidyEnrolled value = \"true\", the Seller enrolls in the CAP program. All eligible SKUs (current and future) are by default opt-in. Seller should use the SKU opt-in/opt-out API to opt-out individual items.  If the subsidyEnrolled value = \"false\", the Seller stops participating in the CAP program and all eligible SKUs (current and future) are opt-out of the CAP program.
         * @summary Set up CAP SKU All
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optCapProgramInPrice: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('optCapProgramInPrice', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('optCapProgramInPrice', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('optCapProgramInPrice', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject6' is not null or undefined
            assertParamExists('optCapProgramInPrice', 'inlineObject6', inlineObject6)
            const localVarPath = `/v3/cppreference`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject6, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates prices in bulk.  In one Feed you can update up to 10,000 items in bulk. To ensure optimal Feed processing time, we recommend sending no more than 1000 items in one Feed and keeping the Feed sizes below 10 MB.  The price sequence guarantee is observed by the bulk price update functionality, subject to the following rules:  The timestamp used to determine precedence is passed in the request headers. All price updates in the feed are considered to have the same timestamp. The timestamp in the XML file is used only for auditing. You can send a single SKU multiple times in one Feed. If a SKU is repeated in a Feed, the price will be set for that SKU on Walmart.com, but there is no guarantee as to which SKU\'s price within that feed will be used. This API should be used in preference to the update a price. It should be called no sooner than 24 hours after a new item is set up and a wpid (Walmart Part ID) is available. Thereafter, the bulk price update has an service level agreement (SLA) of 15 minutes.  After the update is submitted, wait for at least five minutes before verifying whether the bulk price update was successful. Individual SKU price update success or failure is only available after the entire feed is processed.  If a SKU\'s price update fails (for example, multiple price updates were sent for the same SKU in a single feed), an error will be returned.
         * @summary Update bulk prices (Multiple)
         * @param {'price' | 'CPT_SELLER_ELIGIBILITY'} feedType The feed Type
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {any} file Feed file to upload
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceBulkUploads: async (feedType: 'price' | 'CPT_SELLER_ELIGIBILITY', wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, file: any, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedType' is not null or undefined
            assertParamExists('priceBulkUploads', 'feedType', feedType)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('priceBulkUploads', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('priceBulkUploads', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('priceBulkUploads', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('priceBulkUploads', 'file', file)
            const localVarPath = `/v3/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the regular price for a given item.
         * @summary Update a price
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrice: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updatePrice', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updatePrice', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updatePrice', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('updatePrice', 'inlineObject2', inlineObject2)
            const localVarPath = `/v3/price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns incentive items to the default price incentives strategy, ‘Match Competitive Price’
         * @summary Assign Incentive items to Repricer
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepricerIncentive: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateRepricerIncentive', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateRepricerIncentive', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateRepricerIncentive', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('updateRepricerIncentive', 'inlineObject1', inlineObject1)
            const localVarPath = `/v3/repricer/incentive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the existing strategy
         * @summary Update Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStrategy: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateStrategy', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateStrategy', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateStrategy', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('updateStrategy', 'inlineObject', inlineObject)
            const localVarPath = `/v3/repricer/strategy/{strategyCollectionId}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricesApi - functional programming interface
 * @export
 */
export const PricesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new strategy for the seller
         * @summary Create Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStrategy(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStrategy(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject4, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the strategy
         * @summary Delete Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStrategy(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStrategy(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add/Remove one or more items from a strategy
         * @summary Assign/Unassign items to/from Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepricerFeed(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepricerFeed(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject3, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of incentive items
         * @summary List of Incentive Items
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {number} [limit] Specify number of items to return.
         * @param {number} [offset] Specify the offset of item list to be returned.
         * @param {string} [sortBy] Specify the sort criteria for items. Examples of the allowed values are INCENTIVE_END_DATE or INCENTIVE_LIMIT
         * @param {string} [sortOrder] Specify the sort order for given sort criteria. Examples of the allowed values are ASC or DESC
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepricerIncentive(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepricerIncentive(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, limit, offset, sortBy, sortOrder, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of strategies
         * @summary List of Repricer Strategies
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategies(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStrategies(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API helps Sellers to completely opt-in or opt-out from CAP program.  If the subsidyEnrolled value = \"true\", the Seller enrolls in the CAP program. All eligible SKUs (current and future) are by default opt-in. Seller should use the SKU opt-in/opt-out API to opt-out individual items.  If the subsidyEnrolled value = \"false\", the Seller stops participating in the CAP program and all eligible SKUs (current and future) are opt-out of the CAP program.
         * @summary Set up CAP SKU All
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optCapProgramInPrice(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optCapProgramInPrice(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject6, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates prices in bulk.  In one Feed you can update up to 10,000 items in bulk. To ensure optimal Feed processing time, we recommend sending no more than 1000 items in one Feed and keeping the Feed sizes below 10 MB.  The price sequence guarantee is observed by the bulk price update functionality, subject to the following rules:  The timestamp used to determine precedence is passed in the request headers. All price updates in the feed are considered to have the same timestamp. The timestamp in the XML file is used only for auditing. You can send a single SKU multiple times in one Feed. If a SKU is repeated in a Feed, the price will be set for that SKU on Walmart.com, but there is no guarantee as to which SKU\'s price within that feed will be used. This API should be used in preference to the update a price. It should be called no sooner than 24 hours after a new item is set up and a wpid (Walmart Part ID) is available. Thereafter, the bulk price update has an service level agreement (SLA) of 15 minutes.  After the update is submitted, wait for at least five minutes before verifying whether the bulk price update was successful. Individual SKU price update success or failure is only available after the entire feed is processed.  If a SKU\'s price update fails (for example, multiple price updates were sent for the same SKU in a single feed), an error will be returned.
         * @summary Update bulk prices (Multiple)
         * @param {'price' | 'CPT_SELLER_ELIGIBILITY'} feedType The feed Type
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {any} file Feed file to upload
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceBulkUploads(feedType: 'price' | 'CPT_SELLER_ELIGIBILITY', wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, file: any, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceBulkUploads(feedType, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, file, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the regular price for a given item.
         * @summary Update a price
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrice(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrice(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject2, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assigns incentive items to the default price incentives strategy, ‘Match Competitive Price’
         * @summary Assign Incentive items to Repricer
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepricerIncentive(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepricerIncentive(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject1, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the existing strategy
         * @summary Update Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStrategy(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStrategy(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricesApi - factory interface
 * @export
 */
export const PricesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricesApiFp(configuration)
    return {
        /**
         * Creates a new strategy for the seller
         * @summary Create Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStrategy(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.createStrategy(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject4, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the strategy
         * @summary Delete Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStrategy(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.deleteStrategy(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Add/Remove one or more items from a strategy
         * @summary Assign/Unassign items to/from Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepricerFeed(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.getRepricerFeed(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject3, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of incentive items
         * @summary List of Incentive Items
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {number} [limit] Specify number of items to return.
         * @param {number} [offset] Specify the offset of item list to be returned.
         * @param {string} [sortBy] Specify the sort criteria for items. Examples of the allowed values are INCENTIVE_END_DATE or INCENTIVE_LIMIT
         * @param {string} [sortOrder] Specify the sort order for given sort criteria. Examples of the allowed values are ASC or DESC
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepricerIncentive(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getRepricerIncentive(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, limit, offset, sortBy, sortOrder, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of strategies
         * @summary List of Repricer Strategies
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategies(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.getStrategies(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API helps Sellers to completely opt-in or opt-out from CAP program.  If the subsidyEnrolled value = \"true\", the Seller enrolls in the CAP program. All eligible SKUs (current and future) are by default opt-in. Seller should use the SKU opt-in/opt-out API to opt-out individual items.  If the subsidyEnrolled value = \"false\", the Seller stops participating in the CAP program and all eligible SKUs (current and future) are opt-out of the CAP program.
         * @summary Set up CAP SKU All
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optCapProgramInPrice(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.optCapProgramInPrice(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject6, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates prices in bulk.  In one Feed you can update up to 10,000 items in bulk. To ensure optimal Feed processing time, we recommend sending no more than 1000 items in one Feed and keeping the Feed sizes below 10 MB.  The price sequence guarantee is observed by the bulk price update functionality, subject to the following rules:  The timestamp used to determine precedence is passed in the request headers. All price updates in the feed are considered to have the same timestamp. The timestamp in the XML file is used only for auditing. You can send a single SKU multiple times in one Feed. If a SKU is repeated in a Feed, the price will be set for that SKU on Walmart.com, but there is no guarantee as to which SKU\'s price within that feed will be used. This API should be used in preference to the update a price. It should be called no sooner than 24 hours after a new item is set up and a wpid (Walmart Part ID) is available. Thereafter, the bulk price update has an service level agreement (SLA) of 15 minutes.  After the update is submitted, wait for at least five minutes before verifying whether the bulk price update was successful. Individual SKU price update success or failure is only available after the entire feed is processed.  If a SKU\'s price update fails (for example, multiple price updates were sent for the same SKU in a single feed), an error will be returned.
         * @summary Update bulk prices (Multiple)
         * @param {'price' | 'CPT_SELLER_ELIGIBILITY'} feedType The feed Type
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {any} file Feed file to upload
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceBulkUploads(feedType: 'price' | 'CPT_SELLER_ELIGIBILITY', wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, file: any, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.priceBulkUploads(feedType, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, file, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the regular price for a given item.
         * @summary Update a price
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrice(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.updatePrice(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject2, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns incentive items to the default price incentives strategy, ‘Match Competitive Price’
         * @summary Assign Incentive items to Repricer
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepricerIncentive(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.updateRepricerIncentive(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject1, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing strategy
         * @summary Update Repricer Strategy
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStrategy(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.updateStrategy(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createStrategy operation in PricesApi.
 * @export
 * @interface PricesApiCreateStrategyRequest
 */
export interface PricesApiCreateStrategyRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiCreateStrategy
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiCreateStrategy
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiCreateStrategy
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject4}
     * @memberof PricesApiCreateStrategy
     */
    readonly inlineObject4: InlineObject4

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiCreateStrategy
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for deleteStrategy operation in PricesApi.
 * @export
 * @interface PricesApiDeleteStrategyRequest
 */
export interface PricesApiDeleteStrategyRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiDeleteStrategy
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiDeleteStrategy
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiDeleteStrategy
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiDeleteStrategy
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getRepricerFeed operation in PricesApi.
 * @export
 * @interface PricesApiGetRepricerFeedRequest
 */
export interface PricesApiGetRepricerFeedRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiGetRepricerFeed
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiGetRepricerFeed
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiGetRepricerFeed
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject3}
     * @memberof PricesApiGetRepricerFeed
     */
    readonly inlineObject3: InlineObject3

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiGetRepricerFeed
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getRepricerIncentive operation in PricesApi.
 * @export
 * @interface PricesApiGetRepricerIncentiveRequest
 */
export interface PricesApiGetRepricerIncentiveRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiGetRepricerIncentive
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiGetRepricerIncentive
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiGetRepricerIncentive
     */
    readonly wMSVCNAME: string

    /**
     * Specify number of items to return.
     * @type {number}
     * @memberof PricesApiGetRepricerIncentive
     */
    readonly limit?: number

    /**
     * Specify the offset of item list to be returned.
     * @type {number}
     * @memberof PricesApiGetRepricerIncentive
     */
    readonly offset?: number

    /**
     * Specify the sort criteria for items. Examples of the allowed values are INCENTIVE_END_DATE or INCENTIVE_LIMIT
     * @type {string}
     * @memberof PricesApiGetRepricerIncentive
     */
    readonly sortBy?: string

    /**
     * Specify the sort order for given sort criteria. Examples of the allowed values are ASC or DESC
     * @type {string}
     * @memberof PricesApiGetRepricerIncentive
     */
    readonly sortOrder?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiGetRepricerIncentive
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getStrategies operation in PricesApi.
 * @export
 * @interface PricesApiGetStrategiesRequest
 */
export interface PricesApiGetStrategiesRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiGetStrategies
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiGetStrategies
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiGetStrategies
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiGetStrategies
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for optCapProgramInPrice operation in PricesApi.
 * @export
 * @interface PricesApiOptCapProgramInPriceRequest
 */
export interface PricesApiOptCapProgramInPriceRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiOptCapProgramInPrice
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiOptCapProgramInPrice
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiOptCapProgramInPrice
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject6}
     * @memberof PricesApiOptCapProgramInPrice
     */
    readonly inlineObject6: InlineObject6

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiOptCapProgramInPrice
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for priceBulkUploads operation in PricesApi.
 * @export
 * @interface PricesApiPriceBulkUploadsRequest
 */
export interface PricesApiPriceBulkUploadsRequest {
    /**
     * The feed Type
     * @type {'price' | 'CPT_SELLER_ELIGIBILITY'}
     * @memberof PricesApiPriceBulkUploads
     */
    readonly feedType: 'price' | 'CPT_SELLER_ELIGIBILITY'

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiPriceBulkUploads
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiPriceBulkUploads
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiPriceBulkUploads
     */
    readonly wMSVCNAME: string

    /**
     * Feed file to upload
     * @type {any}
     * @memberof PricesApiPriceBulkUploads
     */
    readonly file: any

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiPriceBulkUploads
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updatePrice operation in PricesApi.
 * @export
 * @interface PricesApiUpdatePriceRequest
 */
export interface PricesApiUpdatePriceRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiUpdatePrice
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiUpdatePrice
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiUpdatePrice
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject2}
     * @memberof PricesApiUpdatePrice
     */
    readonly inlineObject2: InlineObject2

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiUpdatePrice
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updateRepricerIncentive operation in PricesApi.
 * @export
 * @interface PricesApiUpdateRepricerIncentiveRequest
 */
export interface PricesApiUpdateRepricerIncentiveRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiUpdateRepricerIncentive
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiUpdateRepricerIncentive
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiUpdateRepricerIncentive
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject1}
     * @memberof PricesApiUpdateRepricerIncentive
     */
    readonly inlineObject1: InlineObject1

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiUpdateRepricerIncentive
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updateStrategy operation in PricesApi.
 * @export
 * @interface PricesApiUpdateStrategyRequest
 */
export interface PricesApiUpdateStrategyRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof PricesApiUpdateStrategy
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof PricesApiUpdateStrategy
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof PricesApiUpdateStrategy
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject}
     * @memberof PricesApiUpdateStrategy
     */
    readonly inlineObject: InlineObject

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof PricesApiUpdateStrategy
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * PricesApi - object-oriented interface
 * @export
 * @class PricesApi
 * @extends {BaseAPI}
 */
export class PricesApi extends BaseAPI {
    /**
     * Creates a new strategy for the seller
     * @summary Create Repricer Strategy
     * @param {PricesApiCreateStrategyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public createStrategy(requestParameters: PricesApiCreateStrategyRequest, options?: any) {
        return PricesApiFp(this.configuration).createStrategy(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject4, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the strategy
     * @summary Delete Repricer Strategy
     * @param {PricesApiDeleteStrategyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public deleteStrategy(requestParameters: PricesApiDeleteStrategyRequest, options?: any) {
        return PricesApiFp(this.configuration).deleteStrategy(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add/Remove one or more items from a strategy
     * @summary Assign/Unassign items to/from Repricer Strategy
     * @param {PricesApiGetRepricerFeedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public getRepricerFeed(requestParameters: PricesApiGetRepricerFeedRequest, options?: any) {
        return PricesApiFp(this.configuration).getRepricerFeed(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject3, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of incentive items
     * @summary List of Incentive Items
     * @param {PricesApiGetRepricerIncentiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public getRepricerIncentive(requestParameters: PricesApiGetRepricerIncentiveRequest, options?: any) {
        return PricesApiFp(this.configuration).getRepricerIncentive(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of strategies
     * @summary List of Repricer Strategies
     * @param {PricesApiGetStrategiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public getStrategies(requestParameters: PricesApiGetStrategiesRequest, options?: any) {
        return PricesApiFp(this.configuration).getStrategies(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API helps Sellers to completely opt-in or opt-out from CAP program.  If the subsidyEnrolled value = \"true\", the Seller enrolls in the CAP program. All eligible SKUs (current and future) are by default opt-in. Seller should use the SKU opt-in/opt-out API to opt-out individual items.  If the subsidyEnrolled value = \"false\", the Seller stops participating in the CAP program and all eligible SKUs (current and future) are opt-out of the CAP program.
     * @summary Set up CAP SKU All
     * @param {PricesApiOptCapProgramInPriceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public optCapProgramInPrice(requestParameters: PricesApiOptCapProgramInPriceRequest, options?: any) {
        return PricesApiFp(this.configuration).optCapProgramInPrice(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject6, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates prices in bulk.  In one Feed you can update up to 10,000 items in bulk. To ensure optimal Feed processing time, we recommend sending no more than 1000 items in one Feed and keeping the Feed sizes below 10 MB.  The price sequence guarantee is observed by the bulk price update functionality, subject to the following rules:  The timestamp used to determine precedence is passed in the request headers. All price updates in the feed are considered to have the same timestamp. The timestamp in the XML file is used only for auditing. You can send a single SKU multiple times in one Feed. If a SKU is repeated in a Feed, the price will be set for that SKU on Walmart.com, but there is no guarantee as to which SKU\'s price within that feed will be used. This API should be used in preference to the update a price. It should be called no sooner than 24 hours after a new item is set up and a wpid (Walmart Part ID) is available. Thereafter, the bulk price update has an service level agreement (SLA) of 15 minutes.  After the update is submitted, wait for at least five minutes before verifying whether the bulk price update was successful. Individual SKU price update success or failure is only available after the entire feed is processed.  If a SKU\'s price update fails (for example, multiple price updates were sent for the same SKU in a single feed), an error will be returned.
     * @summary Update bulk prices (Multiple)
     * @param {PricesApiPriceBulkUploadsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public priceBulkUploads(requestParameters: PricesApiPriceBulkUploadsRequest, options?: any) {
        return PricesApiFp(this.configuration).priceBulkUploads(requestParameters.feedType, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.file, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the regular price for a given item.
     * @summary Update a price
     * @param {PricesApiUpdatePriceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public updatePrice(requestParameters: PricesApiUpdatePriceRequest, options?: any) {
        return PricesApiFp(this.configuration).updatePrice(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject2, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns incentive items to the default price incentives strategy, ‘Match Competitive Price’
     * @summary Assign Incentive items to Repricer
     * @param {PricesApiUpdateRepricerIncentiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public updateRepricerIncentive(requestParameters: PricesApiUpdateRepricerIncentiveRequest, options?: any) {
        return PricesApiFp(this.configuration).updateRepricerIncentive(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject1, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the existing strategy
     * @summary Update Repricer Strategy
     * @param {PricesApiUpdateStrategyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public updateStrategy(requestParameters: PricesApiUpdateStrategyRequest, options?: any) {
        return PricesApiFp(this.configuration).updateStrategy(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


