/* tslint:disable */
/* eslint-disable */
/**
 * On-request Report Management
 * The On-request Reports API allows you to request reports immediately about your items for faster retrieval. You can request the report, check status on the report availability, and then download the report URL when report is ready. You can also get a list of all reports requested.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface DownloadReportResponse
 */
export interface DownloadReportResponse {
    /**
     * URL to be used to download the report.
     * @type {string}
     * @memberof DownloadReportResponse
     */
    downloadURL?: string;
    /**
     * Time till when the URL to download the report will be valid.
     * @type {string}
     * @memberof DownloadReportResponse
     */
    downloadURLExpirationTime?: string;
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof DownloadReportResponse
     */
    requestId?: string;
    /**
     * Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
     * @type {string}
     * @memberof DownloadReportResponse
     */
    requestStatus?: DownloadReportResponseRequestStatusEnum;
    /**
     * Date and time on which the report request is submitted.
     * @type {string}
     * @memberof DownloadReportResponse
     */
    requestSubmissionDate?: string;
    /**
     * Type of report for which the request is created. Example, ITEM for Item Report.
     * @type {string}
     * @memberof DownloadReportResponse
     */
    reportType?: DownloadReportResponseReportTypeEnum;
    /**
     * Version of report for which the request is created. Example, v1.
     * @type {string}
     * @memberof DownloadReportResponse
     */
    reportVersion?: string;
    /**
     * Date and time on which the report is generated. Attribute is available only if report is generated.
     * @type {string}
     * @memberof DownloadReportResponse
     */
    reportGenerationDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DownloadReportResponseRequestStatusEnum {
    Received = 'RECEIVED',
    Inprogress = 'INPROGRESS',
    Ready = 'READY',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum DownloadReportResponseReportTypeEnum {
    Item = 'ITEM'
}

/**
 * 
 * @export
 * @interface EnumFilter
 */
export interface EnumFilter {
    /**
     * Enum filter values which has to be included in report
     * @type {Array<string>}
     * @memberof EnumFilter
     */
    values?: Array<string>;
    /**
     * Column on which filter has to be applied
     * @type {string}
     * @memberof EnumFilter
     */
    columnName: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof EnumFilter
     */
    type: EnumFilterTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EnumFilterTypeEnum {
    RangeFilter = 'rangeFilter',
    EnumFilter = 'enumFilter'
}

/**
 * 
 * @export
 * @interface EnumFilter1
 */
export interface EnumFilter1 {
    /**
     * Enum filter values which has to be included in report
     * @type {Array<string>}
     * @memberof EnumFilter1
     */
    values?: Array<string>;
    /**
     * Column on which filter has to be applied
     * @type {string}
     * @memberof EnumFilter1
     */
    columnName: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof EnumFilter1
     */
    type: EnumFilter1TypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EnumFilter1TypeEnum {
    RangeFilter = 'rangeFilter',
    EnumFilter = 'enumFilter'
}

/**
 * Request Payload
 * @export
 * @interface GenerateReportPayload
 */
export interface GenerateReportPayload {
    /**
     * Row Level filters
     * @type {Array<object>}
     * @memberof GenerateReportPayload
     */
    rowFilters?: Array<object>;
    /**
     * Columns to exclude from report
     * @type {Array<string>}
     * @memberof GenerateReportPayload
     */
    excludeColumns?: Array<string>;
}
/**
 * 
 * @export
 * @interface GenerateReportResponse
 */
export interface GenerateReportResponse {
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof GenerateReportResponse
     */
    requestId?: string;
    /**
     * Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
     * @type {string}
     * @memberof GenerateReportResponse
     */
    requestStatus?: GenerateReportResponseRequestStatusEnum;
    /**
     * Date and time on which the report request is submitted.
     * @type {string}
     * @memberof GenerateReportResponse
     */
    requestSubmissionDate?: string;
    /**
     * Type of report for which the request is created. Example, ITEM for Item Report.
     * @type {string}
     * @memberof GenerateReportResponse
     */
    reportType?: GenerateReportResponseReportTypeEnum;
    /**
     * Version of report for which the request is created. Example, v1.
     * @type {string}
     * @memberof GenerateReportResponse
     */
    reportVersion?: string;
    /**
     * 
     * @type {InlineObject}
     * @memberof GenerateReportResponse
     */
    payload?: InlineObject;
}

/**
    * @export
    * @enum {string}
    */
export enum GenerateReportResponseRequestStatusEnum {
    Received = 'RECEIVED',
    Inprogress = 'INPROGRESS',
    Ready = 'READY',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum GenerateReportResponseReportTypeEnum {
    Item = 'ITEM'
}

/**
 * Request Payload
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Row Level filters
     * @type {Array<object>}
     * @memberof InlineObject
     */
    rowFilters?: Array<object>;
    /**
     * Columns to exclude from report
     * @type {Array<string>}
     * @memberof InlineObject
     */
    excludeColumns?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Current page
     * @type {number}
     * @memberof InlineResponse200
     */
    page?: number;
    /**
     * Number of records fetched.
     * @type {number}
     * @memberof InlineResponse200
     */
    totalCount?: number;
    /**
     * Number of records to be returned. Default is 10.
     * @type {number}
     * @memberof InlineResponse200
     */
    limit?: number;
    /**
     * Used for pagination when more than specified limit (or default 10) records are found. Use this param for next API call. Just have to use this value as query param. Need to pass only the cursor value and not the initial API call query params. For e.g. if [\'nextCursor\'=\'reportType=ITEM&requestStatus=ERROR&requestSubmissionStartDate=2021-08-20T10:52:59Z&requestSubmissionEndDate=2021-09-14T10:52:59Z&page=2&limit=1\'] then subsequent call to will be [marketplace.walmartapis.com/v3/reports/reportRequests?reportType=ITEM&requestStatus=ERROR&requestSubmissionStartDate=2021-08-20T10:52:59Z&requestSubmissionEndDate=2021-09-14T10:52:59Z&page=2&limit=1]. Just have to use nextCursor value instead of query params
     * @type {string}
     * @memberof InlineResponse200
     */
    nextCursor?: string;
    /**
     * List of requests
     * @type {Array<InlineResponse200Requests>}
     * @memberof InlineResponse200
     */
    requests?: Array<InlineResponse200Requests>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof InlineResponse2001
     */
    requestId?: string;
    /**
     * Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
     * @type {string}
     * @memberof InlineResponse2001
     */
    requestStatus?: InlineResponse2001RequestStatusEnum;
    /**
     * Date and time on which the report request is submitted.
     * @type {string}
     * @memberof InlineResponse2001
     */
    requestSubmissionDate?: string;
    /**
     * Type of report for which the request is created. Example, ITEM for Item Report.
     * @type {string}
     * @memberof InlineResponse2001
     */
    reportType?: InlineResponse2001ReportTypeEnum;
    /**
     * Version of report for which the request is created. Example, v1.
     * @type {string}
     * @memberof InlineResponse2001
     */
    reportVersion?: string;
    /**
     * 
     * @type {InlineObject}
     * @memberof InlineResponse2001
     */
    payload?: InlineObject;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2001RequestStatusEnum {
    Received = 'RECEIVED',
    Inprogress = 'INPROGRESS',
    Ready = 'READY',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2001ReportTypeEnum {
    Item = 'ITEM'
}

/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof InlineResponse2002
     */
    requestId?: string;
    /**
     * Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
     * @type {string}
     * @memberof InlineResponse2002
     */
    requestStatus?: InlineResponse2002RequestStatusEnum;
    /**
     * Date and time on which the report request is submitted.
     * @type {string}
     * @memberof InlineResponse2002
     */
    requestSubmissionDate?: string;
    /**
     * Type of report for which the request is created. Example, ITEM for Item Report.
     * @type {string}
     * @memberof InlineResponse2002
     */
    reportType?: InlineResponse2002ReportTypeEnum;
    /**
     * Version of report for which the request is created. Example, v1.
     * @type {string}
     * @memberof InlineResponse2002
     */
    reportVersion?: string;
    /**
     * 
     * @type {InlineObject}
     * @memberof InlineResponse2002
     */
    payload?: InlineObject;
    /**
     * Date and time on which the report is generated. Attribute is available only if report is generated.
     * @type {string}
     * @memberof InlineResponse2002
     */
    reportGenerationDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2002RequestStatusEnum {
    Received = 'RECEIVED',
    Inprogress = 'INPROGRESS',
    Ready = 'READY',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2002ReportTypeEnum {
    Item = 'ITEM'
}

/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * URL to be used to download the report.
     * @type {string}
     * @memberof InlineResponse2003
     */
    downloadURL?: string;
    /**
     * Time till when the URL to download the report will be valid.
     * @type {string}
     * @memberof InlineResponse2003
     */
    downloadURLExpirationTime?: string;
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof InlineResponse2003
     */
    requestId?: string;
    /**
     * Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
     * @type {string}
     * @memberof InlineResponse2003
     */
    requestStatus?: InlineResponse2003RequestStatusEnum;
    /**
     * Date and time on which the report request is submitted.
     * @type {string}
     * @memberof InlineResponse2003
     */
    requestSubmissionDate?: string;
    /**
     * Type of report for which the request is created. Example, ITEM for Item Report.
     * @type {string}
     * @memberof InlineResponse2003
     */
    reportType?: InlineResponse2003ReportTypeEnum;
    /**
     * Version of report for which the request is created. Example, v1.
     * @type {string}
     * @memberof InlineResponse2003
     */
    reportVersion?: string;
    /**
     * Date and time on which the report is generated. Attribute is available only if report is generated.
     * @type {string}
     * @memberof InlineResponse2003
     */
    reportGenerationDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003RequestStatusEnum {
    Received = 'RECEIVED',
    Inprogress = 'INPROGRESS',
    Ready = 'READY',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003ReportTypeEnum {
    Item = 'ITEM'
}

/**
 * Request Payload
 * @export
 * @interface InlineResponse200Payload
 */
export interface InlineResponse200Payload {
    /**
     * Row Level filters
     * @type {Array<object>}
     * @memberof InlineResponse200Payload
     */
    rowFilters?: Array<object>;
    /**
     * Columns to exclude from report
     * @type {Array<string>}
     * @memberof InlineResponse200Payload
     */
    excludeColumns?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse200Requests
 */
export interface InlineResponse200Requests {
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof InlineResponse200Requests
     */
    requestId?: string;
    /**
     * Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
     * @type {string}
     * @memberof InlineResponse200Requests
     */
    requestStatus?: InlineResponse200RequestsRequestStatusEnum;
    /**
     * Date and time on which the report request is submitted.
     * @type {string}
     * @memberof InlineResponse200Requests
     */
    requestSubmissionDate?: string;
    /**
     * Type of report for which the request is created. Example, ITEM for Item Report.
     * @type {string}
     * @memberof InlineResponse200Requests
     */
    reportType?: InlineResponse200RequestsReportTypeEnum;
    /**
     * Version of report for which the request is created. Example, v1.
     * @type {string}
     * @memberof InlineResponse200Requests
     */
    reportVersion?: string;
    /**
     * 
     * @type {InlineResponse200Payload}
     * @memberof InlineResponse200Requests
     */
    payload?: InlineResponse200Payload;
    /**
     * Date and time on which the report is generated. Attribute is available only if report is generated.
     * @type {string}
     * @memberof InlineResponse200Requests
     */
    reportGenerationDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200RequestsRequestStatusEnum {
    Received = 'RECEIVED',
    Inprogress = 'INPROGRESS',
    Ready = 'READY',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse200RequestsReportTypeEnum {
    Item = 'ITEM'
}

/**
 * 
 * @export
 * @interface RangeFilter
 */
export interface RangeFilter {
    /**
     * Filter range start
     * @type {string}
     * @memberof RangeFilter
     */
    from?: string;
    /**
     * Filter range end
     * @type {string}
     * @memberof RangeFilter
     */
    to?: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof RangeFilter
     */
    rowFilterType: RangeFilterRowFilterTypeEnum;
    /**
     * Column on which filter has to be applied
     * @type {string}
     * @memberof RangeFilter
     */
    columnName: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RangeFilterRowFilterTypeEnum {
    RangeFilter = 'rangeFilter',
    EnumFilter = 'enumFilter'
}

/**
 * 
 * @export
 * @interface RangeFilter1
 */
export interface RangeFilter1 {
    /**
     * Filter range start
     * @type {string}
     * @memberof RangeFilter1
     */
    from?: string;
    /**
     * Filter range end
     * @type {string}
     * @memberof RangeFilter1
     */
    to?: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof RangeFilter1
     */
    rowFilterType: RangeFilter1RowFilterTypeEnum;
    /**
     * Column on which filter has to be applied
     * @type {string}
     * @memberof RangeFilter1
     */
    columnName: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RangeFilter1RowFilterTypeEnum {
    RangeFilter = 'rangeFilter',
    EnumFilter = 'enumFilter'
}

/**
 * 
 * @export
 * @interface RequestStatusResponse
 */
export interface RequestStatusResponse {
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof RequestStatusResponse
     */
    requestId?: string;
    /**
     * Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
     * @type {string}
     * @memberof RequestStatusResponse
     */
    requestStatus?: RequestStatusResponseRequestStatusEnum;
    /**
     * Date and time on which the report request is submitted.
     * @type {string}
     * @memberof RequestStatusResponse
     */
    requestSubmissionDate?: string;
    /**
     * Type of report for which the request is created. Example, ITEM for Item Report.
     * @type {string}
     * @memberof RequestStatusResponse
     */
    reportType?: RequestStatusResponseReportTypeEnum;
    /**
     * Version of report for which the request is created. Example, v1.
     * @type {string}
     * @memberof RequestStatusResponse
     */
    reportVersion?: string;
    /**
     * 
     * @type {InlineObject}
     * @memberof RequestStatusResponse
     */
    payload?: InlineObject;
    /**
     * Date and time on which the report is generated. Attribute is available only if report is generated.
     * @type {string}
     * @memberof RequestStatusResponse
     */
    reportGenerationDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RequestStatusResponseRequestStatusEnum {
    Received = 'RECEIVED',
    Inprogress = 'INPROGRESS',
    Ready = 'READY',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum RequestStatusResponseReportTypeEnum {
    Item = 'ITEM'
}

/**
 * 
 * @export
 * @interface RequestsStatusResponse
 */
export interface RequestsStatusResponse {
    /**
     * Current page
     * @type {number}
     * @memberof RequestsStatusResponse
     */
    page?: number;
    /**
     * Number of records fetched.
     * @type {number}
     * @memberof RequestsStatusResponse
     */
    totalCount?: number;
    /**
     * Number of records to be returned. Default is 10.
     * @type {number}
     * @memberof RequestsStatusResponse
     */
    limit?: number;
    /**
     * Used for pagination when more than specified limit (or default 10) records are found. Use this param for next API call. Just have to use this value as query param. Need to pass only the cursor value and not the initial API call query params. For e.g. if [\'nextCursor\'=\'reportType=ITEM&requestStatus=ERROR&requestSubmissionStartDate=2021-08-20T10:52:59Z&requestSubmissionEndDate=2021-09-14T10:52:59Z&page=2&limit=1\'] then subsequent call to will be [marketplace.walmartapis.com/v3/reports/reportRequests?reportType=ITEM&requestStatus=ERROR&requestSubmissionStartDate=2021-08-20T10:52:59Z&requestSubmissionEndDate=2021-09-14T10:52:59Z&page=2&limit=1]. Just have to use nextCursor value instead of query params
     * @type {string}
     * @memberof RequestsStatusResponse
     */
    nextCursor?: string;
    /**
     * List of requests
     * @type {Array<InlineResponse2002>}
     * @memberof RequestsStatusResponse
     */
    requests?: Array<InlineResponse2002>;
}
/**
 * Supertype of all row filters.
 * @export
 * @interface RowFilter
 */
export interface RowFilter {
    /**
     * Enum filter values which has to be included in report
     * @type {Array<string>}
     * @memberof RowFilter
     */
    values?: Array<string>;
    /**
     * Column on which filter has to be applied
     * @type {string}
     * @memberof RowFilter
     */
    columnName: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof RowFilter
     */
    type: RowFilterTypeEnum;
    /**
     * Filter range start
     * @type {string}
     * @memberof RowFilter
     */
    from?: string;
    /**
     * Filter range end
     * @type {string}
     * @memberof RowFilter
     */
    to?: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof RowFilter
     */
    rowFilterType: RowFilterRowFilterTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RowFilterTypeEnum {
    RangeFilter = 'rangeFilter',
    EnumFilter = 'enumFilter'
}
/**
    * @export
    * @enum {string}
    */
export enum RowFilterRowFilterTypeEnum {
    RangeFilter = 'rangeFilter',
    EnumFilter = 'enumFilter'
}


/**
 * OnRequestReportApi - axios parameter creator
 * @export
 */
export const OnRequestReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches URL to download a generated report.
         * @summary Download Report URL
         * @param {string} requestId Automated ID generated by system that uniquely identifies the report request.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadReport: async (requestId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('downloadReport', 'requestId', requestId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('downloadReport', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('downloadReport', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('downloadReport', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('downloadReport', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('downloadReport', 'accept', accept)
            const localVarPath = `/v3/reports/downloadReport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new request for report by specifying the reportType and reportVersion.
         * @summary Create Report Request
         * @param {'ITEM' | 'INVENTORY'} reportType Specifies the report type for the request. For example, reportType&#x3D;ITEM creates an Item Report.
         * @param {string} reportVersion Version of report for which the request is created. Supported versions for each report type are currently \&#39;reportVersion&#x3D;v1\&#39; for the following reportType(s): INVENTORY and \&#39;reportVersion&#x3D;v1\&#39;, \&#39;reportVersion&#x3D;v2\&#39; for the following reportType(s): ITEM.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} contentType Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReport: async (reportType: 'ITEM' | 'INVENTORY', reportVersion: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, contentType: string, wMCONSUMERCHANNELTYPE?: string, inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportType' is not null or undefined
            assertParamExists('generateReport', 'reportType', reportType)
            // verify required parameter 'reportVersion' is not null or undefined
            assertParamExists('generateReport', 'reportVersion', reportVersion)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('generateReport', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('generateReport', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('generateReport', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('generateReport', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('generateReport', 'accept', accept)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('generateReport', 'contentType', contentType)
            const localVarPath = `/v3/reports/reportRequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (reportType !== undefined) {
                localVarQueryParameter['reportType'] = reportType;
            }

            if (reportVersion !== undefined) {
                localVarQueryParameter['reportVersion'] = reportVersion;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of all report requests for specified search criteria by using query parameters.  You can fetch details of report requests created in the last 30 days only.
         * @summary Get All Report Requests
         * @param {'ITEM' | 'INVENTORY'} reportType Type of report for which the request is created. Example, ITEM for Item Report.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [reportVersion] Version of report for which the request is created. Example, v1.
         * @param {'RECEIVED' | 'INPROGRESS' | 'READY' | 'ERROR'} [requestStatus] Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
         * @param {string} [requestSubmissionStartDate] Report request submittal start date for range of reports requested, in format: YYYY-MM-DDTHH:mm:ssZ
         * @param {string} [requestSubmissionEndDate] Report request submittal end date for range of reports requested, in format YYYY-MM-DDTHH:mm:ssZ
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestsStatus: async (reportType: 'ITEM' | 'INVENTORY', authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, reportVersion?: string, requestStatus?: 'RECEIVED' | 'INPROGRESS' | 'READY' | 'ERROR', requestSubmissionStartDate?: string, requestSubmissionEndDate?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportType' is not null or undefined
            assertParamExists('getRequestsStatus', 'reportType', reportType)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getRequestsStatus', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getRequestsStatus', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getRequestsStatus', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getRequestsStatus', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('getRequestsStatus', 'accept', accept)
            const localVarPath = `/v3/reports/reportRequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (reportType !== undefined) {
                localVarQueryParameter['reportType'] = reportType;
            }

            if (reportVersion !== undefined) {
                localVarQueryParameter['reportVersion'] = reportVersion;
            }

            if (requestStatus !== undefined) {
                localVarQueryParameter['requestStatus'] = requestStatus;
            }

            if (requestSubmissionStartDate !== undefined) {
                localVarQueryParameter['requestSubmissionStartDate'] = requestSubmissionStartDate;
            }

            if (requestSubmissionEndDate !== undefined) {
                localVarQueryParameter['requestSubmissionEndDate'] = requestSubmissionEndDate;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches status and other details of a report request by providing a requestID.  You can fetch details of report request created in the last 30 days only.
         * @summary Report Request Status
         * @param {string} requestId Automated ID generated by system that uniquely identifies the report request.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRequestStatus: async (requestId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('getSingleRequestStatus', 'requestId', requestId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getSingleRequestStatus', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getSingleRequestStatus', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getSingleRequestStatus', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getSingleRequestStatus', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('getSingleRequestStatus', 'accept', accept)
            const localVarPath = `/v3/reports/reportRequests/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OnRequestReportApi - functional programming interface
 * @export
 */
export const OnRequestReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OnRequestReportApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches URL to download a generated report.
         * @summary Download Report URL
         * @param {string} requestId Automated ID generated by system that uniquely identifies the report request.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadReport(requestId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadReport(requestId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new request for report by specifying the reportType and reportVersion.
         * @summary Create Report Request
         * @param {'ITEM' | 'INVENTORY'} reportType Specifies the report type for the request. For example, reportType&#x3D;ITEM creates an Item Report.
         * @param {string} reportVersion Version of report for which the request is created. Supported versions for each report type are currently \&#39;reportVersion&#x3D;v1\&#39; for the following reportType(s): INVENTORY and \&#39;reportVersion&#x3D;v1\&#39;, \&#39;reportVersion&#x3D;v2\&#39; for the following reportType(s): ITEM.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} contentType Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateReport(reportType: 'ITEM' | 'INVENTORY', reportVersion: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, contentType: string, wMCONSUMERCHANNELTYPE?: string, inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateReport(reportType, reportVersion, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, contentType, wMCONSUMERCHANNELTYPE, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a list of all report requests for specified search criteria by using query parameters.  You can fetch details of report requests created in the last 30 days only.
         * @summary Get All Report Requests
         * @param {'ITEM' | 'INVENTORY'} reportType Type of report for which the request is created. Example, ITEM for Item Report.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [reportVersion] Version of report for which the request is created. Example, v1.
         * @param {'RECEIVED' | 'INPROGRESS' | 'READY' | 'ERROR'} [requestStatus] Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
         * @param {string} [requestSubmissionStartDate] Report request submittal start date for range of reports requested, in format: YYYY-MM-DDTHH:mm:ssZ
         * @param {string} [requestSubmissionEndDate] Report request submittal end date for range of reports requested, in format YYYY-MM-DDTHH:mm:ssZ
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestsStatus(reportType: 'ITEM' | 'INVENTORY', authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, reportVersion?: string, requestStatus?: 'RECEIVED' | 'INPROGRESS' | 'READY' | 'ERROR', requestSubmissionStartDate?: string, requestSubmissionEndDate?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestsStatus(reportType, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, reportVersion, requestStatus, requestSubmissionStartDate, requestSubmissionEndDate, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches status and other details of a report request by providing a requestID.  You can fetch details of report request created in the last 30 days only.
         * @summary Report Request Status
         * @param {string} requestId Automated ID generated by system that uniquely identifies the report request.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleRequestStatus(requestId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleRequestStatus(requestId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OnRequestReportApi - factory interface
 * @export
 */
export const OnRequestReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OnRequestReportApiFp(configuration)
    return {
        /**
         * Fetches URL to download a generated report.
         * @summary Download Report URL
         * @param {string} requestId Automated ID generated by system that uniquely identifies the report request.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadReport(requestId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.downloadReport(requestId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new request for report by specifying the reportType and reportVersion.
         * @summary Create Report Request
         * @param {'ITEM' | 'INVENTORY'} reportType Specifies the report type for the request. For example, reportType&#x3D;ITEM creates an Item Report.
         * @param {string} reportVersion Version of report for which the request is created. Supported versions for each report type are currently \&#39;reportVersion&#x3D;v1\&#39; for the following reportType(s): INVENTORY and \&#39;reportVersion&#x3D;v1\&#39;, \&#39;reportVersion&#x3D;v2\&#39; for the following reportType(s): ITEM.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} contentType Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReport(reportType: 'ITEM' | 'INVENTORY', reportVersion: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, contentType: string, wMCONSUMERCHANNELTYPE?: string, inlineObject?: InlineObject, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.generateReport(reportType, reportVersion, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, contentType, wMCONSUMERCHANNELTYPE, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of all report requests for specified search criteria by using query parameters.  You can fetch details of report requests created in the last 30 days only.
         * @summary Get All Report Requests
         * @param {'ITEM' | 'INVENTORY'} reportType Type of report for which the request is created. Example, ITEM for Item Report.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [reportVersion] Version of report for which the request is created. Example, v1.
         * @param {'RECEIVED' | 'INPROGRESS' | 'READY' | 'ERROR'} [requestStatus] Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
         * @param {string} [requestSubmissionStartDate] Report request submittal start date for range of reports requested, in format: YYYY-MM-DDTHH:mm:ssZ
         * @param {string} [requestSubmissionEndDate] Report request submittal end date for range of reports requested, in format YYYY-MM-DDTHH:mm:ssZ
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestsStatus(reportType: 'ITEM' | 'INVENTORY', authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, reportVersion?: string, requestStatus?: 'RECEIVED' | 'INPROGRESS' | 'READY' | 'ERROR', requestSubmissionStartDate?: string, requestSubmissionEndDate?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getRequestsStatus(reportType, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, reportVersion, requestStatus, requestSubmissionStartDate, requestSubmissionEndDate, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches status and other details of a report request by providing a requestID.  You can fetch details of report request created in the last 30 days only.
         * @summary Report Request Status
         * @param {string} requestId Automated ID generated by system that uniquely identifies the report request.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} accept Only supported Media Type : application/json
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRequestStatus(requestId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, accept: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getSingleRequestStatus(requestId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, accept, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadReport operation in OnRequestReportApi.
 * @export
 * @interface OnRequestReportApiDownloadReportRequest
 */
export interface OnRequestReportApiDownloadReportRequest {
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof OnRequestReportApiDownloadReport
     */
    readonly requestId: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof OnRequestReportApiDownloadReport
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof OnRequestReportApiDownloadReport
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof OnRequestReportApiDownloadReport
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof OnRequestReportApiDownloadReport
     */
    readonly wMSVCNAME: string

    /**
     * Only supported Media Type : application/json
     * @type {string}
     * @memberof OnRequestReportApiDownloadReport
     */
    readonly accept: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof OnRequestReportApiDownloadReport
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for generateReport operation in OnRequestReportApi.
 * @export
 * @interface OnRequestReportApiGenerateReportRequest
 */
export interface OnRequestReportApiGenerateReportRequest {
    /**
     * Specifies the report type for the request. For example, reportType&#x3D;ITEM creates an Item Report.
     * @type {'ITEM' | 'INVENTORY'}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly reportType: 'ITEM' | 'INVENTORY'

    /**
     * Version of report for which the request is created. Supported versions for each report type are currently \&#39;reportVersion&#x3D;v1\&#39; for the following reportType(s): INVENTORY and \&#39;reportVersion&#x3D;v1\&#39;, \&#39;reportVersion&#x3D;v2\&#39; for the following reportType(s): ITEM.
     * @type {string}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly reportVersion: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly wMSVCNAME: string

    /**
     * Only supported Media Type : application/json
     * @type {string}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly accept: string

    /**
     * Only supported Media Type : application/json
     * @type {string}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly contentType: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly wMCONSUMERCHANNELTYPE?: string

    /**
     * 
     * @type {InlineObject}
     * @memberof OnRequestReportApiGenerateReport
     */
    readonly inlineObject?: InlineObject
}

/**
 * Request parameters for getRequestsStatus operation in OnRequestReportApi.
 * @export
 * @interface OnRequestReportApiGetRequestsStatusRequest
 */
export interface OnRequestReportApiGetRequestsStatusRequest {
    /**
     * Type of report for which the request is created. Example, ITEM for Item Report.
     * @type {'ITEM' | 'INVENTORY'}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly reportType: 'ITEM' | 'INVENTORY'

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly wMSVCNAME: string

    /**
     * Only supported Media Type : application/json
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly accept: string

    /**
     * Version of report for which the request is created. Example, v1.
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly reportVersion?: string

    /**
     * Status of report request. Possible values are RECEIVED, INPROGRESS, READY, ERROR.
     * @type {'RECEIVED' | 'INPROGRESS' | 'READY' | 'ERROR'}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly requestStatus?: 'RECEIVED' | 'INPROGRESS' | 'READY' | 'ERROR'

    /**
     * Report request submittal start date for range of reports requested, in format: YYYY-MM-DDTHH:mm:ssZ
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly requestSubmissionStartDate?: string

    /**
     * Report request submittal end date for range of reports requested, in format YYYY-MM-DDTHH:mm:ssZ
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly requestSubmissionEndDate?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof OnRequestReportApiGetRequestsStatus
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getSingleRequestStatus operation in OnRequestReportApi.
 * @export
 * @interface OnRequestReportApiGetSingleRequestStatusRequest
 */
export interface OnRequestReportApiGetSingleRequestStatusRequest {
    /**
     * Automated ID generated by system that uniquely identifies the report request.
     * @type {string}
     * @memberof OnRequestReportApiGetSingleRequestStatus
     */
    readonly requestId: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof OnRequestReportApiGetSingleRequestStatus
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof OnRequestReportApiGetSingleRequestStatus
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof OnRequestReportApiGetSingleRequestStatus
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof OnRequestReportApiGetSingleRequestStatus
     */
    readonly wMSVCNAME: string

    /**
     * Only supported Media Type : application/json
     * @type {string}
     * @memberof OnRequestReportApiGetSingleRequestStatus
     */
    readonly accept: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof OnRequestReportApiGetSingleRequestStatus
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * OnRequestReportApi - object-oriented interface
 * @export
 * @class OnRequestReportApi
 * @extends {BaseAPI}
 */
export class OnRequestReportApi extends BaseAPI {
    /**
     * Fetches URL to download a generated report.
     * @summary Download Report URL
     * @param {OnRequestReportApiDownloadReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnRequestReportApi
     */
    public downloadReport(requestParameters: OnRequestReportApiDownloadReportRequest, options?: any) {
        return OnRequestReportApiFp(this.configuration).downloadReport(requestParameters.requestId, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.accept, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new request for report by specifying the reportType and reportVersion.
     * @summary Create Report Request
     * @param {OnRequestReportApiGenerateReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnRequestReportApi
     */
    public generateReport(requestParameters: OnRequestReportApiGenerateReportRequest, options?: any) {
        return OnRequestReportApiFp(this.configuration).generateReport(requestParameters.reportType, requestParameters.reportVersion, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.accept, requestParameters.contentType, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a list of all report requests for specified search criteria by using query parameters.  You can fetch details of report requests created in the last 30 days only.
     * @summary Get All Report Requests
     * @param {OnRequestReportApiGetRequestsStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnRequestReportApi
     */
    public getRequestsStatus(requestParameters: OnRequestReportApiGetRequestsStatusRequest, options?: any) {
        return OnRequestReportApiFp(this.configuration).getRequestsStatus(requestParameters.reportType, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.accept, requestParameters.reportVersion, requestParameters.requestStatus, requestParameters.requestSubmissionStartDate, requestParameters.requestSubmissionEndDate, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches status and other details of a report request by providing a requestID.  You can fetch details of report request created in the last 30 days only.
     * @summary Report Request Status
     * @param {OnRequestReportApiGetSingleRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnRequestReportApi
     */
    public getSingleRequestStatus(requestParameters: OnRequestReportApiGetSingleRequestStatusRequest, options?: any) {
        return OnRequestReportApiFp(this.configuration).getSingleRequestStatus(requestParameters.requestId, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.accept, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


