/* tslint:disable */
/* eslint-disable */
/**
 * Returns Management
 * Buyers can now Initiate Returns from Walmart.com for Marketplace seller items (Except for HAZMAT, OTHER or FREIGHT items). For item in the exception categories: HAZMAT or OTHER, sellers need to generate the return shipping label, and upload the label. For detailed instructions, and to download the Returns API JSON schema, see Returns guide.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Carrier information for the return
 * @export
 * @interface CarrierInfoList
 */
export interface CarrierInfoList {
    /**
     * ID of the carrier used for the return
     * @type {string}
     * @memberof CarrierInfoList
     */
    carrierId?: string;
    /**
     * Name of the carrier used
     * @type {string}
     * @memberof CarrierInfoList
     */
    carrierName?: string;
    /**
     * the type of service used
     * @type {string}
     * @memberof CarrierInfoList
     */
    serviceType?: string;
    /**
     * Tracking number of the order
     * @type {string}
     * @memberof CarrierInfoList
     */
    trackingNo?: string;
}
/**
 * Information relating to the charge for the orderLine
 * @export
 * @interface Charge
 */
export interface Charge {
    /**
     * The category type. (e.g., \'PRODUCT\' or \'FEE\')
     * @type {string}
     * @memberof Charge
     */
    chargeCategory?: string;
    /**
     * If chargeType is PRODUCT, chargeName is ItemPrice. If chargeType is PRODUCT and includes a chargeName as SubscriptionDiscount, these are subscription orders with a discount. If chargeType is SHIPPING, chargeName is Shipping
     * @type {string}
     * @memberof Charge
     */
    chargeName?: string;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof Charge
     */
    chargePerUnit?: InlineResponse2002TotalRefundAmount;
    /**
     * Is this charge a discount, which then needs to be subtracted from the refund
     * @type {boolean}
     * @memberof Charge
     */
    isDiscount?: boolean;
    /**
     * Should this charge be included in the refund computation 
     * @type {boolean}
     * @memberof Charge
     */
    isBillable?: boolean;
    /**
     * Taxes for each charge
     * @type {Array<InlineResponse2002Tax>}
     * @memberof Charge
     */
    tax?: Array<InlineResponse2002Tax>;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof Charge
     */
    excessCharge?: InlineResponse2002TotalRefundAmount;
    /**
     * Used only for OG
     * @type {Array<InlineResponse2002References>}
     * @memberof Charge
     */
    references?: Array<InlineResponse2002References>;
}
/**
 * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
 * @export
 * @interface ChargeTotal
 */
export interface ChargeTotal {
    /**
     * Charge Names: lineUnitPrice, lineProductTaxes, lineTotalTaxes, lineRestockingFee, lineShippingFee, lineSubTotal, lineTotal.
     * @type {string}
     * @memberof ChargeTotal
     */
    name: string;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof ChargeTotal
     */
    value: InlineResponse2002TotalRefundAmount;
}
/**
 * Array of current tracking status of each quantity
 * @export
 * @interface CurrentTrackingStatus
 */
export interface CurrentTrackingStatus {
    /**
     * Current status of return. (e.g., \'INITIATED\')
     * @type {string}
     * @memberof CurrentTrackingStatus
     */
    status?: string;
    /**
     * Timestamp of listed status change
     * @type {string}
     * @memberof CurrentTrackingStatus
     */
    statusTime?: string;
    /**
     * Determines the current refund status of the return.
     * @type {string}
     * @memberof CurrentTrackingStatus
     */
    currentRefundStatus?: string;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof CurrentTrackingStatus
     */
    quantity?: V3ReturnsReturnOrderIdRefundQuantity;
}
/**
 * Customer information
 * @export
 * @interface CustomerName
 */
export interface CustomerName {
    /**
     * Customer first name
     * @type {string}
     * @memberof CustomerName
     */
    firstName?: string;
    /**
     * Customer last name
     * @type {string}
     * @memberof CustomerName
     */
    lastName?: string;
}
/**
 * 
 * @export
 * @interface FeedId
 */
export interface FeedId {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the Feed File.
     * @type {string}
     * @memberof FeedId
     */
    feedId?: string;
}
/**
 * 
 * @export
 * @interface GetReturnOrdersResponse
 */
export interface GetReturnOrdersResponse {
    /**
     * 
     * @type {InlineResponse2002Meta}
     * @memberof GetReturnOrdersResponse
     */
    meta: InlineResponse2002Meta;
    /**
     * List of returns for the seller.
     * @type {Array<InlineResponse2002ReturnOrders>}
     * @memberof GetReturnOrdersResponse
     */
    returnOrders: Array<InlineResponse2002ReturnOrders>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof InlineObject
     */
    customerOrderId: string;
    /**
     * Array of refund lines.
     * @type {Array<V3ReturnsReturnOrderIdRefundRefundLines>}
     * @memberof InlineObject
     */
    refundLines: Array<V3ReturnsReturnOrderIdRefundRefundLines>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * The return order id
     * @type {string}
     * @memberof InlineResponse200
     */
    returnOrderId?: string;
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof InlineResponse200
     */
    customerOrderId?: string;
    /**
     * Array of refund lines
     * @type {Array<V3ReturnsReturnOrderIdRefundRefundLines>}
     * @memberof InlineResponse200
     */
    refundLines?: Array<V3ReturnsReturnOrderIdRefundRefundLines>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the Feed File.
     * @type {string}
     * @memberof InlineResponse2001
     */
    feedId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {InlineResponse2002Meta}
     * @memberof InlineResponse2002
     */
    meta: InlineResponse2002Meta;
    /**
     * List of returns for the seller.
     * @type {Array<InlineResponse2002ReturnOrders>}
     * @memberof InlineResponse2002
     */
    returnOrders: Array<InlineResponse2002ReturnOrders>;
}
/**
 * Carrier information for the return
 * @export
 * @interface InlineResponse2002CarrierInfoList
 */
export interface InlineResponse2002CarrierInfoList {
    /**
     * ID of the carrier used for the return
     * @type {string}
     * @memberof InlineResponse2002CarrierInfoList
     */
    carrierId?: string;
    /**
     * Name of the carrier used
     * @type {string}
     * @memberof InlineResponse2002CarrierInfoList
     */
    carrierName?: string;
    /**
     * the type of service used
     * @type {string}
     * @memberof InlineResponse2002CarrierInfoList
     */
    serviceType?: string;
    /**
     * Tracking number of the order
     * @type {string}
     * @memberof InlineResponse2002CarrierInfoList
     */
    trackingNo?: string;
}
/**
 * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
 * @export
 * @interface InlineResponse2002ChargeTotals
 */
export interface InlineResponse2002ChargeTotals {
    /**
     * Charge Names: lineUnitPrice, lineProductTaxes, lineTotalTaxes, lineRestockingFee, lineShippingFee, lineSubTotal, lineTotal.
     * @type {string}
     * @memberof InlineResponse2002ChargeTotals
     */
    name: string;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof InlineResponse2002ChargeTotals
     */
    value: InlineResponse2002TotalRefundAmount;
}
/**
 * Information relating to the charge for the orderLine
 * @export
 * @interface InlineResponse2002Charges
 */
export interface InlineResponse2002Charges {
    /**
     * The category type. (e.g., \'PRODUCT\' or \'FEE\')
     * @type {string}
     * @memberof InlineResponse2002Charges
     */
    chargeCategory?: string;
    /**
     * If chargeType is PRODUCT, chargeName is ItemPrice. If chargeType is PRODUCT and includes a chargeName as SubscriptionDiscount, these are subscription orders with a discount. If chargeType is SHIPPING, chargeName is Shipping
     * @type {string}
     * @memberof InlineResponse2002Charges
     */
    chargeName?: string;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof InlineResponse2002Charges
     */
    chargePerUnit?: InlineResponse2002TotalRefundAmount;
    /**
     * Is this charge a discount, which then needs to be subtracted from the refund
     * @type {boolean}
     * @memberof InlineResponse2002Charges
     */
    isDiscount?: boolean;
    /**
     * Should this charge be included in the refund computation 
     * @type {boolean}
     * @memberof InlineResponse2002Charges
     */
    isBillable?: boolean;
    /**
     * Taxes for each charge
     * @type {Array<InlineResponse2002Tax>}
     * @memberof InlineResponse2002Charges
     */
    tax?: Array<InlineResponse2002Tax>;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof InlineResponse2002Charges
     */
    excessCharge?: InlineResponse2002TotalRefundAmount;
    /**
     * Used only for OG
     * @type {Array<InlineResponse2002References>}
     * @memberof InlineResponse2002Charges
     */
    references?: Array<InlineResponse2002References>;
}
/**
 * Array of current tracking status of each quantity
 * @export
 * @interface InlineResponse2002CurrentTrackingStatuses
 */
export interface InlineResponse2002CurrentTrackingStatuses {
    /**
     * Current status of return. (e.g., \'INITIATED\')
     * @type {string}
     * @memberof InlineResponse2002CurrentTrackingStatuses
     */
    status?: string;
    /**
     * Timestamp of listed status change
     * @type {string}
     * @memberof InlineResponse2002CurrentTrackingStatuses
     */
    statusTime?: string;
    /**
     * Determines the current refund status of the return.
     * @type {string}
     * @memberof InlineResponse2002CurrentTrackingStatuses
     */
    currentRefundStatus?: string;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof InlineResponse2002CurrentTrackingStatuses
     */
    quantity?: V3ReturnsReturnOrderIdRefundQuantity;
}
/**
 * Customer information
 * @export
 * @interface InlineResponse2002CustomerName
 */
export interface InlineResponse2002CustomerName {
    /**
     * Customer first name
     * @type {string}
     * @memberof InlineResponse2002CustomerName
     */
    firstName?: string;
    /**
     * Customer last name
     * @type {string}
     * @memberof InlineResponse2002CustomerName
     */
    lastName?: string;
}
/**
 * Details of the item to be returned
 * @export
 * @interface InlineResponse2002Item
 */
export interface InlineResponse2002Item {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InlineResponse2002Item
     */
    sku?: string;
    /**
     * The name of the product associated with the line item. Example: \'Kenmore CF1\' or \'2086883 Canister Secondary Filter Generic 2 Pack\'
     * @type {string}
     * @memberof InlineResponse2002Item
     */
    productName?: string;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof InlineResponse2002Item
     */
    itemWeight?: V3ReturnsReturnOrderIdRefundQuantity;
}
/**
 * Array of labels
 * @export
 * @interface InlineResponse2002Labels
 */
export interface InlineResponse2002Labels {
    /**
     * Url to get the return label
     * @type {string}
     * @memberof InlineResponse2002Labels
     */
    labelImageURL?: string;
    /**
     * Carrier information for the return
     * @type {Array<InlineResponse2002CarrierInfoList>}
     * @memberof InlineResponse2002Labels
     */
    carrierInfoList?: Array<InlineResponse2002CarrierInfoList>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Meta
 */
export interface InlineResponse2002Meta {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Meta
     */
    totalCount: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Meta
     */
    limit: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Meta
     */
    nextCursor: string;
}
/**
 * Used only for 1P
 * @export
 * @interface InlineResponse2002References
 */
export interface InlineResponse2002References {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002References
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002References
     */
    value: string;
}
/**
 * Array of refund channel of each quantity
 * @export
 * @interface InlineResponse2002RefundChannels
 */
export interface InlineResponse2002RefundChannels {
    /**
     * Valid values are: ONLINE, IN_STORE, and CUSTOMER_CARE
     * @type {string}
     * @memberof InlineResponse2002RefundChannels
     */
    refundChannelName?: string;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof InlineResponse2002RefundChannels
     */
    quantity?: V3ReturnsReturnOrderIdRefundQuantity;
}
/**
 * The channel via order return got initiated
 * @export
 * @interface InlineResponse2002ReturnChannel
 */
export interface InlineResponse2002ReturnChannel {
    /**
     * Valid values are: ONLINE, IN_STORE, and CUSTOMER_CARE
     * @type {string}
     * @memberof InlineResponse2002ReturnChannel
     */
    channelName?: string;
}
/**
 * These groups are created per label or type of carrier service required. (e.g., If order has some lines that can be clubbed and mailed together as a smart post then they belong to one return group. If a line is bulky and needs a different type of carrier service, then that line will be part of different group. Customer gets multiple labels depending on how many groups are created for the entire order.)
 * @export
 * @interface InlineResponse2002ReturnLineGroups
 */
export interface InlineResponse2002ReturnLineGroups {
    /**
     * Sequence of group numbers where each returnLineGroups will represent one or more return lines
     * @type {number}
     * @memberof InlineResponse2002ReturnLineGroups
     */
    groupNo?: number;
    /**
     * Array of return lines
     * @type {Array<InlineResponse2002ReturnLines>}
     * @memberof InlineResponse2002ReturnLineGroups
     */
    returnLines?: Array<InlineResponse2002ReturnLines>;
    /**
     * Array of labels
     * @type {Array<InlineResponse2002Labels>}
     * @memberof InlineResponse2002ReturnLineGroups
     */
    labels?: Array<InlineResponse2002Labels>;
    /**
     * Is customer required to send this item back to return center
     * @type {boolean}
     * @memberof InlineResponse2002ReturnLineGroups
     */
    returnExpectedFlag?: boolean;
}
/**
 * Array of return lines
 * @export
 * @interface InlineResponse2002ReturnLines
 */
export interface InlineResponse2002ReturnLines {
    /**
     * Identifier of the return label
     * @type {number}
     * @memberof InlineResponse2002ReturnLines
     */
    returnOrderLineNumber?: number;
}
/**
 * A list of order lines in the return order
 * @export
 * @interface InlineResponse2002ReturnOrderLines
 */
export interface InlineResponse2002ReturnOrderLines {
    /**
     * The returns order line number for that return
     * @type {number}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    returnOrderLineNumber?: number;
    /**
     * The sales order line number for the return created
     * @type {number}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    salesOrderLineNumber?: number;
    /**
     * A unique ID associated with the sales order for specified Seller; gives Sellers the ability to print their own custom order ID on the return label; limit of 30 characters
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    sellerOrderId?: string;
    /**
     * Gives the reason that was selected during the return creation. Reason codes are: ARRIVED_LATE, AUTO_RETURN, BOUGHT_ANOTHER_SIZE_OR_COLOR, BOUGHT_SOMEWHERE_ELSE, DAMAGED, DEFECTIVE, DUPLICATE_ITEM, INADEQUATE_QUALITY, INCORRECT_ITEM, LOST_AFTER_DELIVERY, LOST_IN_TRANSIT, LOWER_PRICE, MISSING_PARTS, NOT_AS_DESCRIBED, NO_LONGER_WANTED, RETURN_TO_SENDER, SHIPPING_BOX_DAMAGED, TRIED_TO_CANCEL and WRONG_SIZE/POOR_FIT
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    returnReason?: string;
    /**
     * The purchase order ID for the return created
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    purchaseOrderId?: string;
    /**
     * The purchase order line number for the return created
     * @type {number}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    purchaseOrderLineNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    exceptionItemType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    isReturnForException?: boolean;
    /**
     * reason for recharging the customer for replacement
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    rechargeReason?: string;
    /**
     * reason for cancelling the return
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    returnCancellationReason?: string;
    /**
     * 
     * @type {InlineResponse2002Item}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    item?: InlineResponse2002Item;
    /**
     * Information relating to the charge for the orderLine
     * @type {Array<InlineResponse2002Charges>}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    charges?: Array<InlineResponse2002Charges>;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    unitPrice?: InlineResponse2002TotalRefundAmount;
    /**
     * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
     * @type {Array<InlineResponse2002References>}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    itemReturnSettings?: Array<InlineResponse2002References>;
    /**
     * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
     * @type {Array<InlineResponse2002ChargeTotals>}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    chargeTotals?: Array<InlineResponse2002ChargeTotals>;
    /**
     * How much quantity of this order line can be cancelled
     * @type {number}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    cancellableQty?: number;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    quantity?: V3ReturnsReturnOrderIdRefundQuantity;
    /**
     * Is customer required to send this item back to return center.
     * @type {boolean}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    returnExpectedFlag?: boolean;
    /**
     * Applicable only for 1P.
     * @type {boolean}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    isFastReplacement?: boolean;
    /**
     * Is customer allowed to keep the product and not required to send it back to return center. This flag is determined by making a call to fraud system.
     * @type {boolean}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    isKeepIt?: boolean;
    /**
     * This return is the last item on the sales order line and all other sales order line items are already returned. Helps in last penny calculations.
     * @type {boolean}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    lastItem?: boolean;
    /**
     * The quantity for which customer was refunded
     * @type {number}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    refundedQty?: number;
    /**
     * The quantity for which customer can be charged again for
     * @type {number}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    rechargeableQty?: number;
    /**
     * Determines the mode of refund initiation. Valid values are: WALMART_SETTLED_REFUND, SELLER_AUTO_REFUND, SELLER_MANUAL_REFUND, SELLER_SYSTEM_REFUND, and WALMART_TRIGGERED_REFUND.
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    refundChannel?: string;
    /**
     * Informational blocks added as the return order completes its journey from return creation to received and refunded.
     * @type {Array<InlineResponse2002ReturnTrackingDetail>}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    returnTrackingDetail?: Array<InlineResponse2002ReturnTrackingDetail>;
    /**
     * Current status of return. (e.g., \'INITIATED\')
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    status?: string;
    /**
     * Timestamp of listed status change
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    statusTime?: string;
    /**
     * Determines the current carrier tracking status of the return.
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    currentDeliveryStatus?: string;
    /**
     * Determines the current refund status of the return.
     * @type {string}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    currentRefundStatus?: string;
    /**
     * Array of current tracking status of each quantity
     * @type {Array<InlineResponse2002CurrentTrackingStatuses>}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    currentTrackingStatuses?: Array<InlineResponse2002CurrentTrackingStatuses>;
    /**
     * Array of refund channel of each quantity
     * @type {Array<InlineResponse2002RefundChannels>}
     * @memberof InlineResponse2002ReturnOrderLines
     */
    refundChannels?: Array<InlineResponse2002RefundChannels>;
}
/**
 * List of returns for the seller.
 * @export
 * @interface InlineResponse2002ReturnOrders
 */
export interface InlineResponse2002ReturnOrders {
    /**
     * Return order identifier of the return order. This is the same as RMA number.
     * @type {string}
     * @memberof InlineResponse2002ReturnOrders
     */
    returnOrderId?: string;
    /**
     * Customer email address
     * @type {string}
     * @memberof InlineResponse2002ReturnOrders
     */
    customerEmailId?: string;
    /**
     * Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
     * @type {string}
     * @memberof InlineResponse2002ReturnOrders
     */
    returnType?: string;
    /**
     * customer order ID of the original return order on which the replacement is created.
     * @type {string}
     * @memberof InlineResponse2002ReturnOrders
     */
    replacementCustomerOrderId?: string;
    /**
     * 
     * @type {InlineResponse2002CustomerName}
     * @memberof InlineResponse2002ReturnOrders
     */
    customerName?: InlineResponse2002CustomerName;
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof InlineResponse2002ReturnOrders
     */
    customerOrderId?: string;
    /**
     * Date format for return order date
     * @type {string}
     * @memberof InlineResponse2002ReturnOrders
     */
    returnOrderDate?: string;
    /**
     * Date format for return by order date
     * @type {string}
     * @memberof InlineResponse2002ReturnOrders
     */
    returnByDate?: string;
    /**
     * Determines when the refund was/will be issued to the customer
     * @type {string}
     * @memberof InlineResponse2002ReturnOrders
     */
    refundMode?: string;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof InlineResponse2002ReturnOrders
     */
    totalRefundAmount?: InlineResponse2002TotalRefundAmount;
    /**
     * These groups are created per label or type of carrier service required. (e.g., If order has some lines that can be clubbed and mailed together as a smart post then they belong to one return group. If a line is bulky and needs a different type of carrier service, then that line will be part of different group. Customer gets multiple labels depending on how many groups are created for the entire order.)
     * @type {Array<InlineResponse2002ReturnLineGroups>}
     * @memberof InlineResponse2002ReturnOrders
     */
    returnLineGroups?: Array<InlineResponse2002ReturnLineGroups>;
    /**
     * A list of order lines in the return order
     * @type {Array<InlineResponse2002ReturnOrderLines>}
     * @memberof InlineResponse2002ReturnOrders
     */
    returnOrderLines?: Array<InlineResponse2002ReturnOrderLines>;
    /**
     * 
     * @type {InlineResponse2002ReturnChannel}
     * @memberof InlineResponse2002ReturnOrders
     */
    returnChannel?: InlineResponse2002ReturnChannel;
}
/**
 * Informational blocks added as the return order completes its journey from return creation to received and refunded.
 * @export
 * @interface InlineResponse2002ReturnTrackingDetail
 */
export interface InlineResponse2002ReturnTrackingDetail {
    /**
     * The stage the return is in. (e.g., \'1\' is an initiated return)
     * @type {number}
     * @memberof InlineResponse2002ReturnTrackingDetail
     */
    sequenceNo?: number;
    /**
     * The last completed return event. (e.g., \'RETURN_IN_TRANSIT\')
     * @type {string}
     * @memberof InlineResponse2002ReturnTrackingDetail
     */
    eventTag?: string;
    /**
     * Description of current return status event. (e.g., \'A MARKET_PLACE Return in Transit\')
     * @type {string}
     * @memberof InlineResponse2002ReturnTrackingDetail
     */
    eventDescription?: string;
    /**
     * Timestamp of listed event
     * @type {string}
     * @memberof InlineResponse2002ReturnTrackingDetail
     */
    eventTime?: string;
    /**
     * Used only for 1P
     * @type {Array<InlineResponse2002References>}
     * @memberof InlineResponse2002ReturnTrackingDetail
     */
    references?: Array<InlineResponse2002References>;
}
/**
 * Taxes for each charge
 * @export
 * @interface InlineResponse2002Tax
 */
export interface InlineResponse2002Tax {
    /**
     * Name of the tax
     * @type {string}
     * @memberof InlineResponse2002Tax
     */
    taxName?: string;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof InlineResponse2002Tax
     */
    excessTax?: InlineResponse2002TotalRefundAmount;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof InlineResponse2002Tax
     */
    taxPerUnit?: InlineResponse2002TotalRefundAmount;
}
/**
 * Price of One unit of item, in this order line
 * @export
 * @interface InlineResponse2002TotalRefundAmount
 */
export interface InlineResponse2002TotalRefundAmount {
    /**
     * Amount to be refunded. It can be upto two decimal points.
     * @type {number}
     * @memberof InlineResponse2002TotalRefundAmount
     */
    currencyAmount: number;
    /**
     * Currency information
     * @type {string}
     * @memberof InlineResponse2002TotalRefundAmount
     */
    currencyUnit: string;
}
/**
 * Details of the item to be returned
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof Item
     */
    sku?: string;
    /**
     * The name of the product associated with the line item. Example: \'Kenmore CF1\' or \'2086883 Canister Secondary Filter Generic 2 Pack\'
     * @type {string}
     * @memberof Item
     */
    productName?: string;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof Item
     */
    itemWeight?: V3ReturnsReturnOrderIdRefundQuantity;
}
/**
 * Array of labels
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * Url to get the return label
     * @type {string}
     * @memberof Label
     */
    labelImageURL?: string;
    /**
     * Carrier information for the return
     * @type {Array<InlineResponse2002CarrierInfoList>}
     * @memberof Label
     */
    carrierInfoList?: Array<InlineResponse2002CarrierInfoList>;
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    totalCount: number;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    limit: number;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    nextCursor: string;
}
/**
 * Price of One unit of item, in this order line
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * Amount to be refunded. It can be upto two decimal points.
     * @type {number}
     * @memberof Money
     */
    currencyAmount: number;
    /**
     * Currency information
     * @type {string}
     * @memberof Money
     */
    currencyUnit: string;
}
/**
 * Used only for 1P
 * @export
 * @interface NameValue
 */
export interface NameValue {
    /**
     * 
     * @type {string}
     * @memberof NameValue
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NameValue
     */
    value: string;
}
/**
 * Total quantity returned in this return line
 * @export
 * @interface Quantity
 */
export interface Quantity {
    /**
     * The unit of measure in the item\'s weight (e.g., \'EACH\' or \'EA\')
     * @type {string}
     * @memberof Quantity
     */
    unitOfMeasure: string;
    /**
     * The quantity of the unit of measure for the item
     * @type {number}
     * @memberof Quantity
     */
    measurementValue: number;
}
/**
 * Array of refund channel of each quantity
 * @export
 * @interface RefundChannelInfo
 */
export interface RefundChannelInfo {
    /**
     * Valid values are: ONLINE, IN_STORE, and CUSTOMER_CARE
     * @type {string}
     * @memberof RefundChannelInfo
     */
    refundChannelName?: string;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof RefundChannelInfo
     */
    quantity?: V3ReturnsReturnOrderIdRefundQuantity;
}
/**
 * Array of refund lines.
 * @export
 * @interface RefundLine
 */
export interface RefundLine {
    /**
     * A line number associated with each individual line in the return order. If return order has only one return order line and it is not provided in the request, the only available return order line is auto-selected. If return order has multiple return order lines, the required return order line must be provided in the request. If not provided in the request, it will result in data-error.
     * @type {number}
     * @memberof RefundLine
     */
    returnOrderLineNumber: number;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof RefundLine
     */
    quantity?: V3ReturnsReturnOrderIdRefundQuantity;
}
/**
 * 
 * @export
 * @interface RefundRequest
 */
export interface RefundRequest {
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof RefundRequest
     */
    customerOrderId: string;
    /**
     * Array of refund lines.
     * @type {Array<V3ReturnsReturnOrderIdRefundRefundLines>}
     * @memberof RefundRequest
     */
    refundLines: Array<V3ReturnsReturnOrderIdRefundRefundLines>;
}
/**
 * 
 * @export
 * @interface RefundResponse
 */
export interface RefundResponse {
    /**
     * The return order id
     * @type {string}
     * @memberof RefundResponse
     */
    returnOrderId?: string;
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof RefundResponse
     */
    customerOrderId?: string;
    /**
     * Array of refund lines
     * @type {Array<V3ReturnsReturnOrderIdRefundRefundLines>}
     * @memberof RefundResponse
     */
    refundLines?: Array<V3ReturnsReturnOrderIdRefundRefundLines>;
}
/**
 * The channel via order return got initiated
 * @export
 * @interface ReturnChannel
 */
export interface ReturnChannel {
    /**
     * Valid values are: ONLINE, IN_STORE, and CUSTOMER_CARE
     * @type {string}
     * @memberof ReturnChannel
     */
    channelName?: string;
}
/**
 * Array of return lines
 * @export
 * @interface ReturnLine
 */
export interface ReturnLine {
    /**
     * Identifier of the return label
     * @type {number}
     * @memberof ReturnLine
     */
    returnOrderLineNumber?: number;
}
/**
 * These groups are created per label or type of carrier service required. (e.g., If order has some lines that can be clubbed and mailed together as a smart post then they belong to one return group. If a line is bulky and needs a different type of carrier service, then that line will be part of different group. Customer gets multiple labels depending on how many groups are created for the entire order.)
 * @export
 * @interface ReturnLineGroup
 */
export interface ReturnLineGroup {
    /**
     * Sequence of group numbers where each returnLineGroups will represent one or more return lines
     * @type {number}
     * @memberof ReturnLineGroup
     */
    groupNo?: number;
    /**
     * Array of return lines
     * @type {Array<InlineResponse2002ReturnLines>}
     * @memberof ReturnLineGroup
     */
    returnLines?: Array<InlineResponse2002ReturnLines>;
    /**
     * Array of labels
     * @type {Array<InlineResponse2002Labels>}
     * @memberof ReturnLineGroup
     */
    labels?: Array<InlineResponse2002Labels>;
    /**
     * Is customer required to send this item back to return center
     * @type {boolean}
     * @memberof ReturnLineGroup
     */
    returnExpectedFlag?: boolean;
}
/**
 * List of returns for the seller.
 * @export
 * @interface ReturnOrder
 */
export interface ReturnOrder {
    /**
     * Return order identifier of the return order. This is the same as RMA number.
     * @type {string}
     * @memberof ReturnOrder
     */
    returnOrderId?: string;
    /**
     * Customer email address
     * @type {string}
     * @memberof ReturnOrder
     */
    customerEmailId?: string;
    /**
     * Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
     * @type {string}
     * @memberof ReturnOrder
     */
    returnType?: string;
    /**
     * customer order ID of the original return order on which the replacement is created.
     * @type {string}
     * @memberof ReturnOrder
     */
    replacementCustomerOrderId?: string;
    /**
     * 
     * @type {InlineResponse2002CustomerName}
     * @memberof ReturnOrder
     */
    customerName?: InlineResponse2002CustomerName;
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof ReturnOrder
     */
    customerOrderId?: string;
    /**
     * Date format for return order date
     * @type {string}
     * @memberof ReturnOrder
     */
    returnOrderDate?: string;
    /**
     * Date format for return by order date
     * @type {string}
     * @memberof ReturnOrder
     */
    returnByDate?: string;
    /**
     * Determines when the refund was/will be issued to the customer
     * @type {string}
     * @memberof ReturnOrder
     */
    refundMode?: string;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof ReturnOrder
     */
    totalRefundAmount?: InlineResponse2002TotalRefundAmount;
    /**
     * These groups are created per label or type of carrier service required. (e.g., If order has some lines that can be clubbed and mailed together as a smart post then they belong to one return group. If a line is bulky and needs a different type of carrier service, then that line will be part of different group. Customer gets multiple labels depending on how many groups are created for the entire order.)
     * @type {Array<InlineResponse2002ReturnLineGroups>}
     * @memberof ReturnOrder
     */
    returnLineGroups?: Array<InlineResponse2002ReturnLineGroups>;
    /**
     * A list of order lines in the return order
     * @type {Array<InlineResponse2002ReturnOrderLines>}
     * @memberof ReturnOrder
     */
    returnOrderLines?: Array<InlineResponse2002ReturnOrderLines>;
    /**
     * 
     * @type {InlineResponse2002ReturnChannel}
     * @memberof ReturnOrder
     */
    returnChannel?: InlineResponse2002ReturnChannel;
}
/**
 * A list of order lines in the return order
 * @export
 * @interface ReturnOrderLine
 */
export interface ReturnOrderLine {
    /**
     * The returns order line number for that return
     * @type {number}
     * @memberof ReturnOrderLine
     */
    returnOrderLineNumber?: number;
    /**
     * The sales order line number for the return created
     * @type {number}
     * @memberof ReturnOrderLine
     */
    salesOrderLineNumber?: number;
    /**
     * A unique ID associated with the sales order for specified Seller; gives Sellers the ability to print their own custom order ID on the return label; limit of 30 characters
     * @type {string}
     * @memberof ReturnOrderLine
     */
    sellerOrderId?: string;
    /**
     * Gives the reason that was selected during the return creation. Reason codes are: ARRIVED_LATE, AUTO_RETURN, BOUGHT_ANOTHER_SIZE_OR_COLOR, BOUGHT_SOMEWHERE_ELSE, DAMAGED, DEFECTIVE, DUPLICATE_ITEM, INADEQUATE_QUALITY, INCORRECT_ITEM, LOST_AFTER_DELIVERY, LOST_IN_TRANSIT, LOWER_PRICE, MISSING_PARTS, NOT_AS_DESCRIBED, NO_LONGER_WANTED, RETURN_TO_SENDER, SHIPPING_BOX_DAMAGED, TRIED_TO_CANCEL and WRONG_SIZE/POOR_FIT
     * @type {string}
     * @memberof ReturnOrderLine
     */
    returnReason?: string;
    /**
     * The purchase order ID for the return created
     * @type {string}
     * @memberof ReturnOrderLine
     */
    purchaseOrderId?: string;
    /**
     * The purchase order line number for the return created
     * @type {number}
     * @memberof ReturnOrderLine
     */
    purchaseOrderLineNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderLine
     */
    exceptionItemType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    isReturnForException?: boolean;
    /**
     * reason for recharging the customer for replacement
     * @type {string}
     * @memberof ReturnOrderLine
     */
    rechargeReason?: string;
    /**
     * reason for cancelling the return
     * @type {string}
     * @memberof ReturnOrderLine
     */
    returnCancellationReason?: string;
    /**
     * 
     * @type {InlineResponse2002Item}
     * @memberof ReturnOrderLine
     */
    item?: InlineResponse2002Item;
    /**
     * Information relating to the charge for the orderLine
     * @type {Array<InlineResponse2002Charges>}
     * @memberof ReturnOrderLine
     */
    charges?: Array<InlineResponse2002Charges>;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof ReturnOrderLine
     */
    unitPrice?: InlineResponse2002TotalRefundAmount;
    /**
     * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
     * @type {Array<InlineResponse2002References>}
     * @memberof ReturnOrderLine
     */
    itemReturnSettings?: Array<InlineResponse2002References>;
    /**
     * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
     * @type {Array<InlineResponse2002ChargeTotals>}
     * @memberof ReturnOrderLine
     */
    chargeTotals?: Array<InlineResponse2002ChargeTotals>;
    /**
     * How much quantity of this order line can be cancelled
     * @type {number}
     * @memberof ReturnOrderLine
     */
    cancellableQty?: number;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof ReturnOrderLine
     */
    quantity?: V3ReturnsReturnOrderIdRefundQuantity;
    /**
     * Is customer required to send this item back to return center.
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    returnExpectedFlag?: boolean;
    /**
     * Applicable only for 1P.
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    isFastReplacement?: boolean;
    /**
     * Is customer allowed to keep the product and not required to send it back to return center. This flag is determined by making a call to fraud system.
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    isKeepIt?: boolean;
    /**
     * This return is the last item on the sales order line and all other sales order line items are already returned. Helps in last penny calculations.
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    lastItem?: boolean;
    /**
     * The quantity for which customer was refunded
     * @type {number}
     * @memberof ReturnOrderLine
     */
    refundedQty?: number;
    /**
     * The quantity for which customer can be charged again for
     * @type {number}
     * @memberof ReturnOrderLine
     */
    rechargeableQty?: number;
    /**
     * Determines the mode of refund initiation. Valid values are: WALMART_SETTLED_REFUND, SELLER_AUTO_REFUND, SELLER_MANUAL_REFUND, SELLER_SYSTEM_REFUND, and WALMART_TRIGGERED_REFUND.
     * @type {string}
     * @memberof ReturnOrderLine
     */
    refundChannel?: string;
    /**
     * Informational blocks added as the return order completes its journey from return creation to received and refunded.
     * @type {Array<InlineResponse2002ReturnTrackingDetail>}
     * @memberof ReturnOrderLine
     */
    returnTrackingDetail?: Array<InlineResponse2002ReturnTrackingDetail>;
    /**
     * Current status of return. (e.g., \'INITIATED\')
     * @type {string}
     * @memberof ReturnOrderLine
     */
    status?: string;
    /**
     * Timestamp of listed status change
     * @type {string}
     * @memberof ReturnOrderLine
     */
    statusTime?: string;
    /**
     * Determines the current carrier tracking status of the return.
     * @type {string}
     * @memberof ReturnOrderLine
     */
    currentDeliveryStatus?: string;
    /**
     * Determines the current refund status of the return.
     * @type {string}
     * @memberof ReturnOrderLine
     */
    currentRefundStatus?: string;
    /**
     * Array of current tracking status of each quantity
     * @type {Array<InlineResponse2002CurrentTrackingStatuses>}
     * @memberof ReturnOrderLine
     */
    currentTrackingStatuses?: Array<InlineResponse2002CurrentTrackingStatuses>;
    /**
     * Array of refund channel of each quantity
     * @type {Array<InlineResponse2002RefundChannels>}
     * @memberof ReturnOrderLine
     */
    refundChannels?: Array<InlineResponse2002RefundChannels>;
}
/**
 * Informational blocks added as the return order completes its journey from return creation to received and refunded.
 * @export
 * @interface ReturnTrackingDetail
 */
export interface ReturnTrackingDetail {
    /**
     * The stage the return is in. (e.g., \'1\' is an initiated return)
     * @type {number}
     * @memberof ReturnTrackingDetail
     */
    sequenceNo?: number;
    /**
     * The last completed return event. (e.g., \'RETURN_IN_TRANSIT\')
     * @type {string}
     * @memberof ReturnTrackingDetail
     */
    eventTag?: string;
    /**
     * Description of current return status event. (e.g., \'A MARKET_PLACE Return in Transit\')
     * @type {string}
     * @memberof ReturnTrackingDetail
     */
    eventDescription?: string;
    /**
     * Timestamp of listed event
     * @type {string}
     * @memberof ReturnTrackingDetail
     */
    eventTime?: string;
    /**
     * Used only for 1P
     * @type {Array<InlineResponse2002References>}
     * @memberof ReturnTrackingDetail
     */
    references?: Array<InlineResponse2002References>;
}
/**
 * Taxes for each charge
 * @export
 * @interface Tax
 */
export interface Tax {
    /**
     * Name of the tax
     * @type {string}
     * @memberof Tax
     */
    taxName?: string;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof Tax
     */
    excessTax?: InlineResponse2002TotalRefundAmount;
    /**
     * 
     * @type {InlineResponse2002TotalRefundAmount}
     * @memberof Tax
     */
    taxPerUnit?: InlineResponse2002TotalRefundAmount;
}
/**
 * Total quantity returned in this return line
 * @export
 * @interface V3ReturnsReturnOrderIdRefundQuantity
 */
export interface V3ReturnsReturnOrderIdRefundQuantity {
    /**
     * The unit of measure in the item\'s weight (e.g., \'EACH\' or \'EA\')
     * @type {string}
     * @memberof V3ReturnsReturnOrderIdRefundQuantity
     */
    unitOfMeasure: string;
    /**
     * The quantity of the unit of measure for the item
     * @type {number}
     * @memberof V3ReturnsReturnOrderIdRefundQuantity
     */
    measurementValue: number;
}
/**
 * Array of refund lines.
 * @export
 * @interface V3ReturnsReturnOrderIdRefundRefundLines
 */
export interface V3ReturnsReturnOrderIdRefundRefundLines {
    /**
     * A line number associated with each individual line in the return order. If return order has only one return order line and it is not provided in the request, the only available return order line is auto-selected. If return order has multiple return order lines, the required return order line must be provided in the request. If not provided in the request, it will result in data-error.
     * @type {number}
     * @memberof V3ReturnsReturnOrderIdRefundRefundLines
     */
    returnOrderLineNumber: number;
    /**
     * 
     * @type {V3ReturnsReturnOrderIdRefundQuantity}
     * @memberof V3ReturnsReturnOrderIdRefundRefundLines
     */
    quantity?: V3ReturnsReturnOrderIdRefundQuantity;
}

/**
 * ReturnsRefundsApi - axios parameter creator
 * @export
 */
export const ReturnsRefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sellers can specify global settings for returns in Seller Center, and they can override individual item level settings using this API.  Empty values for the settings will remove the existing overriden values and revert them to global settings.  For more details, see the announcement forÂ [Bulk Return Rules](https://sellerhelp.walmart.com/s/guide?article=000008197).
         * @summary Return Item Overrides
         * @param {string} feedType Feed Type
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {any} file Feed file to upload
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkItemOverrideFeed: async (feedType: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, file: any, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedType' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'feedType', feedType)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'file', file)
            const localVarPath = `/v3/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of return orders for the specified filter criteria.
         * @summary Returns
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [returnOrderId] Return order identifier of the return order object as part of array. This is the same as RMA number.
         * @param {string} [customerOrderId] A unique ID associated with the sales order for specified customer
         * @param {string} [status] Status may be specified to query the returns with specific status.Valid statuses are: INITIATED, DELIVERED, COMPLETED
         * @param {string} [replacementInfo] Provides additional attributes - replacementCustomerOrderID, returnType, rechargeReason, returnCancellationReason - related to Replacement return order, in response, if available. Allowed values are true or false.
         * @param {string} [returnType] Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
         * @param {string} [returnCreationStartDate] Start Date for querying all return orders that were created after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;
         * @param {string} [returnCreationEndDate] Limits the query to the return orders that were created before this returnCreationEndDate. Use one of the following formats, based on ISO 8601, are allowed: UTC date or timestamp. Examples: \&#39;2016-08-16T10:30:30.155Z\&#39; or \&#39;2016-08-16\&#39;
         * @param {string} [returnLastModifiedStartDate] Start Date for querying all return orders that were modified after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-17T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [returnLastModifiedEndDate] Limits the query to the return orders that were modified before this date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-18T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-18T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [limit] The number of orders to be returned. Cannot be larger than 200
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturns: async (wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, returnOrderId?: string, customerOrderId?: string, status?: string, replacementInfo?: string, returnType?: string, returnCreationStartDate?: string, returnCreationEndDate?: string, returnLastModifiedStartDate?: string, returnLastModifiedEndDate?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getReturns', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getReturns', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getReturns', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/returns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnOrderId !== undefined) {
                localVarQueryParameter['returnOrderId'] = returnOrderId;
            }

            if (customerOrderId !== undefined) {
                localVarQueryParameter['customerOrderId'] = customerOrderId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (replacementInfo !== undefined) {
                localVarQueryParameter['replacementInfo'] = replacementInfo;
            }

            if (returnType !== undefined) {
                localVarQueryParameter['returnType'] = returnType;
            }

            if (returnCreationStartDate !== undefined) {
                localVarQueryParameter['returnCreationStartDate'] = (returnCreationStartDate as any instanceof Date) ?
                    (returnCreationStartDate as any).toISOString() :
                    returnCreationStartDate;
            }

            if (returnCreationEndDate !== undefined) {
                localVarQueryParameter['returnCreationEndDate'] = (returnCreationEndDate as any instanceof Date) ?
                    (returnCreationEndDate as any).toISOString() :
                    returnCreationEndDate;
            }

            if (returnLastModifiedStartDate !== undefined) {
                localVarQueryParameter['returnLastModifiedStartDate'] = (returnLastModifiedStartDate as any instanceof Date) ?
                    (returnLastModifiedStartDate as any).toISOString() :
                    returnLastModifiedStartDate;
            }

            if (returnLastModifiedEndDate !== undefined) {
                localVarQueryParameter['returnLastModifiedEndDate'] = (returnLastModifiedEndDate as any instanceof Date) ?
                    (returnLastModifiedEndDate as any).toISOString() :
                    returnLastModifiedEndDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API allows sellers to issue refund against a return order. Multiple return order lines can be refunded in one request.  Note: Sellers can use the Refund Order Lines API for all non-exception category items, including adjustments that seller needs to determine a partial refund amount. Especially for exception category items: HAZMAT, OTHER and FREIGHT that are not eligible for the Marketplace Returns Program. 
         * @summary Issue refund
         * @param {string} returnOrderId The return order ID
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRefund: async (returnOrderId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'returnOrderId' is not null or undefined
            assertParamExists('issueRefund', 'returnOrderId', returnOrderId)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('issueRefund', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('issueRefund', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('issueRefund', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('issueRefund', 'inlineObject', inlineObject)
            const localVarPath = `/v3/returns/{returnOrderId}/refund`
                .replace(`{${"returnOrderId"}}`, encodeURIComponent(String(returnOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReturnsRefundsApi - functional programming interface
 * @export
 */
export const ReturnsRefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReturnsRefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * Sellers can specify global settings for returns in Seller Center, and they can override individual item level settings using this API.  Empty values for the settings will remove the existing overriden values and revert them to global settings.  For more details, see the announcement forÂ [Bulk Return Rules](https://sellerhelp.walmart.com/s/guide?article=000008197).
         * @summary Return Item Overrides
         * @param {string} feedType Feed Type
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {any} file Feed file to upload
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkItemOverrideFeed(feedType: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, file: any, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkItemOverrideFeed(feedType, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, file, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of return orders for the specified filter criteria.
         * @summary Returns
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [returnOrderId] Return order identifier of the return order object as part of array. This is the same as RMA number.
         * @param {string} [customerOrderId] A unique ID associated with the sales order for specified customer
         * @param {string} [status] Status may be specified to query the returns with specific status.Valid statuses are: INITIATED, DELIVERED, COMPLETED
         * @param {string} [replacementInfo] Provides additional attributes - replacementCustomerOrderID, returnType, rechargeReason, returnCancellationReason - related to Replacement return order, in response, if available. Allowed values are true or false.
         * @param {string} [returnType] Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
         * @param {string} [returnCreationStartDate] Start Date for querying all return orders that were created after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;
         * @param {string} [returnCreationEndDate] Limits the query to the return orders that were created before this returnCreationEndDate. Use one of the following formats, based on ISO 8601, are allowed: UTC date or timestamp. Examples: \&#39;2016-08-16T10:30:30.155Z\&#39; or \&#39;2016-08-16\&#39;
         * @param {string} [returnLastModifiedStartDate] Start Date for querying all return orders that were modified after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-17T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [returnLastModifiedEndDate] Limits the query to the return orders that were modified before this date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-18T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-18T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [limit] The number of orders to be returned. Cannot be larger than 200
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturns(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, returnOrderId?: string, customerOrderId?: string, status?: string, replacementInfo?: string, returnType?: string, returnCreationStartDate?: string, returnCreationEndDate?: string, returnLastModifiedStartDate?: string, returnLastModifiedEndDate?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturns(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, returnOrderId, customerOrderId, status, replacementInfo, returnType, returnCreationStartDate, returnCreationEndDate, returnLastModifiedStartDate, returnLastModifiedEndDate, limit, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API allows sellers to issue refund against a return order. Multiple return order lines can be refunded in one request.  Note: Sellers can use the Refund Order Lines API for all non-exception category items, including adjustments that seller needs to determine a partial refund amount. Especially for exception category items: HAZMAT, OTHER and FREIGHT that are not eligible for the Marketplace Returns Program. 
         * @summary Issue refund
         * @param {string} returnOrderId The return order ID
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRefund(returnOrderId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRefund(returnOrderId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReturnsRefundsApi - factory interface
 * @export
 */
export const ReturnsRefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReturnsRefundsApiFp(configuration)
    return {
        /**
         * Sellers can specify global settings for returns in Seller Center, and they can override individual item level settings using this API.  Empty values for the settings will remove the existing overriden values and revert them to global settings.  For more details, see the announcement forÂ [Bulk Return Rules](https://sellerhelp.walmart.com/s/guide?article=000008197).
         * @summary Return Item Overrides
         * @param {string} feedType Feed Type
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {any} file Feed file to upload
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkItemOverrideFeed(feedType: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, file: any, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.bulkItemOverrideFeed(feedType, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, file, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of return orders for the specified filter criteria.
         * @summary Returns
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [returnOrderId] Return order identifier of the return order object as part of array. This is the same as RMA number.
         * @param {string} [customerOrderId] A unique ID associated with the sales order for specified customer
         * @param {string} [status] Status may be specified to query the returns with specific status.Valid statuses are: INITIATED, DELIVERED, COMPLETED
         * @param {string} [replacementInfo] Provides additional attributes - replacementCustomerOrderID, returnType, rechargeReason, returnCancellationReason - related to Replacement return order, in response, if available. Allowed values are true or false.
         * @param {string} [returnType] Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
         * @param {string} [returnCreationStartDate] Start Date for querying all return orders that were created after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;
         * @param {string} [returnCreationEndDate] Limits the query to the return orders that were created before this returnCreationEndDate. Use one of the following formats, based on ISO 8601, are allowed: UTC date or timestamp. Examples: \&#39;2016-08-16T10:30:30.155Z\&#39; or \&#39;2016-08-16\&#39;
         * @param {string} [returnLastModifiedStartDate] Start Date for querying all return orders that were modified after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-17T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [returnLastModifiedEndDate] Limits the query to the return orders that were modified before this date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-18T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-18T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [limit] The number of orders to be returned. Cannot be larger than 200
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturns(wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, returnOrderId?: string, customerOrderId?: string, status?: string, replacementInfo?: string, returnType?: string, returnCreationStartDate?: string, returnCreationEndDate?: string, returnLastModifiedStartDate?: string, returnLastModifiedEndDate?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getReturns(wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, returnOrderId, customerOrderId, status, replacementInfo, returnType, returnCreationStartDate, returnCreationEndDate, returnLastModifiedStartDate, returnLastModifiedEndDate, limit, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API allows sellers to issue refund against a return order. Multiple return order lines can be refunded in one request.  Note: Sellers can use the Refund Order Lines API for all non-exception category items, including adjustments that seller needs to determine a partial refund amount. Especially for exception category items: HAZMAT, OTHER and FREIGHT that are not eligible for the Marketplace Returns Program. 
         * @summary Issue refund
         * @param {string} returnOrderId The return order ID
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRefund(returnOrderId: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.issueRefund(returnOrderId, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkItemOverrideFeed operation in ReturnsRefundsApi.
 * @export
 * @interface ReturnsRefundsApiBulkItemOverrideFeedRequest
 */
export interface ReturnsRefundsApiBulkItemOverrideFeedRequest {
    /**
     * Feed Type
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly feedType: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly wMSVCNAME: string

    /**
     * Feed file to upload
     * @type {any}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly file: any

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getReturns operation in ReturnsRefundsApi.
 * @export
 * @interface ReturnsRefundsApiGetReturnsRequest
 */
export interface ReturnsRefundsApiGetReturnsRequest {
    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly wMSVCNAME: string

    /**
     * Return order identifier of the return order object as part of array. This is the same as RMA number.
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnOrderId?: string

    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly customerOrderId?: string

    /**
     * Status may be specified to query the returns with specific status.Valid statuses are: INITIATED, DELIVERED, COMPLETED
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly status?: string

    /**
     * Provides additional attributes - replacementCustomerOrderID, returnType, rechargeReason, returnCancellationReason - related to Replacement return order, in response, if available. Allowed values are true or false.
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly replacementInfo?: string

    /**
     * Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnType?: string

    /**
     * Start Date for querying all return orders that were created after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnCreationStartDate?: string

    /**
     * Limits the query to the return orders that were created before this returnCreationEndDate. Use one of the following formats, based on ISO 8601, are allowed: UTC date or timestamp. Examples: \&#39;2016-08-16T10:30:30.155Z\&#39; or \&#39;2016-08-16\&#39;
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnCreationEndDate?: string

    /**
     * Start Date for querying all return orders that were modified after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-17T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnLastModifiedStartDate?: string

    /**
     * Limits the query to the return orders that were modified before this date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-18T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-18T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnLastModifiedEndDate?: string

    /**
     * The number of orders to be returned. Cannot be larger than 200
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly limit?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for issueRefund operation in ReturnsRefundsApi.
 * @export
 * @interface ReturnsRefundsApiIssueRefundRequest
 */
export interface ReturnsRefundsApiIssueRefundRequest {
    /**
     * The return order ID
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly returnOrderId: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly inlineObject: InlineObject

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * ReturnsRefundsApi - object-oriented interface
 * @export
 * @class ReturnsRefundsApi
 * @extends {BaseAPI}
 */
export class ReturnsRefundsApi extends BaseAPI {
    /**
     * Sellers can specify global settings for returns in Seller Center, and they can override individual item level settings using this API.  Empty values for the settings will remove the existing overriden values and revert them to global settings.  For more details, see the announcement forÂ [Bulk Return Rules](https://sellerhelp.walmart.com/s/guide?article=000008197).
     * @summary Return Item Overrides
     * @param {ReturnsRefundsApiBulkItemOverrideFeedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnsRefundsApi
     */
    public bulkItemOverrideFeed(requestParameters: ReturnsRefundsApiBulkItemOverrideFeedRequest, options?: any) {
        return ReturnsRefundsApiFp(this.configuration).bulkItemOverrideFeed(requestParameters.feedType, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.file, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of return orders for the specified filter criteria.
     * @summary Returns
     * @param {ReturnsRefundsApiGetReturnsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnsRefundsApi
     */
    public getReturns(requestParameters: ReturnsRefundsApiGetReturnsRequest, options?: any) {
        return ReturnsRefundsApiFp(this.configuration).getReturns(requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.returnOrderId, requestParameters.customerOrderId, requestParameters.status, requestParameters.replacementInfo, requestParameters.returnType, requestParameters.returnCreationStartDate, requestParameters.returnCreationEndDate, requestParameters.returnLastModifiedStartDate, requestParameters.returnLastModifiedEndDate, requestParameters.limit, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API allows sellers to issue refund against a return order. Multiple return order lines can be refunded in one request.  Note: Sellers can use the Refund Order Lines API for all non-exception category items, including adjustments that seller needs to determine a partial refund amount. Especially for exception category items: HAZMAT, OTHER and FREIGHT that are not eligible for the Marketplace Returns Program. 
     * @summary Issue refund
     * @param {ReturnsRefundsApiIssueRefundRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnsRefundsApi
     */
    public issueRefund(requestParameters: ReturnsRefundsApiIssueRefundRequest, options?: any) {
        return ReturnsRefundsApiFp(this.configuration).issueRefund(requestParameters.returnOrderId, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


