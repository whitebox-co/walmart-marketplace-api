/* tslint:disable */
/* eslint-disable */
/**
 * Returns Management
 * Buyers can now Initiate Returns from Walmart.com for Marketplace seller items (Except for HAZMAT, OTHER or FREIGHT items). For item in the exception categories: HAZMAT or OTHER, sellers need to generate the return shipping label, and upload the label. For detailed instructions, and to download the Returns API JSON schema, see Returns guide.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Carrier information for the return
 * @export
 * @interface CarrierInfoList
 */
export interface CarrierInfoList {
    /**
     * ID of the carrier used for the return
     * @type {string}
     * @memberof CarrierInfoList
     */
    carrierId?: string;
    /**
     * Name of the carrier used
     * @type {string}
     * @memberof CarrierInfoList
     */
    carrierName?: string;
    /**
     * the type of service used
     * @type {string}
     * @memberof CarrierInfoList
     */
    serviceType?: string;
    /**
     * Tracking number of the order
     * @type {string}
     * @memberof CarrierInfoList
     */
    trackingNo?: string;
}
/**
 * Information relating to the charge for the orderLine
 * @export
 * @interface Charge
 */
export interface Charge {
    /**
     * The category type. (e.g., \'PRODUCT\' or \'FEE\')
     * @type {string}
     * @memberof Charge
     */
    chargeCategory?: string;
    /**
     * If chargeType is PRODUCT, chargeName is Item Price. If chargeType is SHIPPING, chargeName is Shipping
     * @type {string}
     * @memberof Charge
     */
    chargeName?: string;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof Charge
     */
    chargePerUnit?: InlineResponse200TotalRefundAmount;
    /**
     * Is this charge a discount, which then needs to be subtracted from the refund
     * @type {boolean}
     * @memberof Charge
     */
    isDiscount?: boolean;
    /**
     * Should this charge be included in the refund computation 
     * @type {boolean}
     * @memberof Charge
     */
    isBillable?: boolean;
    /**
     * Taxes for each charge
     * @type {Array<InlineResponse200Tax>}
     * @memberof Charge
     */
    tax?: Array<InlineResponse200Tax>;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof Charge
     */
    excessCharge?: InlineResponse200TotalRefundAmount;
    /**
     * Used only for OG
     * @type {Array<InlineResponse200References>}
     * @memberof Charge
     */
    references?: Array<InlineResponse200References>;
}
/**
 * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
 * @export
 * @interface ChargeTotal
 */
export interface ChargeTotal {
    /**
     * Charge Names: lineUnitPrice, lineProductTaxes, lineTotalTaxes, lineRestockingFee, lineShippingFee, lineSubTotal, lineTotal.
     * @type {string}
     * @memberof ChargeTotal
     */
    name: string;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof ChargeTotal
     */
    value: InlineResponse200TotalRefundAmount;
}
/**
 * Customer information
 * @export
 * @interface CustomerName
 */
export interface CustomerName {
    /**
     * Customer first name
     * @type {string}
     * @memberof CustomerName
     */
    firstName?: string;
    /**
     * Customer last name
     * @type {string}
     * @memberof CustomerName
     */
    lastName?: string;
}
/**
 * 
 * @export
 * @interface FeedId
 */
export interface FeedId {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the Feed File.
     * @type {string}
     * @memberof FeedId
     */
    feedId?: string;
}
/**
 * 
 * @export
 * @interface GetReturnOrdersResponse
 */
export interface GetReturnOrdersResponse {
    /**
     * 
     * @type {InlineResponse200Meta}
     * @memberof GetReturnOrdersResponse
     */
    meta: InlineResponse200Meta;
    /**
     * List of returns for the seller.
     * @type {Array<InlineResponse200ReturnOrders>}
     * @memberof GetReturnOrdersResponse
     */
    returnOrders: Array<InlineResponse200ReturnOrders>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof InlineObject
     */
    customerOrderId: string;
    /**
     * Array of refund lines.
     * @type {Array<V3ReturnsReturnOrderIdRefundRefundLines>}
     * @memberof InlineObject
     */
    refundLines: Array<V3ReturnsReturnOrderIdRefundRefundLines>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse200
     */
    meta: InlineResponse200Meta;
    /**
     * List of returns for the seller.
     * @type {Array<InlineResponse200ReturnOrders>}
     * @memberof InlineResponse200
     */
    returnOrders: Array<InlineResponse200ReturnOrders>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * The return order id
     * @type {string}
     * @memberof InlineResponse2001
     */
    returnOrderId?: string;
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof InlineResponse2001
     */
    customerOrderId?: string;
    /**
     * Array of refund lines
     * @type {Array<V3ReturnsReturnOrderIdRefundRefundLines>}
     * @memberof InlineResponse2001
     */
    refundLines?: Array<V3ReturnsReturnOrderIdRefundRefundLines>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * A unique ID, returned from the Bulk Upload API, used for tracking the Feed File.
     * @type {string}
     * @memberof InlineResponse2002
     */
    feedId?: string;
}
/**
 * Carrier information for the return
 * @export
 * @interface InlineResponse200CarrierInfoList
 */
export interface InlineResponse200CarrierInfoList {
    /**
     * ID of the carrier used for the return
     * @type {string}
     * @memberof InlineResponse200CarrierInfoList
     */
    carrierId?: string;
    /**
     * Name of the carrier used
     * @type {string}
     * @memberof InlineResponse200CarrierInfoList
     */
    carrierName?: string;
    /**
     * the type of service used
     * @type {string}
     * @memberof InlineResponse200CarrierInfoList
     */
    serviceType?: string;
    /**
     * Tracking number of the order
     * @type {string}
     * @memberof InlineResponse200CarrierInfoList
     */
    trackingNo?: string;
}
/**
 * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
 * @export
 * @interface InlineResponse200ChargeTotals
 */
export interface InlineResponse200ChargeTotals {
    /**
     * Charge Names: lineUnitPrice, lineProductTaxes, lineTotalTaxes, lineRestockingFee, lineShippingFee, lineSubTotal, lineTotal.
     * @type {string}
     * @memberof InlineResponse200ChargeTotals
     */
    name: string;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof InlineResponse200ChargeTotals
     */
    value: InlineResponse200TotalRefundAmount;
}
/**
 * Information relating to the charge for the orderLine
 * @export
 * @interface InlineResponse200Charges
 */
export interface InlineResponse200Charges {
    /**
     * The category type. (e.g., \'PRODUCT\' or \'FEE\')
     * @type {string}
     * @memberof InlineResponse200Charges
     */
    chargeCategory?: string;
    /**
     * If chargeType is PRODUCT, chargeName is Item Price. If chargeType is SHIPPING, chargeName is Shipping
     * @type {string}
     * @memberof InlineResponse200Charges
     */
    chargeName?: string;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof InlineResponse200Charges
     */
    chargePerUnit?: InlineResponse200TotalRefundAmount;
    /**
     * Is this charge a discount, which then needs to be subtracted from the refund
     * @type {boolean}
     * @memberof InlineResponse200Charges
     */
    isDiscount?: boolean;
    /**
     * Should this charge be included in the refund computation 
     * @type {boolean}
     * @memberof InlineResponse200Charges
     */
    isBillable?: boolean;
    /**
     * Taxes for each charge
     * @type {Array<InlineResponse200Tax>}
     * @memberof InlineResponse200Charges
     */
    tax?: Array<InlineResponse200Tax>;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof InlineResponse200Charges
     */
    excessCharge?: InlineResponse200TotalRefundAmount;
    /**
     * Used only for OG
     * @type {Array<InlineResponse200References>}
     * @memberof InlineResponse200Charges
     */
    references?: Array<InlineResponse200References>;
}
/**
 * Customer information
 * @export
 * @interface InlineResponse200CustomerName
 */
export interface InlineResponse200CustomerName {
    /**
     * Customer first name
     * @type {string}
     * @memberof InlineResponse200CustomerName
     */
    firstName?: string;
    /**
     * Customer last name
     * @type {string}
     * @memberof InlineResponse200CustomerName
     */
    lastName?: string;
}
/**
 * Details of the item to be returned
 * @export
 * @interface InlineResponse200Item
 */
export interface InlineResponse200Item {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof InlineResponse200Item
     */
    sku?: string;
    /**
     * The name of the product associated with the line item. Example: \'Kenmore CF1\' or \'2086883 Canister Secondary Filter Generic 2 Pack\'
     * @type {string}
     * @memberof InlineResponse200Item
     */
    productName?: string;
    /**
     * 
     * @type {InlineResponse200ItemItemWeight}
     * @memberof InlineResponse200Item
     */
    itemWeight?: InlineResponse200ItemItemWeight;
}
/**
 * Total quantity returned in this return line
 * @export
 * @interface InlineResponse200ItemItemWeight
 */
export interface InlineResponse200ItemItemWeight {
    /**
     * The unit of measure in the item\'s weight (e.g., \'POUND\' or \'OUNCE\')
     * @type {string}
     * @memberof InlineResponse200ItemItemWeight
     */
    unitOfMeasure: string;
    /**
     * The quantity of the unit of measure for the item
     * @type {number}
     * @memberof InlineResponse200ItemItemWeight
     */
    measurementValue: number;
}
/**
 * Array of labels
 * @export
 * @interface InlineResponse200Labels
 */
export interface InlineResponse200Labels {
    /**
     * Url to get the return label
     * @type {string}
     * @memberof InlineResponse200Labels
     */
    labelImageURL?: string;
    /**
     * Carrier information for the return
     * @type {Array<InlineResponse200CarrierInfoList>}
     * @memberof InlineResponse200Labels
     */
    carrierInfoList?: Array<InlineResponse200CarrierInfoList>;
}
/**
 * 
 * @export
 * @interface InlineResponse200Meta
 */
export interface InlineResponse200Meta {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200Meta
     */
    totalCount: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200Meta
     */
    limit: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Meta
     */
    nextCursor: string;
}
/**
 * Used only for 1P
 * @export
 * @interface InlineResponse200References
 */
export interface InlineResponse200References {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200References
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200References
     */
    value: string;
}
/**
 * The channel via order return got initiated
 * @export
 * @interface InlineResponse200ReturnChannel
 */
export interface InlineResponse200ReturnChannel {
    /**
     * Valid values are: ONLINE, IN_STORE, and CUSTOMER_CARE
     * @type {string}
     * @memberof InlineResponse200ReturnChannel
     */
    channelName?: string;
}
/**
 * These groups are created per label or type of carrier service required. (e.g., If order has some lines that can be clubbed and mailed together as a smart post then they belong to one return group. If a line is bulky and needs a different type of carrier service, then that line will be part of different group. Customer gets multiple labels depending on how many groups are created for the entire order.)
 * @export
 * @interface InlineResponse200ReturnLineGroups
 */
export interface InlineResponse200ReturnLineGroups {
    /**
     * Sequence of group numbers where each returnLineGroups will represent one or more return lines
     * @type {number}
     * @memberof InlineResponse200ReturnLineGroups
     */
    groupNo?: number;
    /**
     * Array of return lines
     * @type {Array<InlineResponse200ReturnLines>}
     * @memberof InlineResponse200ReturnLineGroups
     */
    returnLines?: Array<InlineResponse200ReturnLines>;
    /**
     * Array of labels
     * @type {Array<InlineResponse200Labels>}
     * @memberof InlineResponse200ReturnLineGroups
     */
    labels?: Array<InlineResponse200Labels>;
    /**
     * Is customer required to send this item back to return center
     * @type {boolean}
     * @memberof InlineResponse200ReturnLineGroups
     */
    returnExpectedFlag?: boolean;
}
/**
 * Array of return lines
 * @export
 * @interface InlineResponse200ReturnLines
 */
export interface InlineResponse200ReturnLines {
    /**
     * Identifier of the return label
     * @type {number}
     * @memberof InlineResponse200ReturnLines
     */
    returnOrderLineNumber?: number;
}
/**
 * A list of order lines in the return order
 * @export
 * @interface InlineResponse200ReturnOrderLines
 */
export interface InlineResponse200ReturnOrderLines {
    /**
     * The returns order line number for that return
     * @type {number}
     * @memberof InlineResponse200ReturnOrderLines
     */
    returnOrderLineNumber?: number;
    /**
     * The sales order line number for the return created
     * @type {number}
     * @memberof InlineResponse200ReturnOrderLines
     */
    salesOrderLineNumber?: number;
    /**
     * A unique ID associated with the sales order for specified Seller; gives Sellers the ability to print their own custom order ID on the return label; limit of 30 characters
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    sellerOrderId?: string;
    /**
     * Gives the reason that was selected during the return creation. Reason codes are: ARRIVED_LATE, AUTO_RETURN, BOUGHT_ANOTHER_SIZE_OR_COLOR, BOUGHT_SOMEWHERE_ELSE, DAMAGED, DEFECTIVE, DUPLICATE_ITEM, INADEQUATE_QUALITY, INCORRECT_ITEM, LOST_AFTER_DELIVERY, LOST_IN_TRANSIT, LOWER_PRICE, MISSING_PARTS, NOT_AS_DESCRIBED, NO_LONGER_WANTED, RETURN_TO_SENDER, SHIPPING_BOX_DAMAGED, TRIED_TO_CANCEL and WRONG_SIZE/POOR_FIT
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    returnReason?: string;
    /**
     * The purchase order ID for the return created
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    purchaseOrderId?: string;
    /**
     * The purchase order line number for the return created
     * @type {number}
     * @memberof InlineResponse200ReturnOrderLines
     */
    purchaseOrderLineNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    exceptionItemType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200ReturnOrderLines
     */
    isReturnForException?: boolean;
    /**
     * reason for recharging the customer for replacement
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    rechargeReason?: string;
    /**
     * reason for cancelling the return
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    returnCancellationReason?: string;
    /**
     * 
     * @type {InlineResponse200Item}
     * @memberof InlineResponse200ReturnOrderLines
     */
    item?: InlineResponse200Item;
    /**
     * Information relating to the charge for the orderLine
     * @type {Array<InlineResponse200Charges>}
     * @memberof InlineResponse200ReturnOrderLines
     */
    charges?: Array<InlineResponse200Charges>;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof InlineResponse200ReturnOrderLines
     */
    unitPrice?: InlineResponse200TotalRefundAmount;
    /**
     * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
     * @type {Array<InlineResponse200References>}
     * @memberof InlineResponse200ReturnOrderLines
     */
    itemReturnSettings?: Array<InlineResponse200References>;
    /**
     * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
     * @type {Array<InlineResponse200ChargeTotals>}
     * @memberof InlineResponse200ReturnOrderLines
     */
    chargeTotals?: Array<InlineResponse200ChargeTotals>;
    /**
     * How much quantity of this order line can be cancelled
     * @type {number}
     * @memberof InlineResponse200ReturnOrderLines
     */
    cancellableQty?: number;
    /**
     * 
     * @type {InlineResponse200ItemItemWeight}
     * @memberof InlineResponse200ReturnOrderLines
     */
    quantity?: InlineResponse200ItemItemWeight;
    /**
     * Is customer required to send this item back to return center.
     * @type {boolean}
     * @memberof InlineResponse200ReturnOrderLines
     */
    returnExpectedFlag?: boolean;
    /**
     * Applicable only for 1P.
     * @type {boolean}
     * @memberof InlineResponse200ReturnOrderLines
     */
    isFastReplacement?: boolean;
    /**
     * Is customer allowed to keep the product and not required to send it back to return center. This flag is determined by making a call to fraud system.
     * @type {boolean}
     * @memberof InlineResponse200ReturnOrderLines
     */
    isKeepIt?: boolean;
    /**
     * This return is the last item on the sales order line and all other sales order line items are already returned. Helps in last penny calculations.
     * @type {boolean}
     * @memberof InlineResponse200ReturnOrderLines
     */
    lastItem?: boolean;
    /**
     * The quantity for which customer was refunded
     * @type {number}
     * @memberof InlineResponse200ReturnOrderLines
     */
    refundedQty?: number;
    /**
     * The quantity for which customer can be charged again for
     * @type {number}
     * @memberof InlineResponse200ReturnOrderLines
     */
    rechargeableQty?: number;
    /**
     * Determines the mode of refund initiation. Valid values are: WALMART_SETTLED_REFUND, SELLER_AUTO_REFUND, SELLER_MANUAL_REFUND, SELLER_SYSTEM_REFUND, and WALMART_TRIGGERED_REFUND.
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    refundChannel?: string;
    /**
     * Informational blocks added as the return order completes its journey from return creation to received and refunded.
     * @type {Array<InlineResponse200ReturnTrackingDetail>}
     * @memberof InlineResponse200ReturnOrderLines
     */
    returnTrackingDetail?: Array<InlineResponse200ReturnTrackingDetail>;
    /**
     * Current status of return. (e.g., \'INITIATED\')
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    status?: string;
    /**
     * Timestamp of listed status change
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    statusTime?: string;
    /**
     * Determines the current carrier tracking status of the return.
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    currentDeliveryStatus?: string;
    /**
     * Determines the current refund status of the return.
     * @type {string}
     * @memberof InlineResponse200ReturnOrderLines
     */
    currentRefundStatus?: string;
}
/**
 * List of returns for the seller.
 * @export
 * @interface InlineResponse200ReturnOrders
 */
export interface InlineResponse200ReturnOrders {
    /**
     * Return order identifier of the return order. This is the same as RMA number.
     * @type {string}
     * @memberof InlineResponse200ReturnOrders
     */
    returnOrderId?: string;
    /**
     * Customer email address
     * @type {string}
     * @memberof InlineResponse200ReturnOrders
     */
    customerEmailId?: string;
    /**
     * Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
     * @type {string}
     * @memberof InlineResponse200ReturnOrders
     */
    returnType?: string;
    /**
     * customer order ID of the original return order on which the replacement is created.
     * @type {string}
     * @memberof InlineResponse200ReturnOrders
     */
    replacementCustomerOrderId?: string;
    /**
     * 
     * @type {InlineResponse200CustomerName}
     * @memberof InlineResponse200ReturnOrders
     */
    customerName?: InlineResponse200CustomerName;
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof InlineResponse200ReturnOrders
     */
    customerOrderId?: string;
    /**
     * Date format for return order date
     * @type {string}
     * @memberof InlineResponse200ReturnOrders
     */
    returnOrderDate?: string;
    /**
     * Date format for return by order date
     * @type {string}
     * @memberof InlineResponse200ReturnOrders
     */
    returnByDate?: string;
    /**
     * Determines when the refund was/will be issued to the customer
     * @type {string}
     * @memberof InlineResponse200ReturnOrders
     */
    refundMode?: string;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof InlineResponse200ReturnOrders
     */
    totalRefundAmount?: InlineResponse200TotalRefundAmount;
    /**
     * These groups are created per label or type of carrier service required. (e.g., If order has some lines that can be clubbed and mailed together as a smart post then they belong to one return group. If a line is bulky and needs a different type of carrier service, then that line will be part of different group. Customer gets multiple labels depending on how many groups are created for the entire order.)
     * @type {Array<InlineResponse200ReturnLineGroups>}
     * @memberof InlineResponse200ReturnOrders
     */
    returnLineGroups?: Array<InlineResponse200ReturnLineGroups>;
    /**
     * A list of order lines in the return order
     * @type {Array<InlineResponse200ReturnOrderLines>}
     * @memberof InlineResponse200ReturnOrders
     */
    returnOrderLines?: Array<InlineResponse200ReturnOrderLines>;
    /**
     * 
     * @type {InlineResponse200ReturnChannel}
     * @memberof InlineResponse200ReturnOrders
     */
    returnChannel?: InlineResponse200ReturnChannel;
}
/**
 * Informational blocks added as the return order completes its journey from return creation to received and refunded.
 * @export
 * @interface InlineResponse200ReturnTrackingDetail
 */
export interface InlineResponse200ReturnTrackingDetail {
    /**
     * The stage the return is in. (e.g., \'1\' is an initiated return)
     * @type {number}
     * @memberof InlineResponse200ReturnTrackingDetail
     */
    sequenceNo?: number;
    /**
     * The last completed return event. (e.g., \'RETURN_IN_TRANSIT\')
     * @type {string}
     * @memberof InlineResponse200ReturnTrackingDetail
     */
    eventTag?: string;
    /**
     * Description of current return status event. (e.g., \'A MARKET_PLACE Return in Transit\')
     * @type {string}
     * @memberof InlineResponse200ReturnTrackingDetail
     */
    eventDescription?: string;
    /**
     * Timestamp of listed event
     * @type {string}
     * @memberof InlineResponse200ReturnTrackingDetail
     */
    eventTime?: string;
    /**
     * Used only for 1P
     * @type {Array<InlineResponse200References>}
     * @memberof InlineResponse200ReturnTrackingDetail
     */
    references?: Array<InlineResponse200References>;
}
/**
 * Taxes for each charge
 * @export
 * @interface InlineResponse200Tax
 */
export interface InlineResponse200Tax {
    /**
     * Name of the tax
     * @type {string}
     * @memberof InlineResponse200Tax
     */
    taxName?: string;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof InlineResponse200Tax
     */
    excessTax?: InlineResponse200TotalRefundAmount;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof InlineResponse200Tax
     */
    taxPerUnit?: InlineResponse200TotalRefundAmount;
}
/**
 * Price of One unit of item, in this order line
 * @export
 * @interface InlineResponse200TotalRefundAmount
 */
export interface InlineResponse200TotalRefundAmount {
    /**
     * Amount to be refunded. It can be upto two decimal points.
     * @type {number}
     * @memberof InlineResponse200TotalRefundAmount
     */
    currencyAmount: number;
    /**
     * Currency information
     * @type {string}
     * @memberof InlineResponse200TotalRefundAmount
     */
    currencyUnit: string;
}
/**
 * Details of the item to be returned
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item.
     * @type {string}
     * @memberof Item
     */
    sku?: string;
    /**
     * The name of the product associated with the line item. Example: \'Kenmore CF1\' or \'2086883 Canister Secondary Filter Generic 2 Pack\'
     * @type {string}
     * @memberof Item
     */
    productName?: string;
    /**
     * 
     * @type {InlineResponse200ItemItemWeight}
     * @memberof Item
     */
    itemWeight?: InlineResponse200ItemItemWeight;
}
/**
 * Array of labels
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * Url to get the return label
     * @type {string}
     * @memberof Label
     */
    labelImageURL?: string;
    /**
     * Carrier information for the return
     * @type {Array<InlineResponse200CarrierInfoList>}
     * @memberof Label
     */
    carrierInfoList?: Array<InlineResponse200CarrierInfoList>;
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    totalCount: number;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    limit: number;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    nextCursor: string;
}
/**
 * Price of One unit of item, in this order line
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * Amount to be refunded. It can be upto two decimal points.
     * @type {number}
     * @memberof Money
     */
    currencyAmount: number;
    /**
     * Currency information
     * @type {string}
     * @memberof Money
     */
    currencyUnit: string;
}
/**
 * Used only for 1P
 * @export
 * @interface NameValue
 */
export interface NameValue {
    /**
     * 
     * @type {string}
     * @memberof NameValue
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NameValue
     */
    value: string;
}
/**
 * Total quantity returned in this return line
 * @export
 * @interface Quantity
 */
export interface Quantity {
    /**
     * The unit of measure in the item\'s weight (e.g., \'POUND\' or \'OUNCE\')
     * @type {string}
     * @memberof Quantity
     */
    unitOfMeasure: string;
    /**
     * The quantity of the unit of measure for the item
     * @type {number}
     * @memberof Quantity
     */
    measurementValue: number;
}
/**
 * Array of refund lines.
 * @export
 * @interface RefundLine
 */
export interface RefundLine {
    /**
     * A line number associated with each individual line in the return order. If return order has only one return order line and it is not provided in the request, the only available return order line is auto-selected. If return order has multiple return order lines, the required return order line must be provided in the request. If not provided in the request, it will result in data-error.
     * @type {number}
     * @memberof RefundLine
     */
    returnOrderLineNumber: number;
}
/**
 * 
 * @export
 * @interface RefundRequest
 */
export interface RefundRequest {
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof RefundRequest
     */
    customerOrderId: string;
    /**
     * Array of refund lines.
     * @type {Array<V3ReturnsReturnOrderIdRefundRefundLines>}
     * @memberof RefundRequest
     */
    refundLines: Array<V3ReturnsReturnOrderIdRefundRefundLines>;
}
/**
 * 
 * @export
 * @interface RefundResponse
 */
export interface RefundResponse {
    /**
     * The return order id
     * @type {string}
     * @memberof RefundResponse
     */
    returnOrderId?: string;
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof RefundResponse
     */
    customerOrderId?: string;
    /**
     * Array of refund lines
     * @type {Array<V3ReturnsReturnOrderIdRefundRefundLines>}
     * @memberof RefundResponse
     */
    refundLines?: Array<V3ReturnsReturnOrderIdRefundRefundLines>;
}
/**
 * The channel via order return got initiated
 * @export
 * @interface ReturnChannel
 */
export interface ReturnChannel {
    /**
     * Valid values are: ONLINE, IN_STORE, and CUSTOMER_CARE
     * @type {string}
     * @memberof ReturnChannel
     */
    channelName?: string;
}
/**
 * Array of return lines
 * @export
 * @interface ReturnLine
 */
export interface ReturnLine {
    /**
     * Identifier of the return label
     * @type {number}
     * @memberof ReturnLine
     */
    returnOrderLineNumber?: number;
}
/**
 * These groups are created per label or type of carrier service required. (e.g., If order has some lines that can be clubbed and mailed together as a smart post then they belong to one return group. If a line is bulky and needs a different type of carrier service, then that line will be part of different group. Customer gets multiple labels depending on how many groups are created for the entire order.)
 * @export
 * @interface ReturnLineGroup
 */
export interface ReturnLineGroup {
    /**
     * Sequence of group numbers where each returnLineGroups will represent one or more return lines
     * @type {number}
     * @memberof ReturnLineGroup
     */
    groupNo?: number;
    /**
     * Array of return lines
     * @type {Array<InlineResponse200ReturnLines>}
     * @memberof ReturnLineGroup
     */
    returnLines?: Array<InlineResponse200ReturnLines>;
    /**
     * Array of labels
     * @type {Array<InlineResponse200Labels>}
     * @memberof ReturnLineGroup
     */
    labels?: Array<InlineResponse200Labels>;
    /**
     * Is customer required to send this item back to return center
     * @type {boolean}
     * @memberof ReturnLineGroup
     */
    returnExpectedFlag?: boolean;
}
/**
 * List of returns for the seller.
 * @export
 * @interface ReturnOrder
 */
export interface ReturnOrder {
    /**
     * Return order identifier of the return order. This is the same as RMA number.
     * @type {string}
     * @memberof ReturnOrder
     */
    returnOrderId?: string;
    /**
     * Customer email address
     * @type {string}
     * @memberof ReturnOrder
     */
    customerEmailId?: string;
    /**
     * Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
     * @type {string}
     * @memberof ReturnOrder
     */
    returnType?: string;
    /**
     * customer order ID of the original return order on which the replacement is created.
     * @type {string}
     * @memberof ReturnOrder
     */
    replacementCustomerOrderId?: string;
    /**
     * 
     * @type {InlineResponse200CustomerName}
     * @memberof ReturnOrder
     */
    customerName?: InlineResponse200CustomerName;
    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof ReturnOrder
     */
    customerOrderId?: string;
    /**
     * Date format for return order date
     * @type {string}
     * @memberof ReturnOrder
     */
    returnOrderDate?: string;
    /**
     * Date format for return by order date
     * @type {string}
     * @memberof ReturnOrder
     */
    returnByDate?: string;
    /**
     * Determines when the refund was/will be issued to the customer
     * @type {string}
     * @memberof ReturnOrder
     */
    refundMode?: string;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof ReturnOrder
     */
    totalRefundAmount?: InlineResponse200TotalRefundAmount;
    /**
     * These groups are created per label or type of carrier service required. (e.g., If order has some lines that can be clubbed and mailed together as a smart post then they belong to one return group. If a line is bulky and needs a different type of carrier service, then that line will be part of different group. Customer gets multiple labels depending on how many groups are created for the entire order.)
     * @type {Array<InlineResponse200ReturnLineGroups>}
     * @memberof ReturnOrder
     */
    returnLineGroups?: Array<InlineResponse200ReturnLineGroups>;
    /**
     * A list of order lines in the return order
     * @type {Array<InlineResponse200ReturnOrderLines>}
     * @memberof ReturnOrder
     */
    returnOrderLines?: Array<InlineResponse200ReturnOrderLines>;
    /**
     * 
     * @type {InlineResponse200ReturnChannel}
     * @memberof ReturnOrder
     */
    returnChannel?: InlineResponse200ReturnChannel;
}
/**
 * A list of order lines in the return order
 * @export
 * @interface ReturnOrderLine
 */
export interface ReturnOrderLine {
    /**
     * The returns order line number for that return
     * @type {number}
     * @memberof ReturnOrderLine
     */
    returnOrderLineNumber?: number;
    /**
     * The sales order line number for the return created
     * @type {number}
     * @memberof ReturnOrderLine
     */
    salesOrderLineNumber?: number;
    /**
     * A unique ID associated with the sales order for specified Seller; gives Sellers the ability to print their own custom order ID on the return label; limit of 30 characters
     * @type {string}
     * @memberof ReturnOrderLine
     */
    sellerOrderId?: string;
    /**
     * Gives the reason that was selected during the return creation. Reason codes are: ARRIVED_LATE, AUTO_RETURN, BOUGHT_ANOTHER_SIZE_OR_COLOR, BOUGHT_SOMEWHERE_ELSE, DAMAGED, DEFECTIVE, DUPLICATE_ITEM, INADEQUATE_QUALITY, INCORRECT_ITEM, LOST_AFTER_DELIVERY, LOST_IN_TRANSIT, LOWER_PRICE, MISSING_PARTS, NOT_AS_DESCRIBED, NO_LONGER_WANTED, RETURN_TO_SENDER, SHIPPING_BOX_DAMAGED, TRIED_TO_CANCEL and WRONG_SIZE/POOR_FIT
     * @type {string}
     * @memberof ReturnOrderLine
     */
    returnReason?: string;
    /**
     * The purchase order ID for the return created
     * @type {string}
     * @memberof ReturnOrderLine
     */
    purchaseOrderId?: string;
    /**
     * The purchase order line number for the return created
     * @type {number}
     * @memberof ReturnOrderLine
     */
    purchaseOrderLineNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderLine
     */
    exceptionItemType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    isReturnForException?: boolean;
    /**
     * reason for recharging the customer for replacement
     * @type {string}
     * @memberof ReturnOrderLine
     */
    rechargeReason?: string;
    /**
     * reason for cancelling the return
     * @type {string}
     * @memberof ReturnOrderLine
     */
    returnCancellationReason?: string;
    /**
     * 
     * @type {InlineResponse200Item}
     * @memberof ReturnOrderLine
     */
    item?: InlineResponse200Item;
    /**
     * Information relating to the charge for the orderLine
     * @type {Array<InlineResponse200Charges>}
     * @memberof ReturnOrderLine
     */
    charges?: Array<InlineResponse200Charges>;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof ReturnOrderLine
     */
    unitPrice?: InlineResponse200TotalRefundAmount;
    /**
     * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
     * @type {Array<InlineResponse200References>}
     * @memberof ReturnOrderLine
     */
    itemReturnSettings?: Array<InlineResponse200References>;
    /**
     * Contains name value pairs of calculated charges for the line. Eg: if order line has 3 Qty, this will have a shipping charge = 3 * shipping charge per unit (This is present in the line level charges).
     * @type {Array<InlineResponse200ChargeTotals>}
     * @memberof ReturnOrderLine
     */
    chargeTotals?: Array<InlineResponse200ChargeTotals>;
    /**
     * How much quantity of this order line can be cancelled
     * @type {number}
     * @memberof ReturnOrderLine
     */
    cancellableQty?: number;
    /**
     * 
     * @type {InlineResponse200ItemItemWeight}
     * @memberof ReturnOrderLine
     */
    quantity?: InlineResponse200ItemItemWeight;
    /**
     * Is customer required to send this item back to return center.
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    returnExpectedFlag?: boolean;
    /**
     * Applicable only for 1P.
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    isFastReplacement?: boolean;
    /**
     * Is customer allowed to keep the product and not required to send it back to return center. This flag is determined by making a call to fraud system.
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    isKeepIt?: boolean;
    /**
     * This return is the last item on the sales order line and all other sales order line items are already returned. Helps in last penny calculations.
     * @type {boolean}
     * @memberof ReturnOrderLine
     */
    lastItem?: boolean;
    /**
     * The quantity for which customer was refunded
     * @type {number}
     * @memberof ReturnOrderLine
     */
    refundedQty?: number;
    /**
     * The quantity for which customer can be charged again for
     * @type {number}
     * @memberof ReturnOrderLine
     */
    rechargeableQty?: number;
    /**
     * Determines the mode of refund initiation. Valid values are: WALMART_SETTLED_REFUND, SELLER_AUTO_REFUND, SELLER_MANUAL_REFUND, SELLER_SYSTEM_REFUND, and WALMART_TRIGGERED_REFUND.
     * @type {string}
     * @memberof ReturnOrderLine
     */
    refundChannel?: string;
    /**
     * Informational blocks added as the return order completes its journey from return creation to received and refunded.
     * @type {Array<InlineResponse200ReturnTrackingDetail>}
     * @memberof ReturnOrderLine
     */
    returnTrackingDetail?: Array<InlineResponse200ReturnTrackingDetail>;
    /**
     * Current status of return. (e.g., \'INITIATED\')
     * @type {string}
     * @memberof ReturnOrderLine
     */
    status?: string;
    /**
     * Timestamp of listed status change
     * @type {string}
     * @memberof ReturnOrderLine
     */
    statusTime?: string;
    /**
     * Determines the current carrier tracking status of the return.
     * @type {string}
     * @memberof ReturnOrderLine
     */
    currentDeliveryStatus?: string;
    /**
     * Determines the current refund status of the return.
     * @type {string}
     * @memberof ReturnOrderLine
     */
    currentRefundStatus?: string;
}
/**
 * Informational blocks added as the return order completes its journey from return creation to received and refunded.
 * @export
 * @interface ReturnTrackingDetail
 */
export interface ReturnTrackingDetail {
    /**
     * The stage the return is in. (e.g., \'1\' is an initiated return)
     * @type {number}
     * @memberof ReturnTrackingDetail
     */
    sequenceNo?: number;
    /**
     * The last completed return event. (e.g., \'RETURN_IN_TRANSIT\')
     * @type {string}
     * @memberof ReturnTrackingDetail
     */
    eventTag?: string;
    /**
     * Description of current return status event. (e.g., \'A MARKET_PLACE Return in Transit\')
     * @type {string}
     * @memberof ReturnTrackingDetail
     */
    eventDescription?: string;
    /**
     * Timestamp of listed event
     * @type {string}
     * @memberof ReturnTrackingDetail
     */
    eventTime?: string;
    /**
     * Used only for 1P
     * @type {Array<InlineResponse200References>}
     * @memberof ReturnTrackingDetail
     */
    references?: Array<InlineResponse200References>;
}
/**
 * Taxes for each charge
 * @export
 * @interface Tax
 */
export interface Tax {
    /**
     * Name of the tax
     * @type {string}
     * @memberof Tax
     */
    taxName?: string;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof Tax
     */
    excessTax?: InlineResponse200TotalRefundAmount;
    /**
     * 
     * @type {InlineResponse200TotalRefundAmount}
     * @memberof Tax
     */
    taxPerUnit?: InlineResponse200TotalRefundAmount;
}
/**
 * Array of refund lines.
 * @export
 * @interface V3ReturnsReturnOrderIdRefundRefundLines
 */
export interface V3ReturnsReturnOrderIdRefundRefundLines {
    /**
     * A line number associated with each individual line in the return order. If return order has only one return order line and it is not provided in the request, the only available return order line is auto-selected. If return order has multiple return order lines, the required return order line must be provided in the request. If not provided in the request, it will result in data-error.
     * @type {number}
     * @memberof V3ReturnsReturnOrderIdRefundRefundLines
     */
    returnOrderLineNumber: number;
}

/**
 * ReturnsRefundsApi - axios parameter creator
 * @export
 */
export const ReturnsRefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sellers can specify global settings for returns in Seller Center, and they can override individual item level settings using this API.  Empty values for the settings will remove the existing overriden values and revert them to global settings.  For more details, see the announcement forÂ [Bulk Return Rules](https://sellerhelp.walmart.com/s/guide?article=000008197).
         * @summary Return Item Overrides
         * @param {string} feedType Feed Type
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkItemOverrideFeed: async (feedType: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedType' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'feedType', feedType)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('bulkItemOverrideFeed', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of return orders for the specified filter criteria.
         * @summary Returns
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [returnOrderId] Return order identifier of the return order object as part of array. This is the same as RMA number.
         * @param {string} [customerOrderId] A unique ID associated with the sales order for specified customer
         * @param {string} [status] Status may be specified to query the returns with specific status.Valid statuses are: INITIATED, DELIVERED, COMPLETED
         * @param {string} [replacementInfo] Provides additional attributes - replacementCustomerOrderID, returnType, rechargeReason, returnCancellationReason - related to Replacement return order, in response, if available. Allowed values are true or false.
         * @param {string} [returnType] Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
         * @param {string} [returnCreationStartDate] Start Date for querying all return orders that were created after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;
         * @param {string} [returnCreationEndDate] Limits the query to the return orders that were created before this returnCreationEndDate. Use one of the following formats, based on ISO 8601, are allowed: UTC date or timestamp. Examples: \&#39;2016-08-16T10:30:30.155Z\&#39; or \&#39;2016-08-16\&#39;
         * @param {string} [returnLastModifiedStartDate] Start Date for querying all return orders that were modified after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-17T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [returnLastModifiedEndDate] Limits the query to the return orders that were modified before this date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-18T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-18T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [limit] The number of orders to be returned. Cannot be larger than 200
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturns: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, returnOrderId?: string, customerOrderId?: string, status?: string, replacementInfo?: string, returnType?: string, returnCreationStartDate?: string, returnCreationEndDate?: string, returnLastModifiedStartDate?: string, returnLastModifiedEndDate?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getReturns', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getReturns', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getReturns', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getReturns', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/returns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (returnOrderId !== undefined) {
                localVarQueryParameter['returnOrderId'] = returnOrderId;
            }

            if (customerOrderId !== undefined) {
                localVarQueryParameter['customerOrderId'] = customerOrderId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (replacementInfo !== undefined) {
                localVarQueryParameter['replacementInfo'] = replacementInfo;
            }

            if (returnType !== undefined) {
                localVarQueryParameter['returnType'] = returnType;
            }

            if (returnCreationStartDate !== undefined) {
                localVarQueryParameter['returnCreationStartDate'] = (returnCreationStartDate as any instanceof Date) ?
                    (returnCreationStartDate as any).toISOString() :
                    returnCreationStartDate;
            }

            if (returnCreationEndDate !== undefined) {
                localVarQueryParameter['returnCreationEndDate'] = (returnCreationEndDate as any instanceof Date) ?
                    (returnCreationEndDate as any).toISOString() :
                    returnCreationEndDate;
            }

            if (returnLastModifiedStartDate !== undefined) {
                localVarQueryParameter['returnLastModifiedStartDate'] = (returnLastModifiedStartDate as any instanceof Date) ?
                    (returnLastModifiedStartDate as any).toISOString() :
                    returnLastModifiedStartDate;
            }

            if (returnLastModifiedEndDate !== undefined) {
                localVarQueryParameter['returnLastModifiedEndDate'] = (returnLastModifiedEndDate as any instanceof Date) ?
                    (returnLastModifiedEndDate as any).toISOString() :
                    returnLastModifiedEndDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API allows sellers to issue refund against a return order. Multiple return order lines can be refunded in one request.  Note: Sellers can use the Refund Order Lines API for all non-exception category items, including adjustments that seller needs to determine a partial refund amount. Especially for exception category items: HAZMAT, OTHER and FREIGHT that are not eligible for the Marketplace Returns Program. 
         * @summary Issue refund
         * @param {string} returnOrderId The return order ID
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRefund: async (returnOrderId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'returnOrderId' is not null or undefined
            assertParamExists('issueRefund', 'returnOrderId', returnOrderId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('issueRefund', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('issueRefund', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('issueRefund', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('issueRefund', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('issueRefund', 'inlineObject', inlineObject)
            const localVarPath = `/v3/returns/{returnOrderId}/refund`
                .replace(`{${"returnOrderId"}}`, encodeURIComponent(String(returnOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReturnsRefundsApi - functional programming interface
 * @export
 */
export const ReturnsRefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReturnsRefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * Sellers can specify global settings for returns in Seller Center, and they can override individual item level settings using this API.  Empty values for the settings will remove the existing overriden values and revert them to global settings.  For more details, see the announcement forÂ [Bulk Return Rules](https://sellerhelp.walmart.com/s/guide?article=000008197).
         * @summary Return Item Overrides
         * @param {string} feedType Feed Type
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkItemOverrideFeed(feedType: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkItemOverrideFeed(feedType, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of return orders for the specified filter criteria.
         * @summary Returns
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [returnOrderId] Return order identifier of the return order object as part of array. This is the same as RMA number.
         * @param {string} [customerOrderId] A unique ID associated with the sales order for specified customer
         * @param {string} [status] Status may be specified to query the returns with specific status.Valid statuses are: INITIATED, DELIVERED, COMPLETED
         * @param {string} [replacementInfo] Provides additional attributes - replacementCustomerOrderID, returnType, rechargeReason, returnCancellationReason - related to Replacement return order, in response, if available. Allowed values are true or false.
         * @param {string} [returnType] Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
         * @param {string} [returnCreationStartDate] Start Date for querying all return orders that were created after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;
         * @param {string} [returnCreationEndDate] Limits the query to the return orders that were created before this returnCreationEndDate. Use one of the following formats, based on ISO 8601, are allowed: UTC date or timestamp. Examples: \&#39;2016-08-16T10:30:30.155Z\&#39; or \&#39;2016-08-16\&#39;
         * @param {string} [returnLastModifiedStartDate] Start Date for querying all return orders that were modified after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-17T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [returnLastModifiedEndDate] Limits the query to the return orders that were modified before this date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-18T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-18T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [limit] The number of orders to be returned. Cannot be larger than 200
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturns(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, returnOrderId?: string, customerOrderId?: string, status?: string, replacementInfo?: string, returnType?: string, returnCreationStartDate?: string, returnCreationEndDate?: string, returnLastModifiedStartDate?: string, returnLastModifiedEndDate?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturns(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, returnOrderId, customerOrderId, status, replacementInfo, returnType, returnCreationStartDate, returnCreationEndDate, returnLastModifiedStartDate, returnLastModifiedEndDate, limit, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API allows sellers to issue refund against a return order. Multiple return order lines can be refunded in one request.  Note: Sellers can use the Refund Order Lines API for all non-exception category items, including adjustments that seller needs to determine a partial refund amount. Especially for exception category items: HAZMAT, OTHER and FREIGHT that are not eligible for the Marketplace Returns Program. 
         * @summary Issue refund
         * @param {string} returnOrderId The return order ID
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRefund(returnOrderId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRefund(returnOrderId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReturnsRefundsApi - factory interface
 * @export
 */
export const ReturnsRefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReturnsRefundsApiFp(configuration)
    return {
        /**
         * Sellers can specify global settings for returns in Seller Center, and they can override individual item level settings using this API.  Empty values for the settings will remove the existing overriden values and revert them to global settings.  For more details, see the announcement forÂ [Bulk Return Rules](https://sellerhelp.walmart.com/s/guide?article=000008197).
         * @summary Return Item Overrides
         * @param {string} feedType Feed Type
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkItemOverrideFeed(feedType: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, file?: any, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.bulkItemOverrideFeed(feedType, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of return orders for the specified filter criteria.
         * @summary Returns
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [returnOrderId] Return order identifier of the return order object as part of array. This is the same as RMA number.
         * @param {string} [customerOrderId] A unique ID associated with the sales order for specified customer
         * @param {string} [status] Status may be specified to query the returns with specific status.Valid statuses are: INITIATED, DELIVERED, COMPLETED
         * @param {string} [replacementInfo] Provides additional attributes - replacementCustomerOrderID, returnType, rechargeReason, returnCancellationReason - related to Replacement return order, in response, if available. Allowed values are true or false.
         * @param {string} [returnType] Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
         * @param {string} [returnCreationStartDate] Start Date for querying all return orders that were created after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;
         * @param {string} [returnCreationEndDate] Limits the query to the return orders that were created before this returnCreationEndDate. Use one of the following formats, based on ISO 8601, are allowed: UTC date or timestamp. Examples: \&#39;2016-08-16T10:30:30.155Z\&#39; or \&#39;2016-08-16\&#39;
         * @param {string} [returnLastModifiedStartDate] Start Date for querying all return orders that were modified after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-17T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [returnLastModifiedEndDate] Limits the query to the return orders that were modified before this date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-18T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-18T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
         * @param {string} [limit] The number of orders to be returned. Cannot be larger than 200
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturns(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, returnOrderId?: string, customerOrderId?: string, status?: string, replacementInfo?: string, returnType?: string, returnCreationStartDate?: string, returnCreationEndDate?: string, returnLastModifiedStartDate?: string, returnLastModifiedEndDate?: string, limit?: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getReturns(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, returnOrderId, customerOrderId, status, replacementInfo, returnType, returnCreationStartDate, returnCreationEndDate, returnLastModifiedStartDate, returnLastModifiedEndDate, limit, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API allows sellers to issue refund against a return order. Multiple return order lines can be refunded in one request.  Note: Sellers can use the Refund Order Lines API for all non-exception category items, including adjustments that seller needs to determine a partial refund amount. Especially for exception category items: HAZMAT, OTHER and FREIGHT that are not eligible for the Marketplace Returns Program. 
         * @summary Issue refund
         * @param {string} returnOrderId The return order ID
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRefund(returnOrderId: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.issueRefund(returnOrderId, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkItemOverrideFeed operation in ReturnsRefundsApi.
 * @export
 * @interface ReturnsRefundsApiBulkItemOverrideFeedRequest
 */
export interface ReturnsRefundsApiBulkItemOverrideFeedRequest {
    /**
     * Feed Type
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly feedType: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly wMCONSUMERCHANNELTYPE?: string

    /**
     * 
     * @type {any}
     * @memberof ReturnsRefundsApiBulkItemOverrideFeed
     */
    readonly file?: any
}

/**
 * Request parameters for getReturns operation in ReturnsRefundsApi.
 * @export
 * @interface ReturnsRefundsApiGetReturnsRequest
 */
export interface ReturnsRefundsApiGetReturnsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly wMSVCNAME: string

    /**
     * Return order identifier of the return order object as part of array. This is the same as RMA number.
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnOrderId?: string

    /**
     * A unique ID associated with the sales order for specified customer
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly customerOrderId?: string

    /**
     * Status may be specified to query the returns with specific status.Valid statuses are: INITIATED, DELIVERED, COMPLETED
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly status?: string

    /**
     * Provides additional attributes - replacementCustomerOrderID, returnType, rechargeReason, returnCancellationReason - related to Replacement return order, in response, if available. Allowed values are true or false.
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly replacementInfo?: string

    /**
     * Specifies if the return order is a replacement return or a regular (refund) return. Possible values are REPLACEMENT or REFUND.
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnType?: string

    /**
     * Start Date for querying all return orders that were created after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnCreationStartDate?: string

    /**
     * Limits the query to the return orders that were created before this returnCreationEndDate. Use one of the following formats, based on ISO 8601, are allowed: UTC date or timestamp. Examples: \&#39;2016-08-16T10:30:30.155Z\&#39; or \&#39;2016-08-16\&#39;
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnCreationEndDate?: string

    /**
     * Start Date for querying all return orders that were modified after that date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-16T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-17T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnLastModifiedStartDate?: string

    /**
     * Limits the query to the return orders that were modified before this date. Use one of the following formats, based on UTC, ISO 8601. Date example: \&#39;2013-08-16\&#39; Timestamp example: \&#39;2013-08-18T10:30:15Z\&#39;.In case of dates with timezone, use format \&#39;2020-04-18T10:42:41.000+0000\&#39; and follow encode \&#39;+\&#39; with %20
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly returnLastModifiedEndDate?: string

    /**
     * The number of orders to be returned. Cannot be larger than 200
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly limit?: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof ReturnsRefundsApiGetReturns
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for issueRefund operation in ReturnsRefundsApi.
 * @export
 * @interface ReturnsRefundsApiIssueRefundRequest
 */
export interface ReturnsRefundsApiIssueRefundRequest {
    /**
     * The return order ID
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly returnOrderId: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly inlineObject: InlineObject

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof ReturnsRefundsApiIssueRefund
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * ReturnsRefundsApi - object-oriented interface
 * @export
 * @class ReturnsRefundsApi
 * @extends {BaseAPI}
 */
export class ReturnsRefundsApi extends BaseAPI {
    /**
     * Sellers can specify global settings for returns in Seller Center, and they can override individual item level settings using this API.  Empty values for the settings will remove the existing overriden values and revert them to global settings.  For more details, see the announcement forÂ [Bulk Return Rules](https://sellerhelp.walmart.com/s/guide?article=000008197).
     * @summary Return Item Overrides
     * @param {ReturnsRefundsApiBulkItemOverrideFeedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnsRefundsApi
     */
    public bulkItemOverrideFeed(requestParameters: ReturnsRefundsApiBulkItemOverrideFeedRequest, options?: any) {
        return ReturnsRefundsApiFp(this.configuration).bulkItemOverrideFeed(requestParameters.feedType, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of return orders for the specified filter criteria.
     * @summary Returns
     * @param {ReturnsRefundsApiGetReturnsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnsRefundsApi
     */
    public getReturns(requestParameters: ReturnsRefundsApiGetReturnsRequest, options?: any) {
        return ReturnsRefundsApiFp(this.configuration).getReturns(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.returnOrderId, requestParameters.customerOrderId, requestParameters.status, requestParameters.replacementInfo, requestParameters.returnType, requestParameters.returnCreationStartDate, requestParameters.returnCreationEndDate, requestParameters.returnLastModifiedStartDate, requestParameters.returnLastModifiedEndDate, requestParameters.limit, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API allows sellers to issue refund against a return order. Multiple return order lines can be refunded in one request.  Note: Sellers can use the Refund Order Lines API for all non-exception category items, including adjustments that seller needs to determine a partial refund amount. Especially for exception category items: HAZMAT, OTHER and FREIGHT that are not eligible for the Marketplace Returns Program. 
     * @summary Issue refund
     * @param {ReturnsRefundsApiIssueRefundRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnsRefundsApi
     */
    public issueRefund(requestParameters: ReturnsRefundsApiIssueRefundRequest, options?: any) {
        return ReturnsRefundsApiFp(this.configuration).issueRefund(requestParameters.returnOrderId, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


