/* tslint:disable */
/* eslint-disable */
/**
 * Rules Management
 * Rules Management
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivateDeactivateRuleInfo
 */
export interface ActivateDeactivateRuleInfo {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof ActivateDeactivateRuleInfo
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof ActivateDeactivateRuleInfo
     */
    ruleStatus?: string;
}
/**
 * 
 * @export
 * @interface ActivateRuleRequest
 */
export interface ActivateRuleRequest {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof ActivateRuleRequest
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {Array<V3RulesActivateRules>}
     * @memberof ActivateRuleRequest
     */
    rules?: Array<V3RulesActivateRules>;
}
/**
 * 
 * @export
 * @interface ActivateRuleResponse
 */
export interface ActivateRuleResponse {
    /**
     * Message and ruleId
     * @type {string}
     * @memberof ActivateRuleResponse
     */
    message?: string;
    /**
     * status
     * @type {string}
     * @memberof ActivateRuleResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface AreaEntity
 */
export interface AreaEntity {
    /**
     * states.
     * @type {Array<InlineResponse20010PayloadStates>}
     * @memberof AreaEntity
     */
    states?: Array<InlineResponse20010PayloadStates>;
    /**
     * regionCode
     * @type {string}
     * @memberof AreaEntity
     */
    regionCode?: string;
    /**
     * regionName
     * @type {string}
     * @memberof AreaEntity
     */
    regionName?: string;
}
/**
 * 
 * @export
 * @interface CategoryInfo
 */
export interface CategoryInfo {
    /**
     * category
     * @type {string}
     * @memberof CategoryInfo
     */
    category?: string;
    /**
     * subCategory
     * @type {Array<InlineResponse2008Subcategory>}
     * @memberof CategoryInfo
     */
    subcategory?: Array<InlineResponse2008Subcategory>;
}
/**
 * 
 * @export
 * @interface ChangeAssortmentPayload
 */
export interface ChangeAssortmentPayload {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof ChangeAssortmentPayload
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface ChangeAssortmentResponse
 */
export interface ChangeAssortmentResponse {
    /**
     * 
     * @type {string}
     * @memberof ChangeAssortmentResponse
     */
    status?: string;
    /**
     * 
     * @type {InlineResponse2009Payload}
     * @memberof ChangeAssortmentResponse
     */
    payload?: InlineResponse2009Payload;
}
/**
 * Seller creates conditions while defining the custom rule assortment.There are three condition which a seller can use : subCategories, price, weight.
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof Condition
     */
    name?: string;
    /**
     * Seller uses operator while defining conditions in the rule. Operators allowed for condition price and weight: EQUALS, GREATER_THAN, LESS_THAN,GREATER_THAN_OR_EQUALS,LESS_THAN_OR_EQUALS. and for condition subcategories : IN .
     * @type {string}
     * @memberof Condition
     */
    operator?: string;
    /**
     * Values for each condition. Value can be a comma separated strings for subcategories and numerical value for price and weight.
     * @type {string}
     * @memberof Condition
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface CreateOverrideExceptionRequest
 */
export interface CreateOverrideExceptionRequest {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof CreateOverrideExceptionRequest
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {V3RulesExceptionsRules}
     * @memberof CreateOverrideExceptionRequest
     */
    rules?: V3RulesExceptionsRules;
}
/**
 * 
 * @export
 * @interface CreateOverrideExceptionResponse
 */
export interface CreateOverrideExceptionResponse {
    /**
     * A unique ID, returned from the Create Override Exception API, used for tracking a feed file
     * @type {string}
     * @memberof CreateOverrideExceptionResponse
     */
    feedId?: string;
    /**
     * status
     * @type {string}
     * @memberof CreateOverrideExceptionResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface CreateRuleRequest
 */
export interface CreateRuleRequest {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof CreateRuleRequest
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {V3RulesCreateRules}
     * @memberof CreateRuleRequest
     */
    rules?: V3RulesCreateRules;
}
/**
 * 
 * @export
 * @interface CreateRuleResponse
 */
export interface CreateRuleResponse {
    /**
     * 
     * @type {Array<InlineResponse2002Rules>}
     * @memberof CreateRuleResponse
     */
    rules?: Array<InlineResponse2002Rules>;
    /**
     * 
     * @type {string}
     * @memberof CreateRuleResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface DeleteExceptionRequest
 */
export interface DeleteExceptionRequest {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof DeleteExceptionRequest
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {V3RulesExceptionsRules}
     * @memberof DeleteExceptionRequest
     */
    rules?: V3RulesExceptionsRules;
}
/**
 * 
 * @export
 * @interface DeleteExceptionResponse
 */
export interface DeleteExceptionResponse {
    /**
     * A unique ID, returned from the Create Override Exception API, used for tracking a feed file
     * @type {string}
     * @memberof DeleteExceptionResponse
     */
    feedId?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteExceptionResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface DeleteRuleResponse
 */
export interface DeleteRuleResponse {
    /**
     * Message and status of deletion
     * @type {string}
     * @memberof DeleteRuleResponse
     */
    message?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteRuleResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ExceptionInfo
 */
export interface ExceptionInfo {
    /**
     * 
     * @type {Array<V3RulesExceptionsRulesSkus>}
     * @memberof ExceptionInfo
     */
    skus?: Array<V3RulesExceptionsRulesSkus>;
}
/**
 * 
 * @export
 * @interface GetAllAreasPayload
 */
export interface GetAllAreasPayload {
    /**
     * 
     * @type {Array<InlineResponse20010PayloadEntities>}
     * @memberof GetAllAreasPayload
     */
    entities?: Array<InlineResponse20010PayloadEntities>;
}
/**
 * 
 * @export
 * @interface GetAllAreasResponse
 */
export interface GetAllAreasResponse {
    /**
     * Status of the rule post the rule creation.
     * @type {string}
     * @memberof GetAllAreasResponse
     */
    status?: string;
    /**
     * 
     * @type {InlineResponse20010Payload}
     * @memberof GetAllAreasResponse
     */
    payload?: InlineResponse20010Payload;
}
/**
 * 
 * @export
 * @interface GetAllExceptionsResponse
 */
export interface GetAllExceptionsResponse {
    /**
     * A seller-provided Product ID.
     * @type {Array<string>}
     * @memberof GetAllExceptionsResponse
     */
    skuIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetAllExceptionsResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface GetAllRulesResponse
 */
export interface GetAllRulesResponse {
    /**
     * 
     * @type {Array<InlineResponse2001Rules>}
     * @memberof GetAllRulesResponse
     */
    rules?: Array<InlineResponse2001Rules>;
    /**
     * status
     * @type {string}
     * @memberof GetAllRulesResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface GetAllSubCategoriesResponse
 */
export interface GetAllSubCategoriesResponse {
    /**
     * 
     * @type {string}
     * @memberof GetAllSubCategoriesResponse
     */
    status?: string;
    /**
     * 
     * @type {Array<InlineResponse2008Payload>}
     * @memberof GetAllSubCategoriesResponse
     */
    payload?: Array<InlineResponse2008Payload>;
}
/**
 * 
 * @export
 * @interface GetSimulationCountResponse
 */
export interface GetSimulationCountResponse {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof GetSimulationCountResponse
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof GetSimulationCountResponse
     */
    ruleStatus?: string;
    /**
     * Number of items that would be set for two-day if the rule gets activated.
     * @type {string}
     * @memberof GetSimulationCountResponse
     */
    simulationCount?: string;
}
/**
 * 
 * @export
 * @interface InactivateRuleRequest
 */
export interface InactivateRuleRequest {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof InactivateRuleRequest
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {Array<V3RulesActivateRules>}
     * @memberof InactivateRuleRequest
     */
    rules?: Array<V3RulesActivateRules>;
}
/**
 * 
 * @export
 * @interface InactivateRuleResponse
 */
export interface InactivateRuleResponse {
    /**
     * Message and status of inactivation of rule
     * @type {string}
     * @memberof InactivateRuleResponse
     */
    message?: string;
    /**
     * status
     * @type {string}
     * @memberof InactivateRuleResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof InlineObject
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {V3RulesActionsRules}
     * @memberof InlineObject
     */
    rules?: V3RulesActionsRules;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof InlineObject1
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {V3RulesCreateRules}
     * @memberof InlineObject1
     */
    rules?: V3RulesCreateRules;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof InlineObject2
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {Array<V3RulesRules>}
     * @memberof InlineObject2
     */
    rules?: Array<V3RulesRules>;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof InlineObject3
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {Array<V3RulesActivateRules>}
     * @memberof InlineObject3
     */
    rules?: Array<V3RulesActivateRules>;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof InlineObject4
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {Array<V3RulesActivateRules>}
     * @memberof InlineObject4
     */
    rules?: Array<V3RulesActivateRules>;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof InlineObject5
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {V3RulesExceptionsRules}
     * @memberof InlineObject5
     */
    rules?: V3RulesExceptionsRules;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof InlineObject6
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {V3RulesExceptionsRules}
     * @memberof InlineObject6
     */
    rules?: V3RulesExceptionsRules;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse200
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof InlineResponse200
     */
    ruleStatus?: string;
    /**
     * Number of items that would be set for two-day if the rule gets activated.
     * @type {string}
     * @memberof InlineResponse200
     */
    simulationCount?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<InlineResponse2001Rules>}
     * @memberof InlineResponse2001
     */
    rules?: Array<InlineResponse2001Rules>;
    /**
     * status
     * @type {string}
     * @memberof InlineResponse2001
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * Status of the rule post the rule creation.
     * @type {string}
     * @memberof InlineResponse20010
     */
    status?: string;
    /**
     * 
     * @type {InlineResponse20010Payload}
     * @memberof InlineResponse20010
     */
    payload?: InlineResponse20010Payload;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Payload
 */
export interface InlineResponse20010Payload {
    /**
     * 
     * @type {Array<InlineResponse20010PayloadEntities>}
     * @memberof InlineResponse20010Payload
     */
    entities?: Array<InlineResponse20010PayloadEntities>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010PayloadEntities
 */
export interface InlineResponse20010PayloadEntities {
    /**
     * states.
     * @type {Array<InlineResponse20010PayloadStates>}
     * @memberof InlineResponse20010PayloadEntities
     */
    states?: Array<InlineResponse20010PayloadStates>;
    /**
     * regionCode
     * @type {string}
     * @memberof InlineResponse20010PayloadEntities
     */
    regionCode?: string;
    /**
     * regionName
     * @type {string}
     * @memberof InlineResponse20010PayloadEntities
     */
    regionName?: string;
}
/**
 * statesubregions
 * @export
 * @interface InlineResponse20010PayloadStateSubregions
 */
export interface InlineResponse20010PayloadStateSubregions {
    /**
     * stateSubregionCode
     * @type {string}
     * @memberof InlineResponse20010PayloadStateSubregions
     */
    stateSubregionCode?: string;
    /**
     * stateSubregionName
     * @type {string}
     * @memberof InlineResponse20010PayloadStateSubregions
     */
    stateSubregionName?: string;
}
/**
 * states.
 * @export
 * @interface InlineResponse20010PayloadStates
 */
export interface InlineResponse20010PayloadStates {
    /**
     * statesubregions
     * @type {Array<InlineResponse20010PayloadStateSubregions>}
     * @memberof InlineResponse20010PayloadStates
     */
    stateSubregions?: Array<InlineResponse20010PayloadStateSubregions>;
}
/**
 * Seller creates conditions while defining the custom rule assortment.There are three condition which a seller can use : subCategories, price, weight.
 * @export
 * @interface InlineResponse2001Conditions
 */
export interface InlineResponse2001Conditions {
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2001Conditions
     */
    name?: string;
    /**
     * Seller uses operator while defining conditions in the rule. Operators allowed for condition price and weight: EQUALS, GREATER_THAN, LESS_THAN,GREATER_THAN_OR_EQUALS,LESS_THAN_OR_EQUALS. and for condition subcategories : IN .
     * @type {string}
     * @memberof InlineResponse2001Conditions
     */
    operator?: string;
    /**
     * Values for each condition. Value can be a comma separated strings for subcategories and numerical value for price and weight.
     * @type {string}
     * @memberof InlineResponse2001Conditions
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001Rules
 */
export interface InlineResponse2001Rules {
    /**
     * Seller creates conditions while defining the custom rule assortment.There are three condition which a seller can use : subCategories, price, weight.
     * @type {Array<InlineResponse2001Conditions>}
     * @memberof InlineResponse2001Rules
     */
    conditions?: Array<InlineResponse2001Conditions>;
    /**
     * Description of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2001Rules
     */
    description?: string;
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2001Rules
     */
    name?: string;
    /**
     * Priority of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2001Rules
     */
    priority?: string;
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2001Rules
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof InlineResponse2001Rules
     */
    ruleStatus?: string;
    /**
     * When the rule gets activated, skuProcessingStatus represents the state of all items being processed for two-day. The two values for skuProcessingStatus are Processing and Completed.
     * @type {string}
     * @memberof InlineResponse2001Rules
     */
    skuProcessingStatus?: string;
    /**
     * 
     * @type {V3RulesActionsRulesActions}
     * @memberof InlineResponse2001Rules
     */
    ruleAction?: V3RulesActionsRulesActions;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<InlineResponse2002Rules>}
     * @memberof InlineResponse2002
     */
    rules?: Array<InlineResponse2002Rules>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Rules
 */
export interface InlineResponse2002Rules {
    /**
     * Seller creates conditions while defining the custom rule assortment.There are three condition which a seller can use : subCategories, price, weight.
     * @type {Array<InlineResponse2001Conditions>}
     * @memberof InlineResponse2002Rules
     */
    conditions?: Array<InlineResponse2001Conditions>;
    /**
     * Description of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2002Rules
     */
    description?: string;
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2002Rules
     */
    name?: string;
    /**
     * Priority of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2002Rules
     */
    priority?: string;
    /**
     * Defines the two day state coverage areas.
     * @type {string}
     * @memberof InlineResponse2002Rules
     */
    ruleAction?: string;
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2002Rules
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof InlineResponse2002Rules
     */
    ruleStatus?: string;
    /**
     * When the rule gets activated, skuProcessingStatus represents the state of all items being processed for two-day. The two values for skuProcessingStatus are Processing and Completed.
     * @type {string}
     * @memberof InlineResponse2002Rules
     */
    skuProcessingStatus?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * Message and ruleId
     * @type {string}
     * @memberof InlineResponse2003
     */
    message?: string;
    /**
     * status
     * @type {string}
     * @memberof InlineResponse2003
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * Message and status of deletion
     * @type {string}
     * @memberof InlineResponse2004
     */
    message?: string;
    /**
     * status
     * @type {string}
     * @memberof InlineResponse2004
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * Message and status of inactivation of rule
     * @type {string}
     * @memberof InlineResponse2005
     */
    message?: string;
    /**
     * status
     * @type {string}
     * @memberof InlineResponse2005
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * A seller-provided Product ID.
     * @type {Array<string>}
     * @memberof InlineResponse2006
     */
    skuIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * A unique ID, returned from the Create Override Exception API, used for tracking a feed file
     * @type {string}
     * @memberof InlineResponse2007
     */
    feedId?: string;
    /**
     * status
     * @type {string}
     * @memberof InlineResponse2007
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    status?: string;
    /**
     * 
     * @type {Array<InlineResponse2008Payload>}
     * @memberof InlineResponse2008
     */
    payload?: Array<InlineResponse2008Payload>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008Payload
 */
export interface InlineResponse2008Payload {
    /**
     * category
     * @type {string}
     * @memberof InlineResponse2008Payload
     */
    category?: string;
    /**
     * subCategory
     * @type {Array<InlineResponse2008Subcategory>}
     * @memberof InlineResponse2008Payload
     */
    subcategory?: Array<InlineResponse2008Subcategory>;
}
/**
 * subCategory
 * @export
 * @interface InlineResponse2008Subcategory
 */
export interface InlineResponse2008Subcategory {
    /**
     * Name of specific kind of category
     * @type {string}
     * @memberof InlineResponse2008Subcategory
     */
    subCategoryName?: string;
    /**
     * ID of specific kind of category
     * @type {string}
     * @memberof InlineResponse2008Subcategory
     */
    subCategoryId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    status?: string;
    /**
     * 
     * @type {InlineResponse2009Payload}
     * @memberof InlineResponse2009
     */
    payload?: InlineResponse2009Payload;
}
/**
 * 
 * @export
 * @interface InlineResponse2009Payload
 */
export interface InlineResponse2009Payload {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof InlineResponse2009Payload
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface OverrideItem
 */
export interface OverrideItem {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \':\', \'/\', \'?\', \'#\', \'[\', \']\', \'@\', \'!\', \'$\', \'&\', \"\'\", \'(\', \')\', \'*\', \'+\', \',\', \';\', \'=\', as well as \'%\' itself. Other characters don\'t need to be encoded.
     * @type {string}
     * @memberof OverrideItem
     */
    sku?: string;
}
/**
 * Defines the two day state coverage areas.
 * @export
 * @interface RuleAction
 */
export interface RuleAction {
    /**
     * List of two-day regions.
     * @type {Array<V3RulesActionsRulesTwoDayShippingRegions>}
     * @memberof RuleAction
     */
    twoDayShippingRegions?: Array<V3RulesActionsRulesTwoDayShippingRegions>;
}
/**
 * 
 * @export
 * @interface RuleHeader
 */
export interface RuleHeader {
    /**
     * 
     * @type {string}
     * @memberof RuleHeader
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface RuleInfo
 */
export interface RuleInfo {
    /**
     * Seller creates conditions while defining the custom rule assortment.There are three condition which a seller can use : subCategories, price, weight.
     * @type {Array<InlineResponse2001Conditions>}
     * @memberof RuleInfo
     */
    conditions?: Array<InlineResponse2001Conditions>;
    /**
     * Description of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleInfo
     */
    description?: string;
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleInfo
     */
    name?: string;
    /**
     * Priority of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleInfo
     */
    priority?: string;
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleInfo
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof RuleInfo
     */
    ruleStatus?: string;
    /**
     * When the rule gets activated, skuProcessingStatus represents the state of all items being processed for two-day. The two values for skuProcessingStatus are Processing and Completed.
     * @type {string}
     * @memberof RuleInfo
     */
    skuProcessingStatus?: string;
    /**
     * 
     * @type {V3RulesActionsRulesActions}
     * @memberof RuleInfo
     */
    ruleAction?: V3RulesActionsRulesActions;
}
/**
 * 
 * @export
 * @interface RuleRequest
 */
export interface RuleRequest {
    /**
     * 
     * @type {Array<InlineResponse2001Conditions>}
     * @memberof RuleRequest
     */
    conditions?: Array<InlineResponse2001Conditions>;
    /**
     * Description of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleRequest
     */
    description?: string;
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleRequest
     */
    name?: string;
    /**
     * Priority of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleRequest
     */
    priority?: string;
}
/**
 * 
 * @export
 * @interface RuleResponse
 */
export interface RuleResponse {
    /**
     * Seller creates conditions while defining the custom rule assortment.There are three condition which a seller can use : subCategories, price, weight.
     * @type {Array<InlineResponse2001Conditions>}
     * @memberof RuleResponse
     */
    conditions?: Array<InlineResponse2001Conditions>;
    /**
     * Description of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleResponse
     */
    description?: string;
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleResponse
     */
    name?: string;
    /**
     * Priority of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleResponse
     */
    priority?: string;
    /**
     * Defines the two day state coverage areas.
     * @type {string}
     * @memberof RuleResponse
     */
    ruleAction?: string;
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleResponse
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof RuleResponse
     */
    ruleStatus?: string;
    /**
     * When the rule gets activated, skuProcessingStatus represents the state of all items being processed for two-day. The two values for skuProcessingStatus are Processing and Completed.
     * @type {string}
     * @memberof RuleResponse
     */
    skuProcessingStatus?: string;
}
/**
 * 
 * @export
 * @interface RuleToUpdate
 */
export interface RuleToUpdate {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RuleToUpdate
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof RuleToUpdate
     */
    ruleStatus?: string;
    /**
     * Defines the two day state coverage areas.
     * @type {Array<V3RulesActionsRulesActions>}
     * @memberof RuleToUpdate
     */
    actions?: Array<V3RulesActionsRulesActions>;
}
/**
 * states.
 * @export
 * @interface State
 */
export interface State {
    /**
     * statesubregions
     * @type {Array<InlineResponse20010PayloadStateSubregions>}
     * @memberof State
     */
    stateSubregions?: Array<InlineResponse20010PayloadStateSubregions>;
}
/**
 * statesubregions
 * @export
 * @interface StateSubRegion
 */
export interface StateSubRegion {
    /**
     * stateSubregionCode
     * @type {string}
     * @memberof StateSubRegion
     */
    stateSubregionCode?: string;
    /**
     * stateSubregionName
     * @type {string}
     * @memberof StateSubRegion
     */
    stateSubregionName?: string;
}
/**
 * subCategory
 * @export
 * @interface SubCategory
 */
export interface SubCategory {
    /**
     * Name of specific kind of category
     * @type {string}
     * @memberof SubCategory
     */
    subCategoryName?: string;
    /**
     * ID of specific kind of category
     * @type {string}
     * @memberof SubCategory
     */
    subCategoryId?: string;
}
/**
 * 
 * @export
 * @interface SubRegionCode
 */
export interface SubRegionCode {
    /**
     * subRegionCode
     * @type {string}
     * @memberof SubRegionCode
     */
    subRegionCode?: string;
}
/**
 * List of two-day regions.
 * @export
 * @interface SubRegions
 */
export interface SubRegions {
    /**
     * regionCode
     * @type {string}
     * @memberof SubRegions
     */
    regionCode?: string;
    /**
     * 
     * @type {Array<V3RulesActionsRulesSubRegions>}
     * @memberof SubRegions
     */
    subRegions?: Array<V3RulesActionsRulesSubRegions>;
}
/**
 * 
 * @export
 * @interface UpdateRuleInfo
 */
export interface UpdateRuleInfo {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof UpdateRuleInfo
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof UpdateRuleInfo
     */
    ruleStatus?: string;
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof UpdateRuleInfo
     */
    name?: string;
    /**
     * Description of the rule created for custom rule assortment.
     * @type {string}
     * @memberof UpdateRuleInfo
     */
    description?: string;
    /**
     * Priority of the rule created for custom rule assortment.
     * @type {string}
     * @memberof UpdateRuleInfo
     */
    priority?: string;
    /**
     * Seller creates conditions while defining the custom rule assortment.There are three condition which a seller can use : subCategories, price, weight.
     * @type {Array<InlineResponse2001Conditions>}
     * @memberof UpdateRuleInfo
     */
    conditions?: Array<InlineResponse2001Conditions>;
}
/**
 * 
 * @export
 * @interface UpdateRuleRequest
 */
export interface UpdateRuleRequest {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof UpdateRuleRequest
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {Array<V3RulesRules>}
     * @memberof UpdateRuleRequest
     */
    rules?: Array<V3RulesRules>;
}
/**
 * 
 * @export
 * @interface UpdateShippingAreaToRulesRequest
 */
export interface UpdateShippingAreaToRulesRequest {
    /**
     * 
     * @type {V3RulesActionsRuleHeader}
     * @memberof UpdateShippingAreaToRulesRequest
     */
    ruleHeader?: V3RulesActionsRuleHeader;
    /**
     * 
     * @type {V3RulesActionsRules}
     * @memberof UpdateShippingAreaToRulesRequest
     */
    rules?: V3RulesActionsRules;
}
/**
 * 
 * @export
 * @interface V3RulesActionsRuleHeader
 */
export interface V3RulesActionsRuleHeader {
    /**
     * 
     * @type {string}
     * @memberof V3RulesActionsRuleHeader
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface V3RulesActionsRules
 */
export interface V3RulesActionsRules {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesActionsRules
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof V3RulesActionsRules
     */
    ruleStatus?: string;
    /**
     * Defines the two day state coverage areas.
     * @type {Array<V3RulesActionsRulesActions>}
     * @memberof V3RulesActionsRules
     */
    actions?: Array<V3RulesActionsRulesActions>;
}
/**
 * Defines the two day state coverage areas.
 * @export
 * @interface V3RulesActionsRulesActions
 */
export interface V3RulesActionsRulesActions {
    /**
     * List of two-day regions.
     * @type {Array<V3RulesActionsRulesTwoDayShippingRegions>}
     * @memberof V3RulesActionsRulesActions
     */
    twoDayShippingRegions?: Array<V3RulesActionsRulesTwoDayShippingRegions>;
}
/**
 * 
 * @export
 * @interface V3RulesActionsRulesSubRegions
 */
export interface V3RulesActionsRulesSubRegions {
    /**
     * subRegionCode
     * @type {string}
     * @memberof V3RulesActionsRulesSubRegions
     */
    subRegionCode?: string;
}
/**
 * List of two-day regions.
 * @export
 * @interface V3RulesActionsRulesTwoDayShippingRegions
 */
export interface V3RulesActionsRulesTwoDayShippingRegions {
    /**
     * regionCode
     * @type {string}
     * @memberof V3RulesActionsRulesTwoDayShippingRegions
     */
    regionCode?: string;
    /**
     * 
     * @type {Array<V3RulesActionsRulesSubRegions>}
     * @memberof V3RulesActionsRulesTwoDayShippingRegions
     */
    subRegions?: Array<V3RulesActionsRulesSubRegions>;
}
/**
 * 
 * @export
 * @interface V3RulesActivateRules
 */
export interface V3RulesActivateRules {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesActivateRules
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof V3RulesActivateRules
     */
    ruleStatus?: string;
}
/**
 * 
 * @export
 * @interface V3RulesCreateRules
 */
export interface V3RulesCreateRules {
    /**
     * 
     * @type {Array<InlineResponse2001Conditions>}
     * @memberof V3RulesCreateRules
     */
    conditions?: Array<InlineResponse2001Conditions>;
    /**
     * Description of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesCreateRules
     */
    description?: string;
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesCreateRules
     */
    name?: string;
    /**
     * Priority of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesCreateRules
     */
    priority?: string;
}
/**
 * 
 * @export
 * @interface V3RulesExceptionsRules
 */
export interface V3RulesExceptionsRules {
    /**
     * 
     * @type {Array<V3RulesExceptionsRulesSkus>}
     * @memberof V3RulesExceptionsRules
     */
    skus?: Array<V3RulesExceptionsRulesSkus>;
}
/**
 * 
 * @export
 * @interface V3RulesExceptionsRulesSkus
 */
export interface V3RulesExceptionsRulesSkus {
    /**
     * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: \':\', \'/\', \'?\', \'#\', \'[\', \']\', \'@\', \'!\', \'$\', \'&\', \"\'\", \'(\', \')\', \'*\', \'+\', \',\', \';\', \'=\', as well as \'%\' itself. Other characters don\'t need to be encoded.
     * @type {string}
     * @memberof V3RulesExceptionsRulesSkus
     */
    sku?: string;
}
/**
 * 
 * @export
 * @interface V3RulesRules
 */
export interface V3RulesRules {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesRules
     */
    ruleId?: string;
    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof V3RulesRules
     */
    ruleStatus?: string;
    /**
     * Name of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesRules
     */
    name?: string;
    /**
     * Description of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesRules
     */
    description?: string;
    /**
     * Priority of the rule created for custom rule assortment.
     * @type {string}
     * @memberof V3RulesRules
     */
    priority?: string;
    /**
     * Seller creates conditions while defining the custom rule assortment.There are three condition which a seller can use : subCategories, price, weight.
     * @type {Array<InlineResponse2001Conditions>}
     * @memberof V3RulesRules
     */
    conditions?: Array<InlineResponse2001Conditions>;
}

/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to activate a rule for a specific ruleId and ruleStatus. Only Rules which are in submitted and inactive state can be activated.
         * @summary Activate rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateRule: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('activateRule', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('activateRule', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('activateRule', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('activateRule', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject3' is not null or undefined
            assertParamExists('activateRule', 'inlineObject3', inlineObject3)
            const localVarPath = `/v3/rules/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API helps you enable or disable the two-day assortment type.
         * @summary Change assortment type
         * @param {boolean} enable 
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {object} body 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAssortmentType: async (enable: boolean, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, body: object, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'enable' is not null or undefined
            assertParamExists('changeAssortmentType', 'enable', enable)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('changeAssortmentType', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('changeAssortmentType', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('changeAssortmentType', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('changeAssortmentType', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changeAssortmentType', 'body', body)
            const localVarPath = `/v3/rules/assortment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (enable !== undefined) {
                localVarQueryParameter['enable'] = enable;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is used to create a rule by selecting any combination of conditions for Sub-category, Price and Weight.
         * @summary Create a new Rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemRule: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createItemRule', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createItemRule', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createItemRule', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createItemRule', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('createItemRule', 'inlineObject1', inlineObject1)
            const localVarPath = `/v3/rules/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is used if any SKU is required to be removed from Two-day delivery settings
         * @summary Create override exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOverrideExceptions: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createOverrideExceptions', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('createOverrideExceptions', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('createOverrideExceptions', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('createOverrideExceptions', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject6' is not null or undefined
            assertParamExists('createOverrideExceptions', 'inlineObject6', inlineObject6)
            const localVarPath = `/v3/rules/exceptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject6, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is used to bring back any SKU to Two-day Delivery settings.
         * @summary Delete exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExceptions: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteExceptions', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('deleteExceptions', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('deleteExceptions', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('deleteExceptions', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject5' is not null or undefined
            assertParamExists('deleteExceptions', 'inlineObject5', inlineObject5)
            const localVarPath = `/v3/rules/exceptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject5, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is used to delete a rule for a specific ruleId and ruleStatus
         * @summary Delete rule
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('deleteRule', 'ruleId', ruleId)
            // verify required parameter 'ruleStatus' is not null or undefined
            assertParamExists('deleteRule', 'ruleStatus', ruleStatus)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteRule', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('deleteRule', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('deleteRule', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('deleteRule', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/{ruleId}/status/{ruleStatus}/`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)))
                .replace(`{${"ruleStatus"}}`, encodeURIComponent(String(ruleStatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use this API to get list of the items defined using \"Create Override Exceptions\".
         * @summary Download exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExceptions: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('downloadExceptions', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('downloadExceptions', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('downloadExceptions', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('downloadExceptions', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/downloadexceptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use this API to download the count of items shortlisted for two-day shipping for a specific rule defined by ruleId and ruleStatus
         * @summary Download simulation result
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSimulationResult: async (ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('downloadSimulationResult', 'ruleId', ruleId)
            // verify required parameter 'ruleStatus' is not null or undefined
            assertParamExists('downloadSimulationResult', 'ruleStatus', ruleStatus)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('downloadSimulationResult', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('downloadSimulationResult', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('downloadSimulationResult', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('downloadSimulationResult', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/{ruleId}/status/{ruleStatus}/simulation`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)))
                .replace(`{${"ruleStatus"}}`, encodeURIComponent(String(ruleStatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a rule detail for a specific ruleId and ruleStatus.
         * @summary Get a rule
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getARule: async (ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('getARule', 'ruleId', ruleId)
            // verify required parameter 'ruleStatus' is not null or undefined
            assertParamExists('getARule', 'ruleStatus', ruleStatus)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getARule', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getARule', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getARule', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getARule', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/{ruleId}/status/{ruleStatus}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)))
                .replace(`{${"ruleStatus"}}`, encodeURIComponent(String(ruleStatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API provides you the list of states on which you can provide two-day shipping of an item.
         * @summary Get all areas
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAreas: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAllAreas', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getAllAreas', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getAllAreas', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getAllAreas', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/areas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API retrieves all the items which has been defined as exceptions using \"Create Override Exception\" API.
         * @summary Gets all exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExceptions: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAllExceptions', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getAllExceptions', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getAllExceptions', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getAllExceptions', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/exceptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API retrieves the details of all the rules defined using \"create an Item rule\" API.
         * @summary Get all rules
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRules: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAllRules', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getAllRules', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getAllRules', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getAllRules', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API provides the complete list of sub-categories which can be used while defining the rule.
         * @summary Get all sub-categories
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubCategories: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAllSubCategories', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getAllSubCategories', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getAllSubCategories', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getAllSubCategories', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/subcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use this API to get the count of items shortlisted for two-day shipping for a specific rule defined by ruleId and ruleStatus
         * @summary Get simulation result
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationResult: async (ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('getSimulationResult', 'ruleId', ruleId)
            // verify required parameter 'ruleStatus' is not null or undefined
            assertParamExists('getSimulationResult', 'ruleStatus', ruleStatus)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getSimulationResult', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('getSimulationResult', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('getSimulationResult', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('getSimulationResult', 'wMSVCNAME', wMSVCNAME)
            const localVarPath = `/v3/rules/{ruleId}/status/{ruleStatus}/simulationcount`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)))
                .replace(`{${"ruleStatus"}}`, encodeURIComponent(String(ruleStatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use this API to inactivate one or more rules for a specific ruleId and ruleStatus.
         * @summary Inactivate rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateRule: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('inactivateRule', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('inactivateRule', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('inactivateRule', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('inactivateRule', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject4' is not null or undefined
            assertParamExists('inactivateRule', 'inlineObject4', inlineObject4)
            const localVarPath = `/v3/rules/inactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API updates a rule defined using \"create an Item rule\". You can update priority, Description, conditions and name of a rule.
         * @summary Update rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateRule', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateRule', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateRule', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateRule', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('updateRule', 'inlineObject2', inlineObject2)
            const localVarPath = `/v3/rules/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API helps you define coverage areas for your items that are held outside of the fulfillment centers defined by your shipNode management API\'s.
         * @summary Update shipping area to rules
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShippingAreaToRule: async (authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateShippingAreaToRule', 'authorization', authorization)
            // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
            assertParamExists('updateShippingAreaToRule', 'wMSECACCESSTOKEN', wMSECACCESSTOKEN)
            // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
            assertParamExists('updateShippingAreaToRule', 'wMQOSCORRELATIONID', wMQOSCORRELATIONID)
            // verify required parameter 'wMSVCNAME' is not null or undefined
            assertParamExists('updateShippingAreaToRule', 'wMSVCNAME', wMSVCNAME)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('updateShippingAreaToRule', 'inlineObject', inlineObject)
            const localVarPath = `/v3/rules/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
                localVarHeaderParameter['WM_SEC.ACCESS_TOKEN'] = String(wMSECACCESSTOKEN);
            }

            if (wMCONSUMERCHANNELTYPE !== undefined && wMCONSUMERCHANNELTYPE !== null) {
                localVarHeaderParameter['WM_CONSUMER.CHANNEL.TYPE'] = String(wMCONSUMERCHANNELTYPE);
            }

            if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
                localVarHeaderParameter['WM_QOS.CORRELATION_ID'] = String(wMQOSCORRELATIONID);
            }

            if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
                localVarHeaderParameter['WM_SVC.NAME'] = String(wMSVCNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to activate a rule for a specific ruleId and ruleStatus. Only Rules which are in submitted and inactive state can be activated.
         * @summary Activate rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject3, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API helps you enable or disable the two-day assortment type.
         * @summary Change assortment type
         * @param {boolean} enable 
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {object} body 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAssortmentType(enable: boolean, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, body: object, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeAssortmentType(enable, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, body, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to create a rule by selecting any combination of conditions for Sub-category, Price and Weight.
         * @summary Create a new Rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject1, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used if any SKU is required to be removed from Two-day delivery settings
         * @summary Create override exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOverrideExceptions(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOverrideExceptions(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject6, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to bring back any SKU to Two-day Delivery settings.
         * @summary Delete exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExceptions(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExceptions(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject5, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to delete a rule for a specific ruleId and ruleStatus
         * @summary Delete rule
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(ruleId, ruleStatus, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can use this API to get list of the items defined using \"Create Override Exceptions\".
         * @summary Download exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadExceptions(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadExceptions(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can use this API to download the count of items shortlisted for two-day shipping for a specific rule defined by ruleId and ruleStatus
         * @summary Download simulation result
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSimulationResult(ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSimulationResult(ruleId, ruleStatus, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a rule detail for a specific ruleId and ruleStatus.
         * @summary Get a rule
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getARule(ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getARule(ruleId, ruleStatus, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API provides you the list of states on which you can provide two-day shipping of an item.
         * @summary Get all areas
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAreas(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAreas(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API retrieves all the items which has been defined as exceptions using \"Create Override Exception\" API.
         * @summary Gets all exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExceptions(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExceptions(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API retrieves the details of all the rules defined using \"create an Item rule\" API.
         * @summary Get all rules
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRules(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRules(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API provides the complete list of sub-categories which can be used while defining the rule.
         * @summary Get all sub-categories
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSubCategories(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSubCategories(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can use this API to get the count of items shortlisted for two-day shipping for a specific rule defined by ruleId and ruleStatus
         * @summary Get simulation result
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimulationResult(ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimulationResult(ruleId, ruleStatus, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can use this API to inactivate one or more rules for a specific ruleId and ruleStatus.
         * @summary Inactivate rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inactivateRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject4, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates a rule defined using \"create an Item rule\". You can update priority, Description, conditions and name of a rule.
         * @summary Update rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject2, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API helps you define coverage areas for your items that are held outside of the fulfillment centers defined by your shipNode management API\'s.
         * @summary Update shipping area to rules
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShippingAreaToRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShippingAreaToRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * This API is used to activate a rule for a specific ruleId and ruleStatus. Only Rules which are in submitted and inactive state can be activated.
         * @summary Activate rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject3} inlineObject3 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject3: InlineObject3, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.activateRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject3, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API helps you enable or disable the two-day assortment type.
         * @summary Change assortment type
         * @param {boolean} enable 
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {object} body 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAssortmentType(enable: boolean, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, body: object, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.changeAssortmentType(enable, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, body, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to create a rule by selecting any combination of conditions for Sub-category, Price and Weight.
         * @summary Create a new Rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject1} inlineObject1 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject1: InlineObject1, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.createItemRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject1, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used if any SKU is required to be removed from Two-day delivery settings
         * @summary Create override exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject6} inlineObject6 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOverrideExceptions(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject6: InlineObject6, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.createOverrideExceptions(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject6, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to bring back any SKU to Two-day Delivery settings.
         * @summary Delete exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject5} inlineObject5 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExceptions(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject5: InlineObject5, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.deleteExceptions(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject5, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to delete a rule for a specific ruleId and ruleStatus
         * @summary Delete rule
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.deleteRule(ruleId, ruleStatus, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use this API to get list of the items defined using \"Create Override Exceptions\".
         * @summary Download exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExceptions(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<string> {
            return localVarFp.downloadExceptions(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use this API to download the count of items shortlisted for two-day shipping for a specific rule defined by ruleId and ruleStatus
         * @summary Download simulation result
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSimulationResult(ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<void> {
            return localVarFp.downloadSimulationResult(ruleId, ruleStatus, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a rule detail for a specific ruleId and ruleStatus.
         * @summary Get a rule
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getARule(ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getARule(ruleId, ruleStatus, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API provides you the list of states on which you can provide two-day shipping of an item.
         * @summary Get all areas
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAreas(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.getAllAreas(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API retrieves all the items which has been defined as exceptions using \"Create Override Exception\" API.
         * @summary Gets all exceptions
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExceptions(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getAllExceptions(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API retrieves the details of all the rules defined using \"create an Item rule\" API.
         * @summary Get all rules
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRules(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getAllRules(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API provides the complete list of sub-categories which can be used while defining the rule.
         * @summary Get all sub-categories
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubCategories(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.getAllSubCategories(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use this API to get the count of items shortlisted for two-day shipping for a specific rule defined by ruleId and ruleStatus
         * @summary Get simulation result
         * @param {string} ruleId Unique identifier of the rule created for custom rule assortment.
         * @param {string} ruleStatus Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationResult(ruleId: string, ruleStatus: string, authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getSimulationResult(ruleId, ruleStatus, authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use this API to inactivate one or more rules for a specific ruleId and ruleStatus.
         * @summary Inactivate rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject4} inlineObject4 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject4: InlineObject4, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.inactivateRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject4, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API updates a rule defined using \"create an Item rule\". You can update priority, Description, conditions and name of a rule.
         * @summary Update rule
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject2} inlineObject2 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject2: InlineObject2, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.updateRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject2, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * This API helps you define coverage areas for your items that are held outside of the fulfillment centers defined by your shipNode management API\'s.
         * @summary Update shipping area to rules
         * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
         * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
         * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
         * @param {string} wMSVCNAME Walmart Service Name
         * @param {InlineObject} inlineObject 
         * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShippingAreaToRule(authorization: string, wMSECACCESSTOKEN: string, wMQOSCORRELATIONID: string, wMSVCNAME: string, inlineObject: InlineObject, wMCONSUMERCHANNELTYPE?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.updateShippingAreaToRule(authorization, wMSECACCESSTOKEN, wMQOSCORRELATIONID, wMSVCNAME, inlineObject, wMCONSUMERCHANNELTYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activateRule operation in RulesApi.
 * @export
 * @interface RulesApiActivateRuleRequest
 */
export interface RulesApiActivateRuleRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiActivateRule
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiActivateRule
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiActivateRule
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiActivateRule
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject3}
     * @memberof RulesApiActivateRule
     */
    readonly inlineObject3: InlineObject3

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiActivateRule
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for changeAssortmentType operation in RulesApi.
 * @export
 * @interface RulesApiChangeAssortmentTypeRequest
 */
export interface RulesApiChangeAssortmentTypeRequest {
    /**
     * 
     * @type {boolean}
     * @memberof RulesApiChangeAssortmentType
     */
    readonly enable: boolean

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiChangeAssortmentType
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiChangeAssortmentType
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiChangeAssortmentType
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiChangeAssortmentType
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {object}
     * @memberof RulesApiChangeAssortmentType
     */
    readonly body: object

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiChangeAssortmentType
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createItemRule operation in RulesApi.
 * @export
 * @interface RulesApiCreateItemRuleRequest
 */
export interface RulesApiCreateItemRuleRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiCreateItemRule
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiCreateItemRule
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiCreateItemRule
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiCreateItemRule
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject1}
     * @memberof RulesApiCreateItemRule
     */
    readonly inlineObject1: InlineObject1

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiCreateItemRule
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for createOverrideExceptions operation in RulesApi.
 * @export
 * @interface RulesApiCreateOverrideExceptionsRequest
 */
export interface RulesApiCreateOverrideExceptionsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiCreateOverrideExceptions
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiCreateOverrideExceptions
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiCreateOverrideExceptions
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiCreateOverrideExceptions
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject6}
     * @memberof RulesApiCreateOverrideExceptions
     */
    readonly inlineObject6: InlineObject6

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiCreateOverrideExceptions
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for deleteExceptions operation in RulesApi.
 * @export
 * @interface RulesApiDeleteExceptionsRequest
 */
export interface RulesApiDeleteExceptionsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiDeleteExceptions
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiDeleteExceptions
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiDeleteExceptions
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiDeleteExceptions
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject5}
     * @memberof RulesApiDeleteExceptions
     */
    readonly inlineObject5: InlineObject5

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiDeleteExceptions
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for deleteRule operation in RulesApi.
 * @export
 * @interface RulesApiDeleteRuleRequest
 */
export interface RulesApiDeleteRuleRequest {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RulesApiDeleteRule
     */
    readonly ruleId: string

    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof RulesApiDeleteRule
     */
    readonly ruleStatus: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiDeleteRule
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiDeleteRule
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiDeleteRule
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiDeleteRule
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiDeleteRule
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for downloadExceptions operation in RulesApi.
 * @export
 * @interface RulesApiDownloadExceptionsRequest
 */
export interface RulesApiDownloadExceptionsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiDownloadExceptions
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiDownloadExceptions
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiDownloadExceptions
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiDownloadExceptions
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiDownloadExceptions
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for downloadSimulationResult operation in RulesApi.
 * @export
 * @interface RulesApiDownloadSimulationResultRequest
 */
export interface RulesApiDownloadSimulationResultRequest {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RulesApiDownloadSimulationResult
     */
    readonly ruleId: string

    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof RulesApiDownloadSimulationResult
     */
    readonly ruleStatus: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiDownloadSimulationResult
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiDownloadSimulationResult
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiDownloadSimulationResult
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiDownloadSimulationResult
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiDownloadSimulationResult
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getARule operation in RulesApi.
 * @export
 * @interface RulesApiGetARuleRequest
 */
export interface RulesApiGetARuleRequest {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RulesApiGetARule
     */
    readonly ruleId: string

    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof RulesApiGetARule
     */
    readonly ruleStatus: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiGetARule
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiGetARule
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiGetARule
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiGetARule
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiGetARule
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getAllAreas operation in RulesApi.
 * @export
 * @interface RulesApiGetAllAreasRequest
 */
export interface RulesApiGetAllAreasRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiGetAllAreas
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiGetAllAreas
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiGetAllAreas
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiGetAllAreas
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiGetAllAreas
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getAllExceptions operation in RulesApi.
 * @export
 * @interface RulesApiGetAllExceptionsRequest
 */
export interface RulesApiGetAllExceptionsRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiGetAllExceptions
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiGetAllExceptions
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiGetAllExceptions
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiGetAllExceptions
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiGetAllExceptions
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getAllRules operation in RulesApi.
 * @export
 * @interface RulesApiGetAllRulesRequest
 */
export interface RulesApiGetAllRulesRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiGetAllRules
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiGetAllRules
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiGetAllRules
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiGetAllRules
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiGetAllRules
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getAllSubCategories operation in RulesApi.
 * @export
 * @interface RulesApiGetAllSubCategoriesRequest
 */
export interface RulesApiGetAllSubCategoriesRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiGetAllSubCategories
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiGetAllSubCategories
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiGetAllSubCategories
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiGetAllSubCategories
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiGetAllSubCategories
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for getSimulationResult operation in RulesApi.
 * @export
 * @interface RulesApiGetSimulationResultRequest
 */
export interface RulesApiGetSimulationResultRequest {
    /**
     * Unique identifier of the rule created for custom rule assortment.
     * @type {string}
     * @memberof RulesApiGetSimulationResult
     */
    readonly ruleId: string

    /**
     * Status of the rule post the rule creation. Allowed values are Active, Inactive, Submitted.
     * @type {string}
     * @memberof RulesApiGetSimulationResult
     */
    readonly ruleStatus: string

    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiGetSimulationResult
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiGetSimulationResult
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiGetSimulationResult
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiGetSimulationResult
     */
    readonly wMSVCNAME: string

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiGetSimulationResult
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for inactivateRule operation in RulesApi.
 * @export
 * @interface RulesApiInactivateRuleRequest
 */
export interface RulesApiInactivateRuleRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiInactivateRule
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiInactivateRule
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiInactivateRule
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiInactivateRule
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject4}
     * @memberof RulesApiInactivateRule
     */
    readonly inlineObject4: InlineObject4

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiInactivateRule
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updateRule operation in RulesApi.
 * @export
 * @interface RulesApiUpdateRuleRequest
 */
export interface RulesApiUpdateRuleRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiUpdateRule
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiUpdateRule
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiUpdateRule
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiUpdateRule
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject2}
     * @memberof RulesApiUpdateRule
     */
    readonly inlineObject2: InlineObject2

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiUpdateRule
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * Request parameters for updateShippingAreaToRule operation in RulesApi.
 * @export
 * @interface RulesApiUpdateShippingAreaToRuleRequest
 */
export interface RulesApiUpdateShippingAreaToRuleRequest {
    /**
     * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @type {string}
     * @memberof RulesApiUpdateShippingAreaToRule
     */
    readonly authorization: string

    /**
     * The access token retrieved in the Token API call
     * @type {string}
     * @memberof RulesApiUpdateShippingAreaToRule
     */
    readonly wMSECACCESSTOKEN: string

    /**
     * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @type {string}
     * @memberof RulesApiUpdateShippingAreaToRule
     */
    readonly wMQOSCORRELATIONID: string

    /**
     * Walmart Service Name
     * @type {string}
     * @memberof RulesApiUpdateShippingAreaToRule
     */
    readonly wMSVCNAME: string

    /**
     * 
     * @type {InlineObject}
     * @memberof RulesApiUpdateShippingAreaToRule
     */
    readonly inlineObject: InlineObject

    /**
     * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @type {string}
     * @memberof RulesApiUpdateShippingAreaToRule
     */
    readonly wMCONSUMERCHANNELTYPE?: string
}

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * This API is used to activate a rule for a specific ruleId and ruleStatus. Only Rules which are in submitted and inactive state can be activated.
     * @summary Activate rule
     * @param {RulesApiActivateRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public activateRule(requestParameters: RulesApiActivateRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).activateRule(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject3, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API helps you enable or disable the two-day assortment type.
     * @summary Change assortment type
     * @param {RulesApiChangeAssortmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public changeAssortmentType(requestParameters: RulesApiChangeAssortmentTypeRequest, options?: any) {
        return RulesApiFp(this.configuration).changeAssortmentType(requestParameters.enable, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.body, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to create a rule by selecting any combination of conditions for Sub-category, Price and Weight.
     * @summary Create a new Rule
     * @param {RulesApiCreateItemRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createItemRule(requestParameters: RulesApiCreateItemRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).createItemRule(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject1, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used if any SKU is required to be removed from Two-day delivery settings
     * @summary Create override exceptions
     * @param {RulesApiCreateOverrideExceptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createOverrideExceptions(requestParameters: RulesApiCreateOverrideExceptionsRequest, options?: any) {
        return RulesApiFp(this.configuration).createOverrideExceptions(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject6, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to bring back any SKU to Two-day Delivery settings.
     * @summary Delete exceptions
     * @param {RulesApiDeleteExceptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteExceptions(requestParameters: RulesApiDeleteExceptionsRequest, options?: any) {
        return RulesApiFp(this.configuration).deleteExceptions(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject5, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to delete a rule for a specific ruleId and ruleStatus
     * @summary Delete rule
     * @param {RulesApiDeleteRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteRule(requestParameters: RulesApiDeleteRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).deleteRule(requestParameters.ruleId, requestParameters.ruleStatus, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use this API to get list of the items defined using \"Create Override Exceptions\".
     * @summary Download exceptions
     * @param {RulesApiDownloadExceptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public downloadExceptions(requestParameters: RulesApiDownloadExceptionsRequest, options?: any) {
        return RulesApiFp(this.configuration).downloadExceptions(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use this API to download the count of items shortlisted for two-day shipping for a specific rule defined by ruleId and ruleStatus
     * @summary Download simulation result
     * @param {RulesApiDownloadSimulationResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public downloadSimulationResult(requestParameters: RulesApiDownloadSimulationResultRequest, options?: any) {
        return RulesApiFp(this.configuration).downloadSimulationResult(requestParameters.ruleId, requestParameters.ruleStatus, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a rule detail for a specific ruleId and ruleStatus.
     * @summary Get a rule
     * @param {RulesApiGetARuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getARule(requestParameters: RulesApiGetARuleRequest, options?: any) {
        return RulesApiFp(this.configuration).getARule(requestParameters.ruleId, requestParameters.ruleStatus, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API provides you the list of states on which you can provide two-day shipping of an item.
     * @summary Get all areas
     * @param {RulesApiGetAllAreasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getAllAreas(requestParameters: RulesApiGetAllAreasRequest, options?: any) {
        return RulesApiFp(this.configuration).getAllAreas(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API retrieves all the items which has been defined as exceptions using \"Create Override Exception\" API.
     * @summary Gets all exceptions
     * @param {RulesApiGetAllExceptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getAllExceptions(requestParameters: RulesApiGetAllExceptionsRequest, options?: any) {
        return RulesApiFp(this.configuration).getAllExceptions(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API retrieves the details of all the rules defined using \"create an Item rule\" API.
     * @summary Get all rules
     * @param {RulesApiGetAllRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getAllRules(requestParameters: RulesApiGetAllRulesRequest, options?: any) {
        return RulesApiFp(this.configuration).getAllRules(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API provides the complete list of sub-categories which can be used while defining the rule.
     * @summary Get all sub-categories
     * @param {RulesApiGetAllSubCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getAllSubCategories(requestParameters: RulesApiGetAllSubCategoriesRequest, options?: any) {
        return RulesApiFp(this.configuration).getAllSubCategories(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use this API to get the count of items shortlisted for two-day shipping for a specific rule defined by ruleId and ruleStatus
     * @summary Get simulation result
     * @param {RulesApiGetSimulationResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getSimulationResult(requestParameters: RulesApiGetSimulationResultRequest, options?: any) {
        return RulesApiFp(this.configuration).getSimulationResult(requestParameters.ruleId, requestParameters.ruleStatus, requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use this API to inactivate one or more rules for a specific ruleId and ruleStatus.
     * @summary Inactivate rule
     * @param {RulesApiInactivateRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public inactivateRule(requestParameters: RulesApiInactivateRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).inactivateRule(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject4, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates a rule defined using \"create an Item rule\". You can update priority, Description, conditions and name of a rule.
     * @summary Update rule
     * @param {RulesApiUpdateRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateRule(requestParameters: RulesApiUpdateRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).updateRule(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject2, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API helps you define coverage areas for your items that are held outside of the fulfillment centers defined by your shipNode management API\'s.
     * @summary Update shipping area to rules
     * @param {RulesApiUpdateShippingAreaToRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateShippingAreaToRule(requestParameters: RulesApiUpdateShippingAreaToRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).updateShippingAreaToRule(requestParameters.authorization, requestParameters.wMSECACCESSTOKEN, requestParameters.wMQOSCORRELATIONID, requestParameters.wMSVCNAME, requestParameters.inlineObject, requestParameters.wMCONSUMERCHANNELTYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


